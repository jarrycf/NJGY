









# 熵

1.serious和dataframe有什么区别



## 负熵

1.api是什么？

​	类的接口

2.矩阵就是二维数组吗？

​	是



# &







# 建模

## 概述

人工智能起点的会议是什么

> 达特茅斯



AI、ML、DL的关系是什么

> ML属于AL
>
> DL属于ML



什么是机器学习

> 数据-模型-预测



数据集由哪两方面构成

> 特征值
>
> 目标值



机器学习的开发流程是哪六步

> 获取数据
>
> 数据处理
>
> 特征工程
>
> 算法训练
>
> 模型评估
>
> 模型应用



获取鸢尾花数据集,及其的特征值、目标值、特征名、目标名
8:2划分数据集，随机数种子22，并查看划分后数据信息

```python
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split

iris = load_iris()
iris

x = iris.data
y = iris["target"]
iris.feature_names
iris.target_names
iris.DESCR

x_train, x_test, y_train, y_test = train_test_split(x, y, test_size = 0.2, random_state = 22)
x_train.shape
x_test.shape
```





机器学习算法可以分成那两类，区别是什么

> 监督学习
>
> 无监督学习
>
> 监督学习有目标值



监督学习又分成哪两类问题

> 分类问题
>
> 回归问题



分类问题的常用算法又哪5个

> KNN
>
> 朴素贝叶斯
>
> 决策树
>
> 随机森林
>
> 逻辑回归



回归问题的常用算法是哪2个

>线性回归
>
>岭回归



无监督的常用方法是哪一个

> K-means



机器学习这门课学哪三个方面

> 特征工程
>
> 分类算法
>
> 回归算法













### 熵

回归与聚类有什么区别

> 





# 特征工程

特征工程包括哪三项

> 特征提取
>
> 特征预处理
>
> 特征降维



提取下面的字典特征 并查看转换后的数据及其特征名
关闭sparse矩阵

{'city': '北京','temperature':100},{'city': '上海','temperature':60},{'city': '深圳','temperature':30}

```python
from sklearn.feature_extraction import DictVectorizer

data = {'city': '北京','temperature':100},{'city': '上海','temperature':60},{'city': '深圳','temperature':30}

transfer = DictVectorizer(sparse=False)
data_new = transfer.fit_transform(data)
data_new
# transfer.get_feature_names()
```



提取下面的文本特征
data = ["life is short,i like python","life is too long,i dislike python"]

```python
from sklearn.feature_extraction.text import CountVectorizer

data = ["life is short,i like python","life is too long,i dislike python"]

transfer = CountVectorizer()
data_new = transfer.fit_transform(data)
data_new.toarray()
transfer.get_feature_names()
```



提取下面的中文文本特征

停用关键词 "一种","所以"

​    data = ["一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。",

​            "我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。",

​            "如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。"]



```python
import jieba

def cut_word(text):
    return " ".join(list(jieba.cut(text)))
```

```python
from sklearn.feature_extraction.text import CountVectorizer

data = ["一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。",

        "我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。",

        "如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。"]

data_new = []
for sent in data:
    data_new.append(cut_word(sent))
# data_new

transfer = CountVectorizer(stop_words=["一种","所以"])

data_final = transfer.fit_transform(data_new)
data_final.toarray()
transfer.get_feature_names()

```



对下面的数据进行归一化[2,3]
./data/datingTestSet2.csv

```python
import pandas as pd
from sklearn.preprocessing import MinMaxScaler

data = pd.read_csv("./data/datingTestSet2.csv")
data

transfer = MinMaxScaler(feature_range = [2,3])

data_new = transfer.fit_transform(data)
data_new
```



归一化的公式是什么

![image-20220501163728051](https://i0.hdslb.com/bfs/album/7ab7f449b95b4e49b07bf880e15504c1314eb082.png)



对下列特征进行归一化

![归一化计算过程](https://i0.hdslb.com/bfs/album/371fedbe7b8dbd4b26fb2d4573b9fb005248f67e.png)





对下面的数据进行标准化

















## 数据清洗

特征清洗包括哪些

> 特征提取
>
> 缺失值处理
>
> 异常值处理



什么时候不需要清洗

> 开源数据



## 特征降维

什么是降维

> 减少特征数



为什么要降维

> 特征间相关性大对算法影响大



如何降维

> 特征选择
>
> 主成分分析



### 特征选择



特征删除彼此相关性大的特征的方法有哪三个形式

> 嵌入式
>
> 过滤式
>
> 包裹式



嵌入式的方法有哪2种

> 低方差过滤
>
> 相关系数



如何计算方差

> ![image-20220421171423549](https://i0.hdslb.com/bfs/album/9c567fe45a8c64d85b34d0a436f8c383b905227a.png)



方差大还是小时相关性大

> 小



相关系数的公式是什么

> ![image-20220421165503736](https://i0.hdslb.com/bfs/album/3c7640cacf1038c1d907eeac64464c415cad29b8.png)



计算下面的相关系数

![广告费表](https://i0.hdslb.com/bfs/album/ee07f5f7bc3ebb966393cac7c81e4f3c2f8e05a3.png)

> ![广告费统计系数结果](https://i0.hdslb.com/bfs/album/c7bff39fdf4ea75a53a68c09a19cca789c447c39.png)
>
> ![相关系数计算数字结果](https://i0.hdslb.com/bfs/album/7cac1a32a51fb1ab8faba74ca4613aa5766ff206.png)
>
> =0.9942



皮尔森相关系数取值范围是多少,趋向哪个时相关系数大

> [-1,1]，1



皮尔森相关系数来自哪个包，英文是什么？

> 科学计算，scipy



降维有哪两种

> 特征选择
>
> PCA



### 主成分分析

PCA的中文是什么

> 主成分分析



将这个二维的数据简化成一维？ 并且损失少量的信息

> 求切线



如何计算

> 矩阵求解



假设对于给定5个点，数据如下，试用求出那条合适的直线

```
(-1,-2)
(-1, 0)
( 0, 0)
( 2, 1)
( 0, 1)
```

![PCA计算图](https://i0.hdslb.com/bfs/album/19af0de353d91a2c5fd7363e47dc497923f6e0f1.png)

> ![PCA运算过程](https://i0.hdslb.com/bfs/album/d25efd353d8944d17446e6bf2d5dab46948cf50a.png)



PCA的API在哪个模块，英文是什么

> 降维
>
> decomposition



保重的n_components为5和0.95分别指什么

> 保留5个整数
>
> 保留95%





低方差、皮尔森、PCA的应用

```python
import pandas as pd
from sklearn.feature_selection import VarianceThreshold
from scipy.stats import pearsonr
from sklearn.decomposition import PCA

# 对 股票预测 数据进行低方差
# 路径 ./data/factor_returns.csv 
data = pd.read_csv("./data/factor_returns.csv")
data = data.iloc[:,1:-2]

#低方差
transfer = VarianceThreshold()
data_new = transfer.fit_transform(data)
data_new

#皮尔森相关系数 'revenue' 和 'total_expense'
r1 = pearsonr(data['revenue'], data['total_expense'])
r1

# PCA主成分分析 data = [[2,3,4,5], [6,3,7,8], [5,4,9,1]]
data = [[2,3,4,5], [6,3,7,8], [5,4,9,1]]
transfer = PCA(n_components= 0.01 )
data_new = transfer.fit_transform(data)
data_new

```







### 熵

三种特征选择间的区别

> 嵌入式：特征与特征，特征与目标值
>
> 过滤式：特征与目标值
>
> 包裹式：算法



方差证明求？

>



皮尔森相关系数怎么求

> 





## KNN

为什么会有KNN

> To solue



KNN解决的问题是什么



什么事KNN



如何解决分类时的等概率



当分类的比例相同，再多一个爱情片，K=7时，是爱情片还是动作片

![image-20220422083320770](https://i0.hdslb.com/bfs/album/f332f60335f2f6c7dbdc92445fd25cac926b05e1.png)

> 动作片



KNN属于哪个模块，哪个接口

> neighbors
>
> KNeighborsClassifer



API的算法有哪4种

> auto
>
> ball_tree
>
> k_tree
>
> brute



用KNN对鸢尾花分类

> ```python
> # KNN分类鸢尾花
> from sklearn.datasets import load_iris
> from sklearn.model_selection import train_test_split
> from sklearn.preprocessing import StandardScaler
> from sklearn.neighbors import KNeighborsClassifier
> 
> iris = load_iris()
> 
> x = iris["data"]
> y = iris.target
> 
> x_train, x_test, y_train, y_test = train_test_split(x, y)
> 
> transfer = StandardScaler()
> x_train = transfer.fit_transform(x_train)
> x_test = transfer.transform(x_test)
> 
> estimator = KNeighborsClassifier(n_neighbors=3)
> estimator.fit(x, y)
> 
> score = estimator.score(x_test, y_test)
> score
> 
> ```
>
> 



KNN对电影进行分类

```python
import pandas as pd
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.neighbors import KNeighborsClassifier

data = pd.read_excel("./data/电影数据集.xlsx")

x_train = data.iloc[1:-2,2:-1]
y_train = data.iloc[1:-2,-1:]
x_test = data.iloc[-1:,2:-1]

transfer = StandardScaler()
x_trian = transfer.fit_transform(x_train)
x_test = transfer.transform(x_test)

estimator = KNeighborsClassifier(n_neighbors=3)
estimator.fit(x_train, y_train)

y_pre = estimator.predict(x_test)
y_pre
```





### 熵

相同的数据、算法和评价，结果为什么会相差这么多

![image-20220422094208987](https://i0.hdslb.com/bfs/album/d4508c885046a8e0429824f5030f17323eeb441c.png)

![image-20220422094217044](https://i0.hdslb.com/bfs/album/8f8574f4d7ec919c9523eda9f098729944908427.png)

![image-20220422094227420](https://i0.hdslb.com/bfs/album/8b6427e37dcb6a43a3bd4202be91328ce96a4711.png)





## 线性回归

如何查看编译器现有的包

> !pip list



对波士顿房价用线性回归进行预测
再画一张预测值（红色）与实际值的比较折线图

```java
#导入波士顿房价预测所需的工具包：数据集、数据划分、预处理、线性回归
#执行步骤 1、导入数据包 2、获取数据 3、数据预处理 4、构建线性回归的模型 # 5、模型评估

from sklearn.datasets import load_boston
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression
import numpy as np
import matplotlib.pyplot as plt

boston = load_boston()

x_train, x_test, y_train, y_test = train_test_split(boston.data, boston.target)

transfer = StandardScaler()
x_train = transfer.fit_transform(x_train)
x_test = transfer.fit_transform(x_test)

estimator = LinearRegression()
estimator.fit(x_train, y_train) 

y_pre = estimator.predict(x_test)
y_pre == y_test

estimator.score(x_test, y_test)

# 画一张预测值（红色）与实际值的比较折线图
# 按排列出预测值的个数并转换成列表a，a作为plot的x轴
# 画布大小宽高为 10*6 x轴标题 “样本” y轴标题 “price”

import matplotlib as mpl
mpl.rcParams["font.family"] = "SimHei"
mpl.rcParams["axes.unicode_minus"]=False

a = np.arange(len(y_pre)).tolist()
# plt.figure(figsize= (10,6))
plt.xlabel('特征')
plt.ylabel('目标')
plt.plot(a,y_pre,color= 'r')#红色是预测值
plt.plot(a,y_test)#准确答案
plt.show()
```







用梯度下降（SGD）正规方程 进行 波士顿房价 的预测

```python
#1.将波士顿房价的案例用正规方程实现（模型训练和评估）；
#2.用梯度下降，SGD方法把波士顿房价再实现，并比较两者的均方误差的结果。

from sklearn.datasets import load_boston
from sklearn.model_selection import train_test_split
from sklearn.preprocessing import StandardScaler
from sklearn.linear_model import LinearRegression, SGDRegressor
from sklearn.metrics import mean_squared_error


def linear1():
    #正规方程的优化方法对波士顿房价进行预测
    #1、获取数据

    boston = load_boston()

    #2、划分数据集
    x_train, x_test, y_train, y_test = train_test_split(boston.data, boston.target, random_state = 22)
   
    #3、标准化
    transfer = StandardScaler()
    x_train = transfer.fit_transform(x_train)
    x_test = transfer.transform(x_test)


    #4、预估器
    estimator = LinearRegression()
    estimator.fit(x_train, y_train)


    #5、得出模型
    print("正规方程权重系数为：\n", estimator.coef_)
    print("正规方程偏置为：\n", estimator.intercept_)

    #6、模型评估
    y_predict = estimator.predict(x_test)
    print("预测房价：\n", y_predict)
    error = mean_squared_error(y_test, y_predict)
    print("正规方程-均方误差为:\n", error)

    return None

def linear2():
    #梯度下降的优化方法对波士顿房价进行预测
    #调参  学习方法"constant"，学习率eta = 0.001 ; 迭代次数 max_iter = 1000

    #1、获取数据

    boston = load_boston()

    #2、划分数据集
    x_train, x_test, y_train, y_test = train_test_split(boston.data, boston.target, random_state = 22)
   
    #3、标准化
    transfer = StandardScaler()
    x_train = transfer.fit_transform(x_train)
    x_test = transfer.transform(x_test)


    #4、预估器
    estimator = SGDRegressor(learning_rate="constant", eta0=0.01, max_iter=10000)
    estimator.fit(x_train, y_train)

    #5、得出模型
    print("梯度下降权重系数为：\n", estimator.coef_)
    print("梯度下降偏置为：\n", estimator.intercept_)

    #6、模型评估
    y_predict = estimator.predict(x_test)
    print("预测房价：\n", y_predict)
    error = mean_squared_error(y_test, y_predict)
    print("梯度下降-均方误差为:\n", error)


    return None


if __name__ == "__main__":
    #代码1:正规方程的优化方法对波士顿房价进行预测
    linear1()
    #代码2:梯度下降的优化方法对波士顿房价进行预测
    linear2()
```









# 课堂纪要



```python
人工智能阶段
    机器学习 三天
    深度学习 三天
    量化交易 四天

传统是机器学习算法
    机器学习概述、特征工程 1天
    分类算法 1天
    回归算法、聚类 1天

机器学习概述
    1.1 人工智能概述
        达特茅斯会议-人工智能的起点
        机器学习是人工智能的一个实现途径
        深度学习是机器学习的一个方法发展而来
        1.1.2 机器学习、深度学习能做些什么
            传统预测
            图像识别
            自然语言处理
    1.2 什么是机器学习
        数据
        模型
        预测
        从历史数据当中获得规律？这些历史数据是怎么的格式
        1.2.3 数据集构成
            特征值 + 目标值
    1.3 机器学习算法分类
        监督学习
            目标值：类别 - 分类问题
                k-临近算法、贝叶斯分类、决策树与随机森林、逻辑回归
            目标值：连续型的数据 - 回归问题
                线性回归、岭回归
        目标值：无 - 无监督学习
            聚类 k-means
        1、预测天的气温是多少度？ 回归
        2、预测明天是阴、晴还是雨？ 分类
        3、人脸年龄预测？ 回归/分类
        4、人脸识别？ 分类

```





```python
特征工程
    2.1 数据集
        2.1.1 可用数据集
            公司内部 百度
            数据接口 花钱
            数据集
            学习阶段可以用的数据集：
                1）sklearn
                2）kaggle
                3）UCI
            1 Scikit-learn工具介绍
        2.1.2 sklearn数据集
            sklearn.datasets
                load_* 获取小规模数据集
                fetch_* 获取大规模数据集
                2 sklearn小数据集
                    skelearn.datasets.load_iris()
                3 sklearn大数据集
                    sklearn.datasets.fetch_20newsgroups(data_home=None,subset=‘train’)
                4 数据集的返回值
                    datasets.base.Bunch(继承自字典)
                        dict['key'] = valuse
                        bunch.key = valuse
                思考 拿到的数据集是否全部都用来训练一个模型
        2.1.3 数据集的划分
            训练模型：用于训练，构建模型
            测试模型：在模型检验时使用，用于评估模型是否有效
                测试集 20%～30%
                sklearn.model_selection.train_test_split(arrays,*options)
                训练集特征值，测试集特征值，训练集目标值，测试集目标值
                x_train,x_test,y_train,y_test
    2.2 特征工程介绍
        算法 特征工程
        2.2.1 为什么需要特征工程
        2.2.2 什么是特征工程
    		sklearn 特征工程
            pandas 数据清洗、数据处理（缺失值）
            特征抽取/特征抽取
                机器学习算法 - 统计方法 - 数学公式
                    文本类型 -》 数值
                    类型 -》 数值 - one-hot编码或哑变量
                2.3.1 特征提取
                    sklearn.feature_extraction
                2.3.2 字典特征提取 - 类别 -> one-hot编码
                    sklearn.feature_extraction.DictVectorizer(sparse = True)
                    vector 数学：向量 物理：矢量
                        矩阵 matrix 二维数组
                        向量 vector 二维数组
                    父类：转换器类
                    返回sparse矩阵
                        sparse稀疏
                            将非零值 按位置表示出来
                            节省内存 - 提高加载效率
                    应用场景
                        1） pclass， sex 数据集当中类别特征比较多
                            1、将数据集的特征-》 字典类型
                            2、DictVectorizer转换
                        2） 本身拿到的数据就是字典类型
                2.3.3 文本特征提取
                    单词 作为 特征
                    句子、短语、单词、字母
                    特征：特征词
                    方法1: CountVectorizer
                        统计每个样本特征词出现的个数
                        stops_words停用词
                        停用词表（自然语言机构）
                    在某一个类别的文章中，出现的次数很多，但是在其他类别的文章当中出现很少
                    方法2:TfidfVectorizer
                        TF-IDF - 重要程度
                        两个词 "经济"，"非常"
                        1000篇文章-语料库
                        100篇文章 - "非常"
                        10篇文章 - "经济"
                        文章A(100词) : 10次"经济" TF-IDF:0.2
                            tf:10/100 = 0.1
                            idf: lg 1000/10 = 2
                        文章B(100词) : 10次"非常" TF-IDF:0.1
                            tf:10/100 = 0.1
                            idf: log 10 1000/100 = 1
                            对数？
                                2 ^ 3 = 8
                                log 2 8 = 3
                                log 10 10 = 1

                        TF - 词频(term frequency,tf)
                        IDF - 逆向文档频率

        2.4 特征预处理
                2.4.1 什么是特征预处理
                为什么我们要进行归一化/标准化？
                    无量纲化
                    2.4.2 归一化
                        异常值：最大值、最小值
                    2.4.3 标准化
                        （x - mean) / std
                        标准差：集中程度

        2.5 特征降维
                2.5.1 降维 - 降低维度
                    ndarray
                        维数：嵌套的层数
                        0维： 标量
                        1维： 向量
                        2维： 矩阵
                        3维： 多个矩阵
                        n维：
                    二维数组
                        此处的降维：
                        降低特征的个数
                        效果：
                        特征与特征之间不相关（不冗余）
                2.5.1 降维
                    特征选择
                        Filter过滤式
                            方差选择法：低方差特征过滤
                            相关系数 - 特征与特征之间的相关程度
                                取值范围：–1≤ r ≤+1
                                皮尔逊相关系数
                                0.9942
                                特征与特征之间相关性很高：
                                    1）选取其中一个
                                    2）加权求和（新特征）
                                    3）主成分分析

                        Embeded嵌入式
                            决策树 第二天
                            正则化 第三天
                            深度学习 第五天
                    主成分分析(PCA)
                        sklearn.decomposition.PCA(n_components=None)
                        n_components
                        小数 表示保留百分之多少的信息
                        整数 减少到多少特征
                2.6.2 案例：探究用户对物品类别的喜好细分降维
                    用户      物品类别
                    user_id  aisle
                    1）需要将user_id和aisle放在同一个表中 - 合并
                    2）找到user_id和aisle - 交叉表和透视表
                    3）特征冗余过多 - PAC降维

```

```
分类算法

目标：分类
1、sklearn转换器和预估器
2、KNN算法
3、模型选择与调优
4、朴素贝叶斯算法
5、决策树
6、随机森林


    3.1 sklearn转换器和估计器
        转换器
        估计器（estimator）
        3.1.1 转换器 - 特征工程的父类
            1 实例化（实例化的是一个转换器类（Transformer）
            2 调用fit_transform(对于文档建立分类词频矩阵，不能同时调用)
            标准化：
                （x - mean) / std
                fit_transform（）
                fit()               计算 每一列的平均值、标准差
                transform()         （x - mean) / std进行最终的转换
        3.1.2 估计器（sklearn机器学习算法的实现）
            估计器
                1 实例化一个estimator
                2 estomator.fit(x_train, y_train) 计算
                    —— 调用完毕，模型生成
                3 模型评估
                    1）直接对比真实值和预测值
                        y_predict == estimator.predict(x_test)
                        y_test == y_predict
                    2) 计算准确率
                        estimator.score(x_test, y_test)
    3.2 KNN算法
        3.2.1 什么是k—近临算法
            KNN核心思想：
                你的“邻居”来推断出你的类型
            1 K-近邻算法（KNN）原理
                K = 1
                    容易受到异常点的影响
                如何确定谁是邻居
                计算距离：
                    距离公式
                        最常用 欧式距离
                        曼哈顿距离 绝对值距离
                        明可夫斯基距离（欧式距离（p=2)和曼哈顿距离(p=1)都是它的一种特殊推广）
            2 电影类别分析
                k = 1 爱情片
                k = 2 爱情片
                ……
                k = 6 无法确定
                k = 7 动作片

                如果取的最近的电影数量不一样？会是什么结果？
                    k 值取得过小，容易受到异常点的影响
                    k 值取得过大，样本不均衡的影响
                综合前面的约会对象数据，分析K-邻近算法需要做什么样的处理
                    无量纲化的处理
                        标准化
                sklearn.neighbors.KNeighborsClassifier(n_neighbors = 5,)
            3.2.3 案例1:鸢尾花种类预测
                1）测试数据
                2）数据集划分
                3）特征工程
                    标准化
                4）KNN预估器流程
                5）模型评估
            3.2.4 K-近邻总结
                优点：简单、易于理解、无需训练
                缺点：
                    1)必须指定K值，K值选择不当则分类精度不能保证
                    2)
                使用场景：小数据场景，几千～几万样本，具体场景具体业务去测试
            3.3 模型选择与调优
                3.3.1 什么是交叉验证（cross validation）
                3.2.2 超参数搜索 - 网格搜索（Grid Search)
                    k的取值
                        [1, 3, 5, 7, 9, 11]
                        暴力破解
                3.3.3 鸢尾花案例增加k值调优
                3.3.4 案例：预测facebook签到位置
                    案例分析：
                        1) 获取数据
                        2）数据处理
                        目的:
                            特征值 x
                            目标值 y
                            a.缩小数据范围
                              2 < x < 2.5
                              1.0 < y < 1.5
                              b.time -> 年月日时分秒
                              c.过滤签到次数少的地点
                              数据集划分
                          3）特征工程：标准化
                          4）KNN算法预估流程
                          5）模型选择与调优
                          6）模型评估
          3.4 朴素贝叶斯
            3.4.1 什么是朴素贝叶斯
            3.4.2 概率基础
                1 概率（Probability)定义
                3.4.3 联合概率、条件概率与相互独立
                    联合概率：包含多个条件，且所有条件同时成立的概率
                    P(程序员, 匀称) P(程序员, 超重｜喜欢)
                    P(A, B)
                    条件概率：就是事件A在另外一个事件B已经发生条件下的发生概率
                    P（程序员|喜欢） P(程序员，超重｜喜欢)
                    P(A|B)
                    相互独立：
                        P(A, B) = P(A)P(B) <=> 事件A与事件B相互独立
                朴素？
                    假设：特征与特征之间是相互独立
                朴素贝叶斯算法:
                    朴素 + 贝叶斯
                应用场景:
                    文本分类
                    单词做为特征
                拉普拉斯平滑系数
            3.4.6 案例：20类新闻分类
                1）获取数据
                2）划分数据集
                3）特征工程
                    文本特征抽取
                4）朴素贝叶斯预估器流程
                5）模型评估
            3.4.7 朴素贝叶斯算法总结
                优点：
                    对缺失数据不太敏感，算法也比较简单，常用于文本分类。
                    分类精确度高，速度快
                缺点：
                    由于使用了样本属性独立性的假设，所以如果特征属性有关联时其效果不好

                    我爱北京天安门


3.5 决策树
    3.5.1 认识决策树
        如何高效的进行决策？
            特征的先后顺序
    3.5.2 决策树分类原理详解
        已知 四个特征值 预测 是否贷款给某个人
        先看房子，再工作 -> 是否贷款 只看了两个特征
        年龄，信贷情况， 工作 看了三个特征
    信息论基础
        1）信息
            香农：消除随机不定性的东西
            小明 年龄 “我今年18岁” - 信息
            小华 ”小明明年19岁” - 不是信息
        2）信息的衡量 - 信息量 - 信息熵
            bit
            g(D,A) = H(D) - 条件熵H（D｜A）
        4 决策树的划分依据之一 —————————— 信息增益
        没有免费的午餐
    3.5.5 决策树可视化
    3.5.6 决策树总结
        优点：
            可视化 - 可解释能力强
        缺点：
            任意产生过拟合
    3.5.4 案例：泰坦尼克号乘客生存预测
        流程分析：
            特征值 目标值
            1）获取数据
            2）数据处理
                缺失值处理
                特征值 -> 字典类型
            3）准备好特征值 目标值
            4）划分数据集
            5）特征工程：字典特征抽取
            6）决策树预估器流程
            7）模型评估


            
3.6 集成学习方法之随机森林
    3.6.1 什么是集成学习方法
    3.6.2 什么是随机森林
        随机
        森林：包含多个决策树的分类器
    3.6.3 随机森林原理过程
        训练集：
        N个样本
        特征值 目标值
        M个特征
        随机
            两个随机
                训练集随机 - N个样本中随机有放回的抽样N个
                    bootstrap 随机有放回抽样
                    [1, 2, 3, 4, 5]
                    新的树的训练集
                    [2, 2, 3, 1, 5]
                特征随机 - 从M个特征中随机抽取m个特征
                    M >> m
                    降维
    3.6.6 总结
        能够有效地运行在大数据集上，
        处理具有高纬特征地输入样本，而且不需要降纬

```



```
回归和聚类

线性回归
欠拟合与过拟合
岭回归

分类算法：逻辑回归

模型保存与加载

无监督学习 k-means算法


4.1 线性回归
    回归问题
        目标值 - 连续的数据
    4.1.1 线性回归的原理
        2 什么是线性回归
            函数关系 特征值和目标值
            线性模型
                线性关系
            y = w1x1 + w2x2 + w3x3 + …… +  wnxn + b
              = wTx + b
            数据挖掘基础
            y = kx + b
            y = w1x1 + w2x2 + b
            y = 0.7x1 + 0.3x2
            期末成绩：0.7 * 期末成绩 + 0.3 * 平时成绩
            [8, 2] * [2, 1] = [8, 1]
            广义线性模型
                非线性关系?
                线性模型
                    自变量一次
                        y = w1x1 + w2x2 + w3x3 + …… +  wnxn + b
                    参数(w1,w2)一次
                        y = w1x1 + w2x1^2 + w3x1^3 + w4x2^3 + …… + b
                    线性关系&线性模型
                    线性关系一定是线性模型，线性模型不一定线性关系
            4.1.2 线性回归的损失和优化原理（理解记忆）
            目标：求模型参数
                模型参数能够使得预测准确
            真实关系：真实房子价格 = 0.02×中心区域的距离 + 0.04×城市一氧化氮浓度 + (-0.12×自住房平均房价) + 0.254×城镇犯罪率
            随意假定：预测房子价格 = 0.25×中心区域的距离 + 0.14×城市一氧化氮浓度 + 0.42×自住房平均房价 + 0.34×城镇犯罪率
            损失函数/cost/成本函数/目标函数：
                最小二乘法
            优化函数
                优化方法？
                正规方程
                    天才 - 直接求解W
                    拓展：
                    1）
                        y = ax^2 + bx + c
                        y' = wax + b = 0
                        x = - b / 2a
                        矩阵求导^
                    2)
                    B = A ^ -1

                梯度下降
                    勤奋努力的普通人
                        试错、改进
            4.1.4 波士顿房价预测
                流程：
                    1）获取数据集
                    2）划分数据集
                    3）特征工程
                        无量纲化 - 标准化
                    4）预估器流程
                        fit() --> 模型
                        coef_ intercept_
                    5) 模型评估
            回归的性能评估
                均方误差
            4 正规方程和梯度下降对比
4.2 欠拟合与过拟合
    训练集上表现得好，测试集上不好 - 过拟合
    4.2.1 什么是过拟合与欠拟合
        欠拟合
            学习到数据到特征过少
            解决：
                增加数据的特征数量
        欠拟合
            原始特征过多，存在一些嘈杂特征，模型过于复杂是因为模型尝试去兼顾各个测试数据点
            解决：
                正则化
                    L1
                    损失函数 + λ惩罚项
                    LASSO
                    L2 更常用
                    损失函数 + λ惩罚项
                    Ridge - 岭回归
4.3 线性回归的改进-岭回归
    4.3.1 带有L2正则化的线性回归-岭回归
        alpha 正则化力度 = 惩罚项系数
4.4 分类算法-逻辑回归与二分类
    4.4.1 逻辑回归的应用场景
        广告点击率 是否会被点击
        是否为垃圾邮件
        是否患病
        是否为金融诈骗
        是否为虚假账号
        正例/反例
    4.4.2 逻辑回归的原理
        线性回归的输出 就是 逻辑回归 的 输入
        激活函数
            sigmoid函数[0, 1]
            1/(1 + e^(-x))
        假设函数/线性模型
            1/（1 + e^(-（w1*1 + w2*2 + w3*3 + …… + wnxn + b))）
        损失函数
            (y_predict - y_true)平方和/总数
            逻辑回归的真实值/预测值 是否属于某个类别
            对数似然损失
            log 2 x
        优化损失
            梯度下降
    4.4.4 案例：癌症分类预测-良／恶性乳腺癌肿瘤预测
        恶性 -  正例
        流程分析
            1）获取数据
                读取的时候加上name
            2）数据处理
                处理缺失值
            3）数据集划分
            4）特征工程
                无量纲化处理 - 标准化
            5）逻辑回归预估器
            6）模型评估
    真的患癌症的，能够被检查出来的概率 - 召回率
    4.4.5 父类的评估方法
        1 精确率与召回率
            1 混淆矩阵
                TP = True Possitive
                FN = False Negative
            2 精确率（Precision)与召回率（Recall）
                精确率
                召回率 查得全不全
                工厂 质量检查 次品 召回率
            3 F1 - score 模型的稳健型
        总共有100个人，如果99个样本癌症，1个样本非癌症 - 样本不均衡
        不管怎样我全都预测正例（默认癌症为正例）- 不负责任的模型
        准确率：99%
        召回率：99/99 = 100%
        精确率：99%
        F1-score：2 * 99% * 100% / 199% = 99.497%
        AUC:
            TPR = 100%
            FPR = 1 / 1 = 100%
    2 ROC曲线与AUC指标
        1 知道TPR与FPR
            TPR = TP / （TP + FN） - 召回率
                所有真实类别为1的样本中，预测类别为1的比例
            FPR = FP / (FP + TN)
                所有真实类别为0对样本中，预测类别为1的比例
4.5 模型保存和加载
4.6 无监督学习 - K-means算法
    4.6.1 什么是无监督学习
        没有目标值 - 无监督学习
    4.6.2 无监督学习包含算法
        聚类
        K-means(K均值聚类)
        降维
        PCA
    4.6.3 K-means原理
    4.6.5 案例：k-means对Instacart Market用户聚类
        k = 3
        流程分析：
        降维之后的数据
        1）预估器流程
        2）看结果
        3）模型评估
    4.6.6 Kmeans性能评估指标
        轮廓系数 高内聚低耦合
        如果b_i>>a_i:趋近于1效果越好，
        b_i<<a_i:趋近于-1，效果不好。
        轮廓系数的值是介于 [-1,1] ，
        越趋近于1代表内聚度和分离度都相对较优。
    4.6.7 K-means总结
        应用场景：
            没有目标值
            父类

```

# 拟合数据

![image-20220422195216112](https://i0.hdslb.com/bfs/album/343f5c1b5092d3c244065d50cb11f45f3eae95ae.png)



> 一个返回的事datafram和serious





# mat

1.figsize=(长，宽)，单位：英尺



#   1.机器学习概述

+ 了解机器学习定义以及应用场景
+ 说明机器学习算法监督学习与无监督学习的区别
+ 说明监督学习中的分类、回归特点
+ 说明机器学习算法目标值的两种数据类型
+ 说明机器学习(数据挖掘)的开发流程

定位

- 课程以算法、案例为驱动的学习，伴随浅显易懂的数学知识
- 作为人工智能领域(数据挖掘/机器学习方向)的提升课程，掌握更深更有效的解决问题技能

目标

- 应用Scikit-learn实现数据集的特征工程
- 掌握机器学习常见算法原理
- 应用Scikit-learn实现机器学习算法的应用，结合场景解决实际问题





## 1.1 人工智能概述

1.1.1 机器学习与人工智能、深度学习

![人工智能范围](https://i0.hdslb.com/bfs/album/08d48c0627f8f29b8d6ea3853b863f2798c51ebb.png)

- 机器学习和人工智能，深度学习的关系
  - 机器学习是人工智能的一个实现途径
  - 深度学习是机器学习的一个方法发展而来

- 达特茅斯会议-人工智能的起点

  1956年8月，在美国汉诺斯小镇宁静的达特茅斯学院中，

  约翰·麦卡锡（John McCarthy）:对弈算法

  <img src="https://i0.hdslb.com/bfs/album/7c2d3df0aa563ef826169f8dee9a0a6e06700165.png" alt="image-20220215141547184" style="zoom:50%;" />

  马文·闵斯基（Marvin Minsky，人工智能与认知学专家）

  <img src="https://i0.hdslb.com/bfs/album/3d7c0238fdddbb113ad76d7e2af1cd1639836367.png" alt="image-20220215141804767" style="zoom:50%;" />

  克劳德·香农（Claude Shannon，信息论的创始人）

  <img src="https://i0.hdslb.com/bfs/album/1b3abb60048ec2882974256a9eafd37617523891.png" alt="image-20220215141918837" style="zoom:50%;" />

  艾伦·纽厄尔（Allen Newell，计算机科学家）

  <img src="https://i0.hdslb.com/bfs/album/ef2cf94244a0c40d9c8830e6f6078cf42784bf6c.png" alt="image-20220215141730463" style="zoom:50%;" />

  赫伯特·西蒙（Herbert Simon，诺贝尔经济学奖得主）
  
  <img src="https://i0.hdslb.com/bfs/album/f8e3112bec2ca3018be5931619b12ca64feafc5d.png" alt="image-20220215141615613" style="zoom:50%;" />
  
  
  
  等科学家（前后47人）正聚在一起，讨论着一个完全不食人间烟火的主题：
  
  **用机器来模仿人类学习以及其他方面的智能。**
  
  会议足足开了两个月的时间（6月18-8月17） ，虽然大家没有达成普遍的共识，但是却为会议讨论的内容起了一个名字：
  
  [人工智能](https://baike.baidu.com/item/人工智能)
  
  因此，1956年也就成为了人工智能元年。
  
  ![image-20220215142718380](https://i0.hdslb.com/bfs/album/ca18e37ccea8bc3985c8136f2a8a0ea31b177a52.png)

他们对什么感兴趣？

- 如何对机器编程以更好利用计算机的能力
-  如何让计算机理解和使用语言
- 如何用神经网络来表达概念
- 如何定义，计算效率和复杂性
- 如何实现机器的自我改进
- 如何实现对象的抽象表示
- 如何实现随机性和创造性



   

1.1.2 机器学习、深度学习能做些什么

**机器学习的应用场景非常多，可以说渗透到了各个行业领域当中。医疗、航空、教育、物流、电商等等领域的各种场景。**

![img](https://i0.hdslb.com/bfs/album/b0036d83e1bc0a6bf77ab576b0129e017c6445a6.png)

- 用在挖掘、预测领域：

  - 应用场景：店铺销量预测、量化投资、广告推荐、企业客户分类、SQL语句安全检测分类…

- 用在图像领域：

  - 应用场景：街道交通标志检测、人脸识别等等

    ![img](https://i0.hdslb.com/bfs/album/0fcbb40ee80dfd9f7ada3882148f4f7cd87811de.png)

- 用在自然语言处理领域：

  - ![img](https://i0.hdslb.com/bfs/album/06819e54300383822a4947ae1562cbad6da19594.png)

**当前重要的是掌握一些机器学习算法等技巧，从某个业务领域切入解决问题。**

1.1.3 人工智能阶段课程安排

![img](https://i0.hdslb.com/bfs/album/ed80876878f5ecb05ac13e2fd371aa6ab3c04455.png)









## 1.2 什么是机器学习

1.2.1 定义

机器学习是从**数据**中**自动分析获得模型**，并利用**模型**对未知数据进行预测。

1.2.2 解释

- 我们人从大量的日常经验中归纳规律，当面临新的问题的时候，就可以利用以往总结的规律去分析现实状况，采取最佳策略。

![img](https://i0.hdslb.com/bfs/album/70fd3bdf2f3d99118c825a285fbe837096b4b1a8.png)

- 从数据（大量的猫和狗的图片）中自动分析获得模型（辨别猫和狗的规律），从而使机器拥有识别猫和狗的能力。

![img](https://i0.hdslb.com/bfs/album/a0faccacbf6e7d81a6ce5a4632f0705638689804.png)

- 从数据（房屋的各种信息）中自动分析获得模型（判断房屋价格的规律），从而使机器拥有预测房屋价格的能力。

**从历史数据当中获得规律？这些历史数据是怎么的格式？**

1.2.3 数据集构成

- 结构：特征值+目标值

![数据集结构](https://i0.hdslb.com/bfs/album/b0df1c7943fb7152a7b04b4e3a3cf23abcefa752.png)

> 注：
>
> - 对于每一行数据我们可以称之为**样本**。
> - 有些数据集可以没有目标值：

![img](https://i0.hdslb.com/bfs/album/ea4caaa050da394ddd519696888652f73e344cb7.png)



## 1.3 机器学习算法分类

学习目标

- 目标
  - 说明机器学习算法监督学习与无监督学习的区别
  - 说明监督学习中的分类、回归特点
- 应用
  - 无

 分析1.2中的例子：

![img](https://i0.hdslb.com/bfs/album/70fd3bdf2f3d99118c825a285fbe837096b4b1a8.png)

- 特征值：猫/狗的图片；目标值：猫/狗-类别
  - 分类问题

![img](https://i0.hdslb.com/bfs/album/a0faccacbf6e7d81a6ce5a4632f0705638689804.png)

- 特征值：房屋的各个属性信息；目标值：房屋价格-连续型数据
  - 回归问题

![img](https://i0.hdslb.com/bfs/album/ea4caaa050da394ddd519696888652f73e344cb7.png)

- 特征值：人物的各个属性信息；目标值：无
  - 无监督学习

1.3.1 总结

![监督学习无监督学习区别](https://i0.hdslb.com/bfs/album/1eced58d599038454106fe642e0c60afdf56e79a.png)

1.3.2 练习

说一下它们具体问题类别：

1、预测明天的气温是多少度？

2、预测明天是阴、晴还是雨？

3、人脸年龄预测？

4、人脸识别？

1.3.3 机器学习算法分类

- 监督学习(supervised learning)（预测）
  - 定义：输入数据是由输入特征值和目标值所组成。函数的输出可以是一个连续的值(称为回归），或是输出是有限个离散值（称作分类）。
  - **分类 k-近邻算法、贝叶斯分类、决策树与随机森林、逻辑回归、神经网络**
  - **回归 线性回归、岭回归**
- 无监督学习(unsupervised learning)
  - 定义：输入数据是由输入特征值所组成。
  - **聚类 k-means**





## 1.4 机器学习开发流程

![img](https://i0.hdslb.com/bfs/album/9287b5cfdf27a703897368e9bb85788094f46eb9.png)

- 流程图：

![开发流程](https://i0.hdslb.com/bfs/album/6642ed202fca023f724555d77df95104329537e2.png)1.5 学习框架和资料介绍

需明确几点问题：

（1）**算法**是核心，**数据**与**计算**是基础

（2）找准定位

大部分复杂模型的算法设计都是算法工程师在做，而我们

- 分析很多的数据
- 分析具体的业务
- 应用常见的算法
- 特征工程、调参数、优化

![img](https://i0.hdslb.com/bfs/album/ed57bd8d4b9133c4547e127bff0af3c30017c158.png)

- 我们应该怎么做？
- 学会分析问题，使用机器学习算法的目的，想要算法完成何种任务
- 掌握算法基本思想，学会对问题用相应的算法解决
- 学会利用库或者框架解决问题

**当前重要的是掌握一些机器学习算法等技巧，从某个业务领域切入解决问题。**





1.5.1 机器学习库与框架

![框架](https://i0.hdslb.com/bfs/album/38d8782e4c55cf36f5ef030aa69901ed1b4f2617.png)

1.5.2 书籍资料

![学习书籍](https://i0.hdslb.com/bfs/album/5f9e6dc84cd494528e4c20b245b38886d6f075ea.png)

1.5.3 提深内功（但不是必须）

![深度学习](https://i0.hdslb.com/bfs/album/a43260fc078c65858a551621397e9adc12377dec.png)









# 2.特征工程

- 了解特征工程在机器学习当中的重要性
- 应用sklearn实现特征预处理
- 应用sklearn实现特征抽取
- 应用sklearn实现特征选择
- 应用PCA实现特征的降维



## 2.1 数据集

- 目标
  - 知道数据集的分为训练集和测试集
  - 会使用sklearn的数据集
- 应用
  - 无

2.1.1 可用数据集

![img](https://i0.hdslb.com/bfs/album/d73d39f89a57cf5224702a9bac65bc0e3528a202.png)

Kaggle网址：https://www.kaggle.com/datasets

UCI数据集网址： http://archive.ics.uci.edu/ml/

scikit-learn网址：[http://scikit-learn.org/stable/datasets/index.html#datasets](http://scikit-learn.org/stable/datasets/index.html)

1 Scikit-learn工具介绍

![scikitlearn](https://i0.hdslb.com/bfs/album/d58819b4dd756bf8ddef2b950d280f7f8a09fedc.png)

- Python语言的机器学习工具
- Scikit-learn包括许多知名的机器学习算法的实现
- Scikit-learn文档完善，容易上手，丰富的API
- 目前稳定版本0.19.1

2 安装

```
pip3 install Scikit-learn==0.19.1
```

安装好之后可以通过以下命令查看是否安装成功

```python
import sklearn
```

- 注：安装scikit-learn需要Numpy, Scipy等库

3 Scikit-learn包含的内容

![image-20220120154318032](https://i0.hdslb.com/bfs/album/2169635d61e85dd9657a5c43dd95457c7d9c3f96.png)

- 分类、聚类、回归
- 特征工程
- 模型选择、调优

2.1.2 sklearn数据集

1 scikit-learn数据集API介绍

- sklearn.datasets
  - 加载获取流行数据集
  - datasets.load_*()
    - 获取小规模数据集，数据包含在datasets里
  - datasets.fetch_*(data_home=None)
    - 获取大规模数据集，需要从网络上下载，函数的第一个参数是data_home，表示数据集下载的目录,默认是 ~/scikit_learn_data/

2 sklearn小数据集

- sklearn.datasets.load_iris()

  加载并返回鸢尾花数据集

![img](https://i0.hdslb.com/bfs/album/10dcb05a4f0d4bff5c4c0f01046ea8e5e0ab16e1.png)

- sklearn.datasets.load_boston()

  加载并返回波士顿房价数据集

![img](https://i0.hdslb.com/bfs/album/5cfdfe79fe32d179abbc2d2af353640a135b49f7.png)

3 sklearn大数据集

- sklearn.datasets.fetch_20newsgroups(data_home=None,subset=‘train’)
  - subset：'train'或者'test'，'all'，可选，选择要加载的数据集。
  - 训练集的“训练”，测试集的“测试”，两者的“全部”

4 sklearn数据集的使用

- 以鸢尾花数据集为例：

  ![img](https://i0.hdslb.com/bfs/album/cfe63b9b73e6c3f26aee700646985c4f71265db6.png)

**sklearn数据集返回值介绍**

- load

  和fetch

  返回的数据类型datasets.base.Bunch(字典格式)

  - data：特征数据数组，是 [n_samples * n_features] 的二维 numpy.ndarray 数组
  - target：标签数组，是 n_samples 的一维 numpy.ndarray 数组
  - DESCR：数据描述
  - feature_names：特征名,新闻数据，手写数字、回归数据集没有
  - target_names：标签名

```python
from sklearn.datasets import load_iris
# 获取鸢尾花数据集
iris = load_iris()
print("鸢尾花数据集的返回值：\n", iris)
# 返回值是一个继承自字典的Bench
print("鸢尾花的特征值:\n", iris["data"])
print("鸢尾花的目标值：\n", iris.target)
print("鸢尾花特征的名字：\n", iris.feature_names)
print("鸢尾花目标值的名字：\n", iris.target_na  mes)
print("鸢尾花的描述：\n", iris.DESCR)
```

**思考：拿到的数据是否全部都用来训练一个模型？**

2.1.3 数据集的划分

机器学习一般的数据集会划分为两个部分：

- 训练数据：用于训练，**构建模型**
- 测试数据：在模型检验时使用，用于**评估模型是否有效**

划分比例：

- 训练集：70% 80% 75%
- 测试集：30% 20% 30%

**数据集划分api**

- sklearn.model_selection.train_test_split(

  arrays, *

  options)

  - x 数据集的特征值
  - y 数据集的标签值
  - test_size 测试集的大小，一般为float
  - random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。
  - return 测试集特征训练集特征值值，训练标签，测试标签(默认随机取)

```python
from sklearn.datasets import load_iris
from sklearn.model_selection import train_test_split


def datasets_demo():
    """
    对鸢尾花数据集的演示
    :return: None
    """
    # 1、获取鸢尾花数据集
    iris = load_iris()
    print("鸢尾花数据集的返回值：\n", iris)
    # 返回值是一个继承自字典的Bench
    print("鸢尾花的特征值:\n", iris["data"])
    print("鸢尾花的目标值：\n", iris.target)
    print("鸢尾花特征的名字：\n", iris.feature_names)
    print("鸢尾花目标值的名字：\n", iris.target_names)
    print("鸢尾花的描述：\n", iris.DESCR)

    # 2、对鸢尾花数据集进行分割
    # 训练集的特征值x_train 测试集的特征值x_test 训练集的目标值y_train 测试集的目标值y_test
    x_train, x_test, y_train, y_test = train_test_split(iris.data, iris.target, random_state=22)
    print("x_train:\n", x_train.shape)
    # 随机数种子
    x_train1, x_test1, y_train1, y_test1 = train_test_split(iris.data, iris.target, random_state=6)
    x_train2, x_test2, y_train2, y_test2 = train_test_split(iris.data, iris.target, random_state=6)
    print("如果随机数种子不一致：\n", x_train == x_train1)
    print("如果随机数种子一致：\n", x_train1 == x_train2)

    return None
```





## 2.2 特征工程介绍

学习目标

- 目标
  - 了解特征工程在机器学习当中的重要性
  - 知道特征工程的分类
- 应用
  - 无

![img](https://i0.hdslb.com/bfs/album/6a8074cea3d64d49e76bece8d85716debfac347b.png)

2.2.1 为什么需要特征工程(Feature Engineering)

> 机器学习领域的大神Andrew Ng(吴恩达)老师说“Coming up with features is difficult, time-consuming, requires expert knowledge. “Applied machine learning” is basically feature engineering. ”
>
> 注：业界广泛流传：数据和特征决定了机器学习的上限，而模型和算法只是逼近这个上限而已。

2.2.2 什么是特征工程

特征工程是使用**专业背景知识和技巧处理数据**，**使得特征能在机器学习算法上发挥更好的作用的过程**。

- 意义：会直接影响机器学习的效果

2.2.3 特征工程的位置与数据处理的比较

![特征工程过程](https://i0.hdslb.com/bfs/album/b2a97fb4341195805b1ea18925ed821e1028cf72.png)

- pandas:一个数据读取非常方便以及基本的处理格式的工具
- sklearn:对于特征的处理提供了强大的接口

**特征工程包含内容**

- 特征抽取
- 特征预处理
- 特征降维







## 2.3 特征提取

学习目标

- 目标
  - 应用DictVectorizer实现对类别特征进行数值化、离散化
  - 应用CountVectorizer实现对文本特征进行数值化
  - 应用TfidfVectorizer实现对文本特征进行数值化
  - 说出两种文本特征提取的方式区别
- 应用
  - 无

什么是特征提取呢？

![文本特征提取图](https://i0.hdslb.com/bfs/album/014306f2a6a634d14ccd5dc61f9acd647fc70716.png)

![字典特征提取图](https://i0.hdslb.com/bfs/album/f1e043262f0bb927b1da13d675a6139fc74f2547.png)

2.3.1 特征提取

1 将任意数据（如文本或图像）转换为可用于机器学习的数字特征

> 注：特征值化是为了计算机更好的去理解数据

- 字典特征提取(特征离散化)
- 文本特征提取
- 图像特征提取（深度学习将介绍）

2 特征提取API

```python
sklearn.feature_extraction
```

2.3.2 字典特征提取

**作用：对字典数据进行特征值化**

- sklearn.feature_extraction.DictVectorizer(sparse=True,…)
  - DictVectorizer.fit_transform(X) X:字典或者包含字典的迭代器返回值：返回sparse矩阵
  - DictVectorizer.inverse_transform(X) X:array数组或者sparse矩阵 返回值:转换之前数据格式
  - DictVectorizer.get_feature_names() 返回类别名称

1 应用

我们对以下数据进行特征提取

```python
[{'city': '北京','temperature':100}
{'city': '上海','temperature':60}
{'city': '深圳','temperature':30}]
```

![dictvec结果](https://i0.hdslb.com/bfs/album/44097ea344862d32ce98e0b9bc2d0ce5330b29f0.png)

2 流程分析

- 实例化类DictVectorizer
- 调用fit_transform方法输入数据并转换（注意返回格式）

```python
from sklearn.feature_extraction import DictVectorizer

def dict_demo():
    """
    对字典类型的数据进行特征抽取
    :return: None
    """
    data = [{'city': '北京','temperature':100}, {'city': '上海','temperature':60}, {'city': '深圳','temperature':30}]
    # 1、实例化一个转换器类
    transfer = DictVectorizer(sparse=False)
    # 2、调用fit_transform
    data = transfer.fit_transform(data)
    print("返回的结果:\n", data)
    # 打印特征名字
    print("特征名字：\n", transfer.get_feature_names())

    return None
```

注意观察没有加上sparse=False参数的结果

```python
返回的结果:
   (0, 1)    1.0
  (0, 3)    100.0
  (1, 0)    1.0
  (1, 3)    60.0
  (2, 2)    1.0
  (2, 3)    30.0
特征名字：
 ['city=上海', 'city=北京', 'city=深圳', 'temperature']
```

这个结果并不是我们想要看到的，所以加上参数，得到想要的结果：

```python
返回的结果:
 [[   0.    1.    0.  100.]
 [   1.    0.    0.   60.]
 [   0.    0.    1.   30.]]
特征名字：
 ['city=上海', 'city=北京', 'city=深圳', 'temperature']
```

之前在学习pandas中的离散化的时候，也实现了类似的效果。

我们把这个处理数据的技巧叫做”one-hot“编码：

![onehot](https://i0.hdslb.com/bfs/album/876a0e5301b5c232c5dcf40a86b848e972301cb8.png)

转化为：

![onehot1](https://i0.hdslb.com/bfs/album/2c826dbb384f7832acd6520ba049fa3b08988d88.png)

3 总结

**对于特征当中存在类别信息的我们都会做one-hot编码处理**











2.3.3 文本特征提取

**作用：对文本数据进行特征值化**

- **sklearn.feature_extraction.text.CountVectorizer(stop_words=[])**
  - 返回词频矩阵

- CountVectorizer.fit_transform(X) X:文本或者包含文本字符串的可迭代对象 返回值：返回sparse矩阵
- CountVectorizer.inverse_transform(X) X:array数组或者sparse矩阵 返回值:转换之前数据格
- CountVectorizer.get_feature_names() 返回值:单词列表

- **sklearn.feature_extraction.text.TfidfVectorizer**

1 应用

我们对以下数据进行特征提取

```python
["life is short,i like python",
"life is too long,i dislike python"]
```

![countvec结果](https://i0.hdslb.com/bfs/album/4e7ff94dd1f7d2ad60302933ea1ec51c84bc3f36.png)

2 流程分析

- 实例化类CountVectorizer
- 调用fit_transform方法输入数据并转换 （注意返回格式，利用toarray()进行sparse矩阵转换array数组）

```python
from sklearn.feature_extraction.text import CountVectorizer

def text_count_demo():
    """
    对文本进行特征抽取，countvetorizer
    :return: None
    """
    data = ["life is short,i like like python", "life is too long,i dislike python"]
    # 1、实例化一个转换器类
    # transfer = CountVectorizer(sparse=False)
    transfer = CountVectorizer()
    # 2、调用fit_transform
    data = transfer.fit_transform(data)
    print("文本特征抽取的结果：\n", data.toarray())
    print("返回特征名字：\n", transfer.get_feature_names())

    return None
```

返回结果：

```python
文本特征抽取的结果：
 [[0 1 1 2 0 1 1 0]
 [1 1 1 0 1 1 0 1]]
返回特征名字：
 ['dislike', 'is', 'life', 'like', 'long', 'python', 'short', 'too']
```

问题:如果我们将数据替换成中文？

```python
"人生苦短，我喜欢Python" "生活太长久，我不喜欢Python"
```

那么最终得到的结果是

![不支持单个中文字](https://i0.hdslb.com/bfs/album/1ce168c7500ab677194d559315e09084796f645c.png)

为什么会得到这样的结果呢，**仔细分析之后会发现英文默认是以空格分开的。其实就达到了一个分词的效果**，所以我们要对中文进行分词处理

3 jieba分词处理

- jieba.cut()
  - 返回词语组成的生成器

需要安装下jieba库

```python
pip3 install jieba
```

4 案例分析

对以下三句话进行特征值化

```python
今天很残酷，明天更残酷，后天很美好，
但绝对大部分是死在明天晚上，所以每个人不要放弃今天。

我们看到的从很远星系来的光是在几百万年之前发出的，
这样当我们看到宇宙时，我们是在看它的过去。

如果只用一种方式了解某样事物，你就不会真正了解它。
了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。
```

- 分析
  - 准备句子，利用jieba.cut进行分词
  - 实例化CountVectorizer
  - 将分词结果变成字符串当作fit_transform的输入值

![三段中文结果](https://i0.hdslb.com/bfs/album/f1b4641a05d33528e4c646026eb3c3d1a8a5915b.png)

```python
from sklearn.feature_extraction.text import CountVectorizer
import jieba

def cut_word(text):
    """
    对中文进行分词
    "我爱北京天安门"————>"我 爱 北京 天安门"
    :param text:
    :return: text
    """
    # 用结巴对中文字符串进行分词
    text = " ".join(list(jieba.cut(text)))

    return text

def text_chinese_count_demo2():
    """
    对中文进行特征抽取
    :return: None
    """
    data = ["一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。",
            "我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。",
            "如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。"]
    # 将原始数据转换成分好词的形式
    text_list = []
    for sent in data:
        text_list.append(cut_word(sent))
    print(text_list)

    # 1、实例化一个转换器类
    # transfer = CountVectorizer(sparse=False)
    transfer = CountVectorizer()
    # 2、调用fit_transform
    data = transfer.fit_transform(text_list)
    print("文本特征抽取的结果：\n", data.toarray())
    print("返回特征名字：\n", transfer.get_feature_names())

    return None
```

返回结果：

```python
Building prefix dict from the default dictionary ...
Dumping model to file cache /var/folders/mz/tzf2l3sx4rgg6qpglfb035_r0000gn/T/jieba.cache
Loading model cost 1.032 seconds.
['一种 还是 一种 今天 很 残酷 ， 明天 更 残酷 ， 后天 很 美好 ， 但 绝对 大部分 是 死 在 明天 晚上 ， 所以 每个 人 不要 放弃 今天 。', '我们 看到 的 从 很 远 星系 来 的 光是在 几百万年 之前 发出 的 ， 这样 当 我们 看到 宇宙 时 ， 我们 是 在 看 它 的 过去 。', '如果 只用 一种 方式 了解 某样 事物 ， 你 就 不会 真正 了解 它 。 了解 事物 真正 含义 的 秘密 取决于 如何 将 其 与 我们 所 了解 的 事物 相 联系 。']
Prefix dict has been built succesfully.
文本特征抽取的结果：
 [[2 0 1 0 0 0 2 0 0 0 0 0 1 0 1 0 0 0 0 1 1 0 2 0 1 0 2 1 0 0 0 1 1 0 0 1 0]
 [0 0 0 1 0 0 0 1 1 1 0 0 0 0 0 0 0 1 3 0 0 0 0 1 0 0 0 0 2 0 0 0 0 0 1 0 1]
 [1 1 0 0 4 3 0 0 0 0 1 1 0 1 0 1 1 0 1 0 0 1 0 0 0 1 0 0 0 2 1 0 0 1 0 0 0]]
返回特征名字：
 ['一种', '不会', '不要', '之前', '了解', '事物', '今天', '光是在', '几百万年', '发出', '取决于', '只用', '后天', '含义', '大部分', '如何', '如果', '宇宙', '我们', '所以', '放弃', '方式', '明天', '星系', '晚上', '某样', '残酷', '每个', '看到', '真正', '秘密', '绝对', '美好', '联系', '过去', '还是', '这样']
```

**但如果把这样的词语特征用于分类，会出现什么问题？**

请看问题：

![词语占比](https://i0.hdslb.com/bfs/album/b17a6c45ce7b45f33baac7b88b754b8ea91da94e.png)

**该如何处理某个词或短语在多篇文章中出现的次数高这种情况**

5 Tf-idf文本特征提取

- TF-IDF的主要思想是：如果**某个词或短语在一篇文章中出现的概率高，并且在其他文章中很少出现**，则认为此词或者短语具有很好的类别区分能力，适合用来分类。
- **TF-IDF作用：用以评估一字词对于一个文件集或一个语料库中的其中一份文件的重要程度。**

5.1 公式

- 词频（term frequency，tf）指的是某一个给定的词语在该文件中出现的频率
- 逆向文档频率（inverse document frequency，idf）是一个词语普遍重要性的度量。某一特定词语的idf，可以**由总文件数目除以包含该词语之文件的数目，再将得到的商取以10为底的对数得到**

![tfidf公式](https://i0.hdslb.com/bfs/album/2801531c492ed03719c4edf2f2e6cf002f1dc687.png)

最终得出结果可以理解为重要程度。

```
注：假如一篇文件的总词语数是100个，而词语"非常"出现了5次，那么"非常"一词在该文件中的词频就是5/100=0.05。而计算文件频率（IDF）的方法是以文件集的文件总数，除以出现"非常"一词的文件数。所以，如果"非常"一词在1,000份文件出现过，而文件总数是10,000,000份的话，其逆向文件频率就是lg（10,000,000 / 1,0000）=3。最后"非常"对于这篇文档的tf-idf的分数为0.05 * 3=0.15
```

5.2 案例

```python
from sklearn.feature_extraction.text import TfidfVectorizer
import jieba

def cut_word(text):
    """
    对中文进行分词
    "我爱北京天安门"————>"我 爱 北京 天安门"
    :param text:
    :return: text
    """
    # 用结巴对中文字符串进行分词
    text = " ".join(list(jieba.cut(text)))

    return text

def text_chinese_tfidf_demo():
    """
    对中文进行特征抽取
    :return: None
    """
    data = ["一种还是一种今天很残酷，明天更残酷，后天很美好，但绝对大部分是死在明天晚上，所以每个人不要放弃今天。",
            "我们看到的从很远星系来的光是在几百万年之前发出的，这样当我们看到宇宙时，我们是在看它的过去。",
            "如果只用一种方式了解某样事物，你就不会真正了解它。了解事物真正含义的秘密取决于如何将其与我们所了解的事物相联系。"]
    # 将原始数据转换成分好词的形式
    text_list = []
    for sent in data:
        text_list.append(cut_word(sent))
    print(text_list)

    # 1、实例化一个转换器类
    # transfer = CountVectorizer(sparse=False)
    transfer = TfidfVectorizer(stop_words=['一种', '不会', '不要'])
    # 2、调用fit_transform
    data = transfer.fit_transform(text_list)
    print("文本特征抽取的结果：\n", data.toarray())
    print("返回特征名字：\n", transfer.get_feature_names())

    return None
```

返回结果：

```python
Building prefix dict from the default dictionary ...
Loading model from cache /var/folders/mz/tzf2l3sx4rgg6qpglfb035_r0000gn/T/jieba.cache
Loading model cost 0.856 seconds.
Prefix dict has been built succesfully.
['一种 还是 一种 今天 很 残酷 ， 明天 更 残酷 ， 后天 很 美好 ， 但 绝对 大部分 是 死 在 明天 晚上 ， 所以 每个 人 不要 放弃 今天 。', '我们 看到 的 从 很 远 星系 来 的 光是在 几百万年 之前 发出 的 ， 这样 当 我们 看到 宇宙 时 ， 我们 是 在 看 它 的 过去 。', '如果 只用 一种 方式 了解 某样 事物 ， 你 就 不会 真正 了解 它 。 了解 事物 真正 含义 的 秘密 取决于 如何 将 其 与 我们 所 了解 的 事物 相 联系 。']
文本特征抽取的结果：
 [[ 0.          0.          0.          0.43643578  0.          0.          0.
   0.          0.          0.21821789  0.          0.21821789  0.          0.
   0.          0.          0.21821789  0.21821789  0.          0.43643578
   0.          0.21821789  0.          0.43643578  0.21821789  0.          0.
   0.          0.21821789  0.21821789  0.          0.          0.21821789
   0.        ]
 [ 0.2410822   0.          0.          0.          0.2410822   0.2410822
   0.2410822   0.          0.          0.          0.          0.          0.
   0.          0.2410822   0.55004769  0.          0.          0.          0.
   0.2410822   0.          0.          0.          0.          0.48216441
   0.          0.          0.          0.          0.          0.2410822
   0.          0.2410822 ]
 [ 0.          0.644003    0.48300225  0.          0.          0.          0.
   0.16100075  0.16100075  0.          0.16100075  0.          0.16100075
   0.16100075  0.          0.12244522  0.          0.          0.16100075
   0.          0.          0.          0.16100075  0.          0.          0.
   0.3220015   0.16100075  0.          0.          0.16100075  0.          0.
   0.        ]]
返回特征名字：
 ['之前', '了解', '事物', '今天', '光是在', '几百万年', '发出', '取决于', '只用', '后天', '含义', '大部分', '如何', '如果', '宇宙', '我们', '所以', '放弃', '方式', '明天', '星系', '晚上', '某样', '残酷', '每个', '看到', '真正', '秘密', '绝对', '美好', '联系', '过去', '还是', '这样']
```

6 Tf-idf的重要性

**分类机器学习算法进行文章分类中前期数据处理方式**





## 2.4 特征预处理

学习目标

- 目标
  - 了解数值型数据、类别型数据特点
  - 应用MinMaxScaler实现对特征数据进行归一化
  - 应用StandardScaler实现对特征数据进行标准化
- 应用
  - 无

什么是特征预处理？

![特征预处理图](https://i0.hdslb.com/bfs/album/91bd27682bc8b6a67314d09ddf8a83a78443a3c8.png)

2.4.1 什么是特征预处理

```python
# scikit-learn的解释
provides several common utility functions and transformer classes to change raw feature vectors into a representation that is more suitable for the downstream estimators.
```

翻译过来：通过**一些转换函数**将特征数据**转换成更加适合算法模型**的特征数据过程

可以通过上面那张图来理解

1 包含内容

- 数值型数据的无量纲化：
  - 归一化
  - 标准化

2 特征预处理API

```python
sklearn.preprocessing
```

为什么我们要进行归一化/标准化？

- 特征的**单位或者大小相差较大，或者某特征的方差相比其他的特征要大出几个数量级**，**容易影响（支配）目标结果**，使得一些算法无法学习到其它的特征

约会对象数据

![约会对象数据](https://i0.hdslb.com/bfs/album/3d84eff80a009db193256d340ec51a5c7eefe0c4.png)

我们需要用到一些方法进行**无量纲化**，**使不同规格的数据转换到同一规格**

2.4.2 归一化

1 定义

通过对原始数据进行变换把数据映射到(默认为[0,1])之间

2 公式

![归一化公式](https://i0.hdslb.com/bfs/album/1dab5dc6a993c403cbf5b287b6e5e3339986a194.png)

> 作用于每一列，max为一列的最大值，min为一列的最小值,那么X’’为最终结果，mx，mi分别为指定区间值默认mx为1,mi为0

那么怎么理解这个过程呢？我们通过一个例子

![归一化计算过程](https://i0.hdslb.com/bfs/album/371fedbe7b8dbd4b26fb2d4573b9fb005248f67e.png)

3 API

- sklearn.preprocessing.MinMaxScaler (feature_range=(0,1)… )
  - MinMaxScalar.fit_transform(X)
    - X:numpy array格式的数据[n_samples,n_features]
  - 返回值：转换后的形状相同的array

4 数据计算

我们对以下数据进行运算，在dating.txt中。保存的就是之前的约会对象数据

```python
milage,Liters,Consumtime,target
40920,8.326976,0.953952,3
14488,7.153469,1.673904,2
26052,1.441871,0.805124,1
75136,13.147394,0.428964,1
38344,1.669788,0.134296,1
```

- 分析

1、实例化MinMaxScalar

2、通过fit_transform转换

```python
import pandas as pd
from sklearn.preprocessing import MinMaxScaler

def minmax_demo():
    """
    归一化演示
    :return: None
    """
    data = pd.read_csv("dating.txt")
    print(data)
    # 1、实例化一个转换器类
    transfer = MinMaxScaler(feature_range=(2, 3))
    # 2、调用fit_transform
    data = transfer.fit_transform(data[['milage','Liters','Consumtime']])
    print("最小值最大值归一化处理的结果：\n", data)

    return None
```

返回结果：

```python
     milage     Liters  Consumtime  target
0     40920   8.326976    0.953952       3
1     14488   7.153469    1.673904       2
2     26052   1.441871    0.805124       1
3     75136  13.147394    0.428964       1
..      ...        ...         ...     ...
998   48111   9.134528    0.728045       3
999   43757   7.882601    1.332446       3

[1000 rows x 4 columns]
最小值最大值归一化处理的结果：
 [[ 2.44832535  2.39805139  2.56233353]
 [ 2.15873259  2.34195467  2.98724416]
 [ 2.28542943  2.06892523  2.47449629]
 ..., 
 [ 2.29115949  2.50910294  2.51079493]
 [ 2.52711097  2.43665451  2.4290048 ]
 [ 2.47940793  2.3768091   2.78571804]]
```

问题：如果数据中异常点较多，会有什么影响？

![异常点对归一化影响](https://i0.hdslb.com/bfs/album/6c17191641d020f9b955acb30e916be7af9e3cee.png)

5 归一化总结

注意最大值最小值是变化的，另外，最大值与最小值非常容易受异常点影响，**所以这种方法鲁棒性较差，只适合传统精确小数据场景。**

怎么办？

2.4.3 标准化

1 定义

通过对原始数据进行变换把数据变换到均值为0,标准差为1范围内

2 公式

![标准化公式](https://i0.hdslb.com/bfs/album/73de5e62cdcb788ec4886c0b15bfc26f628ac4e5.png)

> 作用于每一列，mean为平均值，σ为标准差

所以回到刚才异常点的地方，我们再来看看标准化

![标准化异常点影响](https://i0.hdslb.com/bfs/album/5ac8045a3d50b9ee475a7db8885e3040cd4b05d9.png)

- 对于归一化来说：如果出现异常点，影响了最大值和最小值，那么结果显然会发生改变
- 对于标准化来说：如果出现异常点，由于具有一定数据量，少量的异常点对于平均值的影响并不大，从而方差改变较小。

3 API

- sklearn.preprocessing.StandardScaler( )
  - 处理之后每列来说所有数据都聚集在均值0附近标准差差为1
  - StandardScaler.fit_transform(X)
    - X:numpy array格式的数据[n_samples,n_features]
  - 返回值：转换后的形状相同的array

4 数据计算

同样对上面的数据进行处理

- 分析

1、实例化StandardScaler

2、通过fit_transform转换

```python
import pandas as pd
from sklearn.preprocessing import StandardScaler

def stand_demo():
    """
    标准化演示
    :return: None
    """
    data = pd.read_csv("dating.txt")
    print(data)
    # 1、实例化一个转换器类
    transfer = StandardScaler()
    # 2、调用fit_transform
    data = transfer.fit_transform(data[['milage','Liters','Consumtime']])
    print("标准化的结果:\n", data)
    print("每一列特征的平均值：\n", transfer.mean_)
    print("每一列特征的方差：\n", transfer.var_)

    return None
```

返回结果：

```python
     milage     Liters  Consumtime  target
0     40920   8.326976    0.953952       3
1     14488   7.153469    1.673904       2
2     26052   1.441871    0.805124       1
..      ...        ...         ...     ...
997   26575  10.650102    0.866627       3
998   48111   9.134528    0.728045       3
999   43757   7.882601    1.332446       3

[1000 rows x 4 columns]
标准化的结果:
 [[ 0.33193158  0.41660188  0.24523407]
 [-0.87247784  0.13992897  1.69385734]
 [-0.34554872 -1.20667094 -0.05422437]
 ..., 
 [-0.32171752  0.96431572  0.06952649]
 [ 0.65959911  0.60699509 -0.20931587]
 [ 0.46120328  0.31183342  1.00680598]]
每一列特征的平均值：
 [  3.36354210e+04   6.55996083e+00   8.32072997e-01]
每一列特征的方差：
 [  4.81628039e+08   1.79902874e+01   2.46999554e-01]
```

5 标准化总结

在已有样本足够多的情况下比较稳定，适合现代嘈杂大数据场景。





## 2.5 特征降维

学习目标

- 目标
  - 知道特征选择的嵌入式、过滤式以及包裹氏三种方式
  - 应用VarianceThreshold实现删除低方差特征
  - 了解相关系数的特点和计算
  - 应用相关性系数实现特征选择
- 应用
  - 无

2.5.1 降维

**降维**是指在某些限定条件下，**降低随机变量(特征)个数**，得到**一组“不相关”主变量**的过程

- 降低随机变量的个数

![降维](https://i0.hdslb.com/bfs/album/81ceba877f1d0f82745bc17109aca61b7a36c8c2.png)

- 相关特征(correlated feature)
  - 相对湿度与降雨量之间的相关
  - 等等

> 正是因为在进行训练的时候，我们都是使用特征进行学习。如果特征本身存在问题或者特征之间相关性较强，对于算法学习预测会影响较大

2.5.2 降维的两种方式

- **特征选择**
- **主成分分析（可以理解一种特征提取的方式）**

2.5.3 什么是特征选择

1 定义

数据中包含**冗余或无关变量（或称特征、属性、指标等）**，旨在从**原有特征中找出主要特征**。

![鸟类特征选择](https://i0.hdslb.com/bfs/album/e51cb7f44cfdc84666ca8a06baaf57d2d4f66fa2.png)

2 方法

- Filter(过滤式)：主要探究特征本身特点、特征与特征和目标值之间关联
  - **方差选择法：低方差特征过滤**
  - **相关系数**
- Embedded (嵌入式)：算法自动选择特征（特征与目标值之间的关联）
  - **决策树:信息熵、信息增益**
  - **正则化：L1、L2**
  - **深度学习：卷积等**

> 对于Embedded方式，只能在讲解算法的时候在进行介绍，更好的去理解

3 模块

```python
sklearn.feature_selection
```

4 过滤式

4.1 低方差特征过滤

删除低方差的一些特征，前面讲过方差的意义。再结合方差的大小来考虑这个方式的角度。

- 特征方差小：某个特征大多样本的值比较相近
- 特征方差大：某个特征很多样本的值都有差别

4.1.1 API

- sklearn.feature_selection.VarianceThreshold(threshold = 0.0)
  - 删除所有低方差特征
  - Variance.fit_transform(X)
    - X:numpy array格式的数据[n_samples,n_features]
    - 返回值：训练集差异低于threshold的特征将被删除。默认值是保留所有非零方差特征，即删除所有样本中具有相同值的特征。

4.1.2 数据计算

我们对**某些股票的指标特征之间进行一个筛选**，数据在"factor_regression_data/factor_returns.csv"文件当中,除去'index,'date','return'列不考虑**（这些类型不匹配，也不是所需要指标）**

一共这些特征

```
pe_ratio,pb_ratio,market_cap,return_on_asset_net_profit,du_return_on_equity,ev,earnings_per_share,revenue,total_expense
index,pe_ratio,pb_ratio,market_cap,return_on_asset_net_profit,du_return_on_equity,ev,earnings_per_share,revenue,total_expense,date,return
0,000001.XSHE,5.9572,1.1818,85252550922.0,0.8008,14.9403,1211444855670.0,2.01,20701401000.0,10882540000.0,2012-01-31,0.027657228229937388
1,000002.XSHE,7.0289,1.588,84113358168.0,1.6463,7.8656,300252061695.0,0.326,29308369223.2,23783476901.2,2012-01-31,0.08235182370820669
2,000008.XSHE,-262.7461,7.0003,517045520.0,-0.5678,-0.5943,770517752.56,-0.006,11679829.03,12030080.04,2012-01-31,0.09978900335112327
3,000060.XSHE,16.476,3.7146,19680455995.0,5.6036,14.617,28009159184.6,0.35,9189386877.65,7935542726.05,2012-01-31,0.12159482758620697
4,000069.XSHE,12.5878,2.5616,41727214853.0,2.8729,10.9097,81247380359.0,0.271,8951453490.28,7091397989.13,2012-01-31,-0.0026808154146886697
```

- 分析

1、初始化VarianceThreshold,指定阀值方差

2、调用fit_transform

```python
def variance_demo():
    """
    删除低方差特征——特征选择
    :return: None
    """
    data = pd.read_csv("factor_returns.csv")
    print(data)
    # 1、实例化一个转换器类
    transfer = VarianceThreshold(threshold=1)
    # 2、调用fit_transform
    data = transfer.fit_transform(data.iloc[:, 1:10])
    print("删除低方差特征的结果：\n", data)
    print("形状：\n", data.shape)

    return None
```

返回结果：

```python
            index  pe_ratio  pb_ratio    market_cap  \
0     000001.XSHE    5.9572    1.1818  8.525255e+10   
1     000002.XSHE    7.0289    1.5880  8.411336e+10    
...           ...       ...       ...           ...   
2316  601958.XSHG   52.5408    2.4646  3.287910e+10   
2317  601989.XSHG   14.2203    1.4103  5.911086e+10   

      return_on_asset_net_profit  du_return_on_equity            ev  \
0                         0.8008              14.9403  1.211445e+12   
1                         1.6463               7.8656  3.002521e+11    
...                          ...                  ...           ...   
2316                      2.7444               2.9202  3.883803e+10   
2317                      2.0383               8.6179  2.020661e+11   

      earnings_per_share       revenue  total_expense        date    return  
0                 2.0100  2.070140e+10   1.088254e+10  2012-01-31  0.027657  
1                 0.3260  2.930837e+10   2.378348e+10  2012-01-31  0.082352  
2                -0.0060  1.167983e+07   1.203008e+07  2012-01-31  0.099789   
...                  ...           ...            ...         ...       ...  
2315              0.2200  1.789082e+10   1.749295e+10  2012-11-30  0.137134  
2316              0.1210  6.465392e+09   6.009007e+09  2012-11-30  0.149167  
2317              0.2470  4.509872e+10   4.132842e+10  2012-11-30  0.183629  

[2318 rows x 12 columns]
删除低方差特征的结果：
 [[  5.95720000e+00   1.18180000e+00   8.52525509e+10 ...,   1.21144486e+12
    2.07014010e+10   1.08825400e+10]
 [  7.02890000e+00   1.58800000e+00   8.41133582e+10 ...,   3.00252062e+11
    2.93083692e+10   2.37834769e+10]
 [ -2.62746100e+02   7.00030000e+00   5.17045520e+08 ...,   7.70517753e+08
    1.16798290e+07   1.20300800e+07]
 ..., 
 [  3.95523000e+01   4.00520000e+00   1.70243430e+10 ...,   2.42081699e+10
    1.78908166e+10   1.74929478e+10]
 [  5.25408000e+01   2.46460000e+00   3.28790988e+10 ...,   3.88380258e+10
    6.46539204e+09   6.00900728e+09]
 [  1.42203000e+01   1.41030000e+00   5.91108572e+10 ...,   2.02066110e+11
    4.50987171e+10   4.13284212e+10]]
形状：
 (2318, 8)
```

4.2 相关系数

- 皮尔逊相关系数(Pearson Correlation Coefficient)	还有：斯皮尔曼相关系数
  - 反映变量之间相关关系密切程度的统计指标

4.2.2 公式计算案例(了解，不用记忆)

- 公式

![相关系数公式](https://i0.hdslb.com/bfs/album/84b6a3fa311c108e9a16500e1141559c8ceb5867.png)

- 比如说我们计算年广告费投入与月均销售额

![广告费表](https://i0.hdslb.com/bfs/album/ee07f5f7bc3ebb966393cac7c81e4f3c2f8e05a3.png)

那么之间的相关系数怎么计算

![广告费统计系数结果](https://i0.hdslb.com/bfs/album/c7bff39fdf4ea75a53a68c09a19cca789c447c39.png)

最终计算：

![相关系数计算数字结果](https://i0.hdslb.com/bfs/album/7cac1a32a51fb1ab8faba74ca4613aa5766ff206.png)

= 0.9942

**所以我们最终得出结论是广告投入费与月平均销售额之间有高度的正相关关系。** 　

4.2.3 特点

**相关系数的值介于–1与+1之间，即–1≤ r ≤+1**。其性质如下：

- **当r>0时，表示两变量正相关，r<0时，两变量为负相关**
- 当|r|=1时，表示两变量为完全相关，当r=0时，表示两变量间无相关关系
- **当0<|r|<1时，表示两变量存在一定程度的相关。且|r|越接近1，两变量间线性关系越密切；|r|越接近于0，表示两变量的线性相关越弱**
- **一般可按三级划分：|r|<0.4为低度相关；0.4≤|r|<0.7为显著性相关；0.7≤|r|<1为高度线性相关**

> 这个符号：|r|为r的绝对值， |-5| = 5

4.2.4 API

- from scipy.stats import pearsonr
  - x : (N,) array_like
  - y : (N,) array_like Returns: (Pearson’s correlation coefficient, p-value)

4.2.5 案例：股票的财务指标相关性计算

我们刚才的股票的这些指标进行相关性计算， 假设我们以

```python
factor = ['pe_ratio','pb_ratio','market_cap','return_on_asset_net_profit','du_return_on_equity','ev','earnings_per_share','revenue','total_expense']
```

这些特征当中的两两进行计算，得出相关性高的一些特征

![指标相关性结果](https://i0.hdslb.com/bfs/album/d109a300889ba36b207a6560ffb873428097c99d.png)

- 分析
  - 两两特征之间进行相关性计算

```python
import pandas as pd
from scipy.stats import pearsonr

def pearsonr_demo():
    """
    相关系数计算
    :return: None
    """
    data = pd.read_csv("factor_returns.csv")

    factor = ['pe_ratio', 'pb_ratio', 'market_cap', 'return_on_asset_net_profit', 'du_return_on_equity', 'ev',
              'earnings_per_share', 'revenue', 'total_expense']

    for i in range(len(factor)):
        for j in range(i, len(factor) - 1):
            print(
                "指标%s与指标%s之间的相关性大小为%f" % (factor[i], factor[j + 1], pearsonr(data[factor[i]], data[factor[j + 1]])[0]))

    return None
```

返回结果：

```python
指标pe_ratio与指标pb_ratio之间的相关性大小为-0.004389
指标pe_ratio与指标market_cap之间的相关性大小为-0.068861
指标pe_ratio与指标return_on_asset_net_profit之间的相关性大小为-0.066009
指标pe_ratio与指标du_return_on_equity之间的相关性大小为-0.082364
指标pe_ratio与指标ev之间的相关性大小为-0.046159
指标pe_ratio与指标earnings_per_share之间的相关性大小为-0.072082
指标pe_ratio与指标revenue之间的相关性大小为-0.058693
指标pe_ratio与指标total_expense之间的相关性大小为-0.055551
指标pb_ratio与指标market_cap之间的相关性大小为0.009336
指标pb_ratio与指标return_on_asset_net_profit之间的相关性大小为0.445381
指标pb_ratio与指标du_return_on_equity之间的相关性大小为0.291367
指标pb_ratio与指标ev之间的相关性大小为-0.183232
指标pb_ratio与指标earnings_per_share之间的相关性大小为0.198708
指标pb_ratio与指标revenue之间的相关性大小为-0.177671
指标pb_ratio与指标total_expense之间的相关性大小为-0.173339
指标market_cap与指标return_on_asset_net_profit之间的相关性大小为0.214774
指标market_cap与指标du_return_on_equity之间的相关性大小为0.316288
指标market_cap与指标ev之间的相关性大小为0.565533
指标market_cap与指标earnings_per_share之间的相关性大小为0.524179
指标market_cap与指标revenue之间的相关性大小为0.440653
指标market_cap与指标total_expense之间的相关性大小为0.386550
指标return_on_asset_net_profit与指标du_return_on_equity之间的相关性大小为0.818697
指标return_on_asset_net_profit与指标ev之间的相关性大小为-0.101225
指标return_on_asset_net_profit与指标earnings_per_share之间的相关性大小为0.635933
指标return_on_asset_net_profit与指标revenue之间的相关性大小为0.038582
指标return_on_asset_net_profit与指标total_expense之间的相关性大小为0.027014
指标du_return_on_equity与指标ev之间的相关性大小为0.118807
指标du_return_on_equity与指标earnings_per_share之间的相关性大小为0.651996
指标du_return_on_equity与指标revenue之间的相关性大小为0.163214
指标du_return_on_equity与指标total_expense之间的相关性大小为0.135412
指标ev与指标earnings_per_share之间的相关性大小为0.196033
指标ev与指标revenue之间的相关性大小为0.224363
指标ev与指标total_expense之间的相关性大小为0.149857
指标earnings_per_share与指标revenue之间的相关性大小为0.141473
指标earnings_per_share与指标total_expense之间的相关性大小为0.105022
指标revenue与指标total_expense之间的相关性大小为0.995845
```

从中我们得出

- 指标revenue与指标total_expense之间的相关性大小为0.995845
- 指标return_on_asset_net_profit与指标du_return_on_equity之间的相关性大小为0.818697

我们也可以通过画图来观察结果

```python
import matplotlib.pyplot as plt
plt.figure(figsize=(20, 8), dpi=100)
plt.scatter(data['revenue'], data['total_expense'])
plt.show()
```

![img](https://i0.hdslb.com/bfs/album/57dfa396e0b0183d046952b5cacbefae29c40f4e.png)

**这两对指标之间的相关性较大，可以做之后的处理，比如合成这两个指标。**







## 2.6 主成分分析

学习目标

- 目标
  - 应用PCA实现特征的降维
- 应用
  - 用户与物品类别之间主成分分析

2.6.1 什么是主成分分析(PCA:Principal Component Analysis)

- 定义：**高维数据转化为低维数据的过程**，在此过程中**可能会舍弃原有数据、创造新的变量**
- 作用：**是数据维数压缩，尽可能降低原数据的维数（复杂度），损失少量信息。**
- 应用：回归分析或者聚类分析当中

> 对于信息一词，在决策树中会进行介绍

那么更好的理解这个过程呢？我们来看一张图

![PCA解释图](https://i0.hdslb.com/bfs/album/d9be89a4e8096dca4983f46cacce56c359f21279.png)

1 计算案例理解(了解，无需记忆)

假设对于给定5个点，数据如下

```
(-1,-2)
(-1, 0)
( 0, 0)
( 2, 1)
( 0, 1)
```

![PCA计算图](https://i0.hdslb.com/bfs/album/19af0de353d91a2c5fd7363e47dc497923f6e0f1.png)

要求：将这个二维的数据简化成一维？ 并且损失少量的信息

![PCA坐标轴结果](https://i0.hdslb.com/bfs/album/548ff56286f53052f98a2e19a84795c0ce5cea00.png)

这个过程如何计算的呢？**找到一个合适的直线，通过一个矩阵运算得出主成分分析的结果（不需要理解）**

![PCA运算过程](https://i0.hdslb.com/bfs/album/d25efd353d8944d17446e6bf2d5dab46948cf50a.png)

2 API

- sklearn.decomposition.PCA(n_components=None)
  - 将数据分解为较低维数空间
  - n_components:
    - **小数：表示保留百分之多少的信息**
    - **整数：减少到多少特征**
  - PCA.fit_transform(X) X:numpy array格式的数据[n_samples,n_features]
  - 返回值：转换后指定维度的array

3 数据计算

先拿个简单的数据计算一下

```python
[[2,8,4,5],
[6,3,0,8],
[5,4,9,1]]
from sklearn.decomposition import PCA

def pca_demo():
    """
    对数据进行PCA降维
    :return: None
    """
    data = [[2,8,4,5], [6,3,0,8], [5,4,9,1]]

    # 1、实例化PCA, 小数——保留多少信息
    transfer = PCA(n_components=0.9)
    # 2、调用fit_transform
    data1 = transfer.fit_transform(data)

    print("保留90%的信息，降维结果为：\n", data1)

    # 1、实例化PCA, 整数——指定降维到的维数
    transfer2 = PCA(n_components=3)
    # 2、调用fit_transform
    data2 = transfer2.fit_transform(data)
    print("降维到3维的结果：\n", data2)

    return None
```

返回结果：

```python
保留90%的信息，降维结果为：
 [[ -3.13587302e-16   3.82970843e+00]
 [ -5.74456265e+00  -1.91485422e+00]
 [  5.74456265e+00  -1.91485422e+00]]
降维到3维的结果：
 [[ -3.13587302e-16   3.82970843e+00   4.59544715e-16]
 [ -5.74456265e+00  -1.91485422e+00   4.59544715e-16]
 [  5.74456265e+00  -1.91485422e+00   4.59544715e-16]]
```

2.6.2 案例：探究用户对物品类别的喜好细分降维

![instacart](https://i0.hdslb.com/bfs/album/01c73d8732c594ebfa0c7a9daa978e3508ceac98.png)

数据如下：

- order_products__prior.csv：订单与商品信息
  - 字段：**order_id**, **product_id**, add_to_cart_order, reordered
- products.csv：商品信息
  - 字段：**product_id**, product_name, **aisle_id**, department_id
- orders.csv：用户的订单信息
  - 字段：**order_id**,**user_id**,eval_set,order_number,….
- aisles.csv：商品所属具体物品类别
  - 字段： **aisle_id**, **aisle**

1 需求

![instacart效果](https://i0.hdslb.com/bfs/album/664e74f8369d219013d1bc6db70143b8f268764b.png)

!![instacartPCA结果](https://i0.hdslb.com/bfs/album/7ae34f2016e5489711e42e344f2c0924d32b6f76.png)

2 分析

- 合并表，使得**user_id**与**aisle**在一张表当中
- 进行交叉表变换
- 进行降维

3 完整代码

```python
import pandas as pd
from sklearn.decomposition import PCA

# 1、获取数据集
# ·商品信息- products.csv：
# Fields：product_id, product_name, aisle_id, department_id
# ·订单与商品信息- order_products__prior.csv：
# Fields：order_id, product_id, add_to_cart_order, reordered 
# ·用户的订单信息- orders.csv：
# Fields：order_id, user_id,eval_set, order_number,order_dow, order_hour_of_day, days_since_prior_order 
# ·商品所属具体物品类别- aisles.csv：
# Fields：aisle_id, aisle     
products = pd.read_csv("./instacart/products.csv")
order_products = pd.read_csv("./instacart/order_products__prior.csv")
orders = pd.read_csv("./instacart/orders.csv")
aisles = pd.read_csv("./instacart/aisles.csv")

# 2、合并表，将user_id和aisle放在一张表上
# 1）合并orders和order_products on=order_id tab1:order_id, product_id, user_id
tab1 = pd.merge(orders, order_products, on=["order_id", "order_id"])
# 2）合并tab1和products on=product_id tab2:aisle_id
tab2 = pd.merge(tab1, products, on=["product_id", "product_id"])
# 3）合并tab2和aisles on=aisle_id tab3:user_id, aisle
tab3 = pd.merge(tab2, aisles, on=["aisle_id", "aisle_id"])

# 3、交叉表处理，把user_id和aisle进行分组
table = pd.crosstab(tab3["user_id"], tab3["aisle"])

# 4、主成分分析的方法进行降维
# 1）实例化一个转换器类PCA
transfer = PCA(n_components=0.95)
# 2）fit_transform
data = transfer.fit_transform(table)

data.shape
```

返回结果：

```python
(206209, 44)
```





## 2.7 总结

![img](https://i0.hdslb.com/bfs/album/37ec2023174c1ab7d3ef4db5113ed8f64a114b00.png)



![day1](https://i0.hdslb.com/bfs/album/6f5ab3feaf373d7697f992f469d02ffe5526a88c.png)

![code](https://i0.hdslb.com/bfs/album/d0136f1e439b59496c8656f2760f736982211909.png)



1、数据集的结构是什么?

答案: 特征值+ 目标值

2、机器学习算法分成哪些类别? 如何分类

答案: 根据是否有目标值分为 监督学习和非监督学习

根据目标值的数据类型:目标值为离散值就是分类问题

 目标值为连续值就是回归问题

3、什么是标准化? 和归一化相比有什么优点?

答案: 标准化是通过对原始数据进行变换把数据变换到均值为0,方差为1范围内

 优点: 少量异常点, 不影响平均值和方差, 对转换影响小





# 3.分类算法

- 知道数据集的分为训练集和测试集

- 知道sklearn的转换器和估计器流程

- 了解sklearn的分类、回归数据集

- 说明K-近邻算法的距离公式
  说明K-近邻算法的超参数K值以及取值问题

- 说明K-近邻算法的优缺点

- 应用KNeighborsClassifier实现分类

- 了解分类算法的评估标准准确率

- 说明朴素贝叶斯算法的原理

- 说明朴素贝叶斯算法的优缺点

- 应用MultinomialNB实现文本分类

- 应用模型选择与调优

- 说明决策树算法的原理

- 说明决策树算法的优缺点

- 应用DecisionTreeClassifier实现分类

- 说明随机森林算法的原理

- 说明随机森林算法的优缺点

- 应用RandomForestClassifier实现分类

  

## 3.1数据集介绍与划分

学习目标

- 目标
  - 知道数据集的分为训练集和测试集
  - 知道sklearn的分类、回归数据集
- 应用
  - 无

拿到的数据是否全部都用来训练一个模型？

1、数据集的划分

机器学习一般的数据集会划分为两个部分：

- 训练数据：用于训练，构建模型
- 测试数据：在模型检验时使用，用于评估模型是否有效

划分比例：

- 训练集：70% 80% 75%
- 测试集：30% 20% 30%

API

- sklearn.model_selection.train_test_split(

  arrays, *

  options)

  - x 数据集的特征值
  - y 数据集的标签值
  - test_size 测试集的大小，一般为float
  - random_state 随机数种子,不同的种子会造成不同的随机采样结果。相同的种子采样结果相同。
  - return ，测试集特征训练集特征值值，训练标签，测试标签(默认随机取)

结合后面的数据集作介绍

2、sklearn数据集介绍

2.1 API

- sklearn.datasets
  - 加载获取流行数据集
  - datasets.load_*()
    - 获取小规模数据集，数据包含在datasets里
  - datasets.fetch_*(data_home=None)
    - 获取大规模数据集，需要从网络上下载，函数的第一个参数是data_home，表示数据集下载的目录,默认是 ~/scikit_learn_data/

2.2分类和回归数据集

- 分类数据集

![分类数据集](https://i0.hdslb.com/bfs/album/ddeb2fe440e9b07c435235c355397c798d1f2ab3.png)

- sklearn.datasets.fetch_20newsgroups(data_home=None,subset=‘train’)
  - subset: 'train'或者'test','all'，可选，选择要加载的数据集.训练集的“训练”，测试集的“测试”，两者的“全部”
- 回归数据集

![回归数据集](https://i0.hdslb.com/bfs/album/15c4145fc1cd29d637ab63c144eff47c06e171ed.png)

2.3 返回类型

- load

  和fetch

  返回的数据类型datasets.base.Bunch(字典格式)

  - data：特征数据数组，是 [n_samples * n_features] 的二维 numpy.ndarray 数组
  - target：标签数组，是 n_samples 的一维 numpy.ndarray 数组
  - DESCR：数据描述
  - feature_names：特征名,新闻数据，手写数字、回归数据集没有
  - target_names：标签名



## 3.2sklearn转换器和估计器

学习目标

- 目标
  - 知道sklearn的转换器和估计器流程
- 应用
  - 无

1、转换器和估计器

1.1 转换器

想一下之前做的特征工程的步骤？

- 1、实例化 (实例化的是一个转换器类(Transformer))
- 2、调用fit_transform(对于文档建立分类词频矩阵，不能同时调用)

我们把特征工程的接口称之为转换器，其中转换器调用有这么几种形式

- fit_transform
- fit
- transform

**这几个方法之间的区别是什么呢？我们看以下代码就清楚了**

```python
In [1]: from sklearn.preprocessing import StandardScaler

In [2]: std1 = StandardScaler()

In [3]: a = [[1,2,3], [4,5,6]]

In [4]: std1.fit_transform(a)
Out[4]:
array([[-1., -1., -1.],
       [ 1.,  1.,  1.]])

In [5]: std2 = StandardScaler()

In [6]: std2.fit(a)
Out[6]: StandardScaler(copy=True, with_mean=True, with_std=True)

In [7]: std2.transform(a)
Out[7]:
array([[-1., -1., -1.],
       [ 1.,  1.,  1.]])
```

从中可以看出，fit_transform的作用相当于transform加上fit。但是为什么还要提供单独的fit呢, 我们还是使用原来的std2来进行标准化看看

```python
In [8]: b = [[7,8,9], [10, 11, 12]]

In [9]: std2.transform(b)
Out[9]:
array([[3., 3., 3.],
       [5., 5., 5.]])

In [10]: std2.fit_transform(b)
Out[10]:
array([[-1., -1., -1.],
       [ 1.,  1.,  1.]])
```

1.2 估计器(sklearn机器学习算法的实现)

在sklearn中，估计器(estimator)是一个重要的角色，是一类实现了算法的API

- 1、用于分类的估计器：
  - sklearn.neighbors k-近邻算法
  - sklearn.naive_bayes 贝叶斯
  - sklearn.linear_model.LogisticRegression 逻辑回归
  - sklearn.tree 决策树与随机森林
- 2、用于回归的估计器：
  - sklearn.linear_model.LinearRegression 线性回归
  - sklearn.linear_model.Ridge 岭回归
- 3、用于无监督学习的估计器
  - sklearn.cluster.KMeans 聚类

1.3 估计器工作流程

![估计器工作流程](https://i0.hdslb.com/bfs/album/aba75df9c845cf19149a0b5f5a4c869b91e95d87.png)



## 3.3K-近邻算法

学习目标

- 目标
  - 说明K-近邻算法的距离公式
  - 说明K-近邻算法的超参数K值以及取值问题
  - 说明K-近邻算法的优缺点
  - 应用KNeighborsClassifier实现分类
  - 了解分类算法的评估标准准确率
- 应用
  - Facebook签到位置预测
- 内容预览
  - 3.2.1 什么是K-近邻算法
  - 3.2.2 K-近邻算法API
  - 3.2.3 案例：鸢尾花种类预测
  - 3.2.4 K-近邻总结


问题：回忆分类问题的判定方法

什么是K-近邻算法![地图K紧邻算法](https://i0.hdslb.com/bfs/album/d6ffdee01d0a22991ccf2d7e65a3f5e31de1bc93.png)

- 你的“邻居”来推断出你的类别

1、K-近邻算法(KNN)

1.1 定义

如果一个样本在特征空间中的**k个最相似(即特征空间中最邻近)的样本中的大多数属于某一个类别**，则该样本也属于这个类别。

> 来源：KNN算法最早是由Cover和Hart提出的一种分类算法

1.2 距离公式

两个样本的距离可以通过如下公式计算，又叫欧式距离

![距离公式](https://i0.hdslb.com/bfs/album/3d7cf964e98b71bb89a5d5e5b3c57bdf5960da86.png)

2、电影类型分析

假设我们有现在几部电影

![电影类型分析](https://i0.hdslb.com/bfs/album/d2853742af8ddbd3eda0c98e56decde1d322ed6e.png)

其中？ 号电影不知道类别，如何去预测？我们可以利用K近邻算法的思想

![电影距离计算](https://i0.hdslb.com/bfs/album/7f218ace22cd44dae0d5385074fcd92f3376ffeb.png)

2.1 问题

- 如果取的最近的电影数量不一样？会是什么结果？

2.2 K-近邻算法数据的特征工程处理

- 结合前面的约会对象数据，分析K-近邻算法需要做什么样的处理

3、K-近邻算法API

- sklearn.neighbors.KNeighborsClassifier(n_neighbors=5,algorithm='auto')
  - n_neighbors：int,可选（默认= 5），k_neighbors查询默认使用的邻居数
  - algorithm：{‘auto’，‘ball_tree’，‘kd_tree’，‘brute’}，可选用于计算最近邻居的算法：‘ball_tree’将会使用 BallTree，‘kd_tree’将使用 KDTree。‘auto’将尝试根据传递给fit方法的值来决定最合适的算法。 (不同实现方式影响效率)

4、案例：预测签到位置

![FBlocation介绍](https://i0.hdslb.com/bfs/album/7ce3fee13ce4579466465dc238393e3b3a33acf6.png)

数据介绍：将根据用户的位置，准确性和时间戳预测用户正在查看的业务。

```python
train.csv，test.csv 
row_id：登记事件的ID
xy：坐标
准确性：定位准确性 
时间：时间戳
place_id：业务的ID，这是您预测的目标
```

> 官网：https://www.kaggle.com/navoshta/grid-knn/data

4.1 分析

- 对于数据做一些基本处理（这里所做的一些处理不一定达到很好的效果，我们只是简单尝试，有些特征我们可以根据一些特征选择的方式去做处理）

  - 1、缩小数据集范围 DataFrame.query()

  - 4、删除没用的日期数据 DataFrame.drop（可以选择保留）

  - 5、将签到位置少于n个用户的删除

    place_count = data.groupby('place_id').count()

    tf = place_count[place_count.row_id > 3].reset_index()

    data = data[data['place_id'].isin(tf.place_id)]

- 分割数据集

- 标准化处理

- k-近邻预测

4.2 代码

```python
def knncls():
    """
    K近邻算法预测入住位置类别
    :return:
    """
    # 一、处理数据以及特征工程
    # 1、读取收，缩小数据的范围
    data = pd.read_csv("./data/FBlocation/train.csv")

    # 数据逻辑筛选操作 df.query()
    data = data.query("x > 1.0 & x < 1.25 & y > 2.5 & y < 2.75")

    # 删除time这一列特征
    data = data.drop(['time'], axis=1)

    print(data)

    # 删除入住次数少于三次位置
    place_count = data.groupby('place_id').count()

    tf = place_count[place_count.row_id > 3].reset_index()

    data = data[data['place_id'].isin(tf.place_id)]

    # 3、取出特征值和目标值
    y = data['place_id']
    # y = data[['place_id']]

    x = data.drop(['place_id', 'row_id'], axis=1)

    # 4、数据分割与特征工程?

    # （1）、数据分割
    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)

    # (2)、标准化
    std = StandardScaler()

    # 队训练集进行标准化操作
    x_train = std.fit_transform(x_train)
    print(x_train)

    # 进行测试集的标准化操作
    x_test = std.fit_transform(x_test)

    # 二、算法的输入训练预测
    # K值：算法传入参数不定的值    理论上：k = 根号(样本数)
    # K值：后面会使用参数调优方法，去轮流试出最好的参数[1,3,5,10,20,100,200]
    knn = KNeighborsClassifier(n_neighbors=1)

    # 调用fit()
    knn.fit(x_train, y_train)

    # 预测测试数据集，得出准确率
    y_predict = knn.predict(x_test)

    print("预测测试集类别：", y_predict)

    print("准确率为：", knn.score(x_test, y_test))

    return None
```

4.3 结果分析

准确率： 分类算法的评估之一

- 1、k值取多大？有什么影响？

k值取很小：容易受到异常点的影响

k值取很大：受到样本均衡的问题

- 2、性能问题？

距离计算上面，时间复杂度高

5、K-近邻总结

- 优点：
  - 简单，易于理解，易于实现，无需训练
- 缺点：
  - 懒惰算法，对测试样本分类时的计算量大，内存开销大
  - 必须指定K值，K值选择不当则分类精度不能保证
- 使用场景：小数据场景，几千～几万样本，具体场景具体业务去测试







## 3.4模型选择与调优

学习目标

- 目标
  - 说明交叉验证过程
  - 说明超参数搜索过程
  - 应用GridSearchCV实现算法参数的调优
- 应用
  - Facebook签到位置预测调优

- 内容预览

  - 3.3.1 什么是交叉验证（cross validation）

  - 3.2.2 超参数搜索 - 网格搜索（Grid Search)

  - 3.3.3 鸢尾花案例增加K值调优

  - 3.2.4 案例：预测facebook签到位置

  - 3.3.5 总结

1、为什么需要交叉验证

交叉验证目的：**为了让被评估的模型更加准确可信**

2、什么是交叉验证(cross validation)

交叉验证：将拿到的训练数据，分为训练和验证集。以下图为例：将数据分成5份，其中一份作为验证集。然后经过5次(组)的测试，每次都更换不同的验证集。即得到5组模型的结果，取平均值作为最终结果。又称5折交叉验证。

2.1 分析

我们之前知道数据分为训练集和测试集，但是**为了让从训练得到模型结果更加准确。**做以下处理

- 训练集：训练集+验证集
- 测试集：测试集

![交叉验证过程](https://i0.hdslb.com/bfs/album/dfdc7cdf0828c1b546609efca97a92ebd90f7599.png)

问题：那么这个只是对于参数得出更好的结果，那么怎么选择或者调优参数呢？

3、超参数搜索-网格搜索(Grid Search)

通常情况下，**有很多参数是需要手动指定的（如k-近邻算法中的K值），这种叫超参数**。但是手动过程繁杂，所以需要对模型预设几种超参数组合。**每组超参数都采用交叉验证来进行评估。最后选出最优参数组合建立模型。**

![超参数](https://i0.hdslb.com/bfs/album/8ebe440a9ca05530c4be3aca1862778db93eb22c.png)

3.1 模型选择与调优

- sklearn.model_selection.GridSearchCV(estimator, param_grid=None,cv=None)
  - 对估计器的指定参数值进行详尽搜索
  - estimator：估计器对象
  - param_grid：估计器参数(dict){“n_neighbors”:[1,3,5]}
  - cv：指定几折交叉验证
  - 
  - fit：输入训练数据
  - score：准确率
  - 结果分析：
    - best*score*:在交叉验证中验证的最好结果_
    - best*estimator*：最好的参数模型
    - cv*results*:每次交叉验证后的验证集准确率结果和训练集准确率结果

4、Facebook签到位置预测K值调优

- 使用网格搜索估计器

```python
# 使用网格搜索和交叉验证找到合适的参数
knn = KNeighborsClassifier()

param = {"n_neighbors": [3, 5, 10]}

gc = GridSearchCV(knn, param_grid=param, cv=2)

gc.fit(x_train, y_train)

print("选择了某个模型测试集当中预测的准确率为：", gc.score(x_test, y_test))

# 训练验证集的结果
print("在交叉验证当中验证的最好结果：", gc.best_score_)
print("gc选择了的模型K值是：", gc.best_estimator_)
print("每次交叉验证的结果为：", gc.cv_results_)
```





## 3.5朴素贝叶斯算法

学习目标

- 目标
  - 说明条件概率与联合概率
  - 说明贝叶斯公式、以及特征独立的关系
  - 记忆贝叶斯公式
  - 知道拉普拉斯平滑系数
  - 应用贝叶斯公式实现概率的计算
- 应用
  - 20类新闻文章分类预测
- 内容预览
  - 3.4.1 什么是朴素贝叶斯
  - 3.4.2 概率基础
  - 3.4.3 联合概率、条件概率与相互独立
  - 3.4.4 贝叶斯格式
  - 3.4.5 API
  - 3.4.6 案例：20类新闻分类
  - 3.4.7 朴素贝叶斯算法总结
  - 3.4.8 总结


1、 什么是朴素贝叶斯分类方法

![垃圾邮件分类](https://i0.hdslb.com/bfs/album/d77ed9db003b8d97d36c7ccc2a2e95ff89d5d550.png)



![文章分类](https://i0.hdslb.com/bfs/album/8075e8fd7f79c36af790d72f24d7818e51c0a773.png)





2、 概率基础

2.1 概率(Probability)定义

- 概率定义为一件事情发生的可能性
  - 扔出一个硬币，结果头像朝上
  - 某天是晴天
- P(X) : 取值在[0, 1]

2.2 女神是否喜欢计算案例

在讲这两个概率之前我们通过一个例子，来计算一些结果：

![计算概率](https://i0.hdslb.com/bfs/album/6e7eccb30e3857dcd70529bc807ec8ad976eb652.png)

- 问题如下：

![概率问题](https://i0.hdslb.com/bfs/album/28bf152c734863b7cf1c5fbdb31418a6ecf391af.png)

那么其中有些问题我们计算的结果不正确，或者不知道计算，我们有固定的公式去计算

2.3 条件概率与联合概率

- 联合概率：包含多个条件，且所有条件同时成立的概率
  - 记作：P(A,B)
  - 特性：P(A, B) = P(A)P(B)
- 条件概率：就是事件A在另外一个事件B已经发生条件下的发生概率
  - 记作：P(A|B)
  - 特性：P(A1,A2|B) = P(A1|B)P(A2|B)

> 注意：此条件概率的成立，**是由于A1,A2相互独立的结果**(记忆)

这样我们计算结果为：

```python
p(程序员, 匀称) =  P(程序员)P(匀称) =3/7*(4/7) = 12/49 
P(产品, 超重|喜欢) = P(产品|喜欢)P(超重|喜欢)=1/2 *  1/4 = 1/8
```

**那么，我们知道了这些知识之后，继续回到我们的主题中。朴素贝叶斯如何分类，这个算法经常会用在文本分类，那就来看文章分类是一个什么样的问题？**

!![文章分类引入](https://i0.hdslb.com/bfs/album/b31f5969806132ca4c097ce75acc9c31c987611e.png)

这个了类似一个条件概率，那么仔细一想，给定文章其实相当于给定什么？结合前面我们将文本特征抽取的时候讲的？所以我们可以理解为

![文章分类引入2](https://i0.hdslb.com/bfs/album/ba74db727fc718a0809fbdba03512ddb7db983db.png)

**但是这个公式怎么求？前面并没有参考例子，其实是相似的，我们可以使用贝叶斯公式去计算**

3、 贝叶斯公式

3.1 公式

![image-20220219020359461](https://i0.hdslb.com/bfs/album/4814b964a886ecb6cb090f6dec6566c44099e022.png)

**那么这个公式如果应用在文章分类的场景当中，我们可以这样看：**

![贝叶斯公式理解](https://i0.hdslb.com/bfs/album/04f9ec7b24b1018def21df9ce091e7f41ba42007.png)

公式分为三个部分：

- P(C)：每个文档类别的概率(某文档类别数／总文档数量)
- P(W│C)：给定类别下特征（被预测文档中出现的词）的概率
  - 计算方法：P(F1│C)=Ni/N （训练文档中去计算）
    - Ni为该F1词在C类别所有文档中出现的次数
    - N为所属类别C下的文档所有词出现的次数和
- P(F1,F2,…) 预测文档中每个词的概率

如果计算两个类别概率比较：

![概率前面比较大小](https://i0.hdslb.com/bfs/album/4e66091f6cbc97bd852f4c102162a832d3264859.png)

**所以我们只要比较前面的大小就可以，得出谁的概率大**

3.2 文章分类计算

- 假设我们从**训练数据集**得到如下信息

![分类计算例子](https://i0.hdslb.com/bfs/album/63601b2460cf00a35bd2bccec93572f0f32b9494.png)

- 计算结果

```python
科技：P(科技|影院,支付宝,云计算) = 𝑃(影院,支付宝,云计算|科技)∗P(科技)=(8/100)∗(20/100)∗(63/100)∗(30/90) = 0.00456109

娱乐：P(娱乐|影院,支付宝,云计算) = 𝑃(影院,支付宝,云计算|娱乐)∗P(娱乐)=(56/121)∗(15/121)∗(0/121)∗(60/90) = 0
```

思考:我们计算出来某个概率为0，合适吗？

3.3 拉普拉斯平滑系数

目的：防止计算出的分类概率为0

![平滑系数公式](https://i0.hdslb.com/bfs/album/ae2a1e3dfb4828e5a83d3a3fb2912ceff382751a.png)

```python
P(娱乐|影院,支付宝,云计算) =P(影院,支付宝,云计算|娱乐)P(娱乐) =P(影院|娱乐)*P(支付宝|娱乐)*P(云计算|娱乐)P(娱乐)=(56+1/121+4)(15+1/121+4)(0+1/121+1*4)(60/90) = 0.00002
```

3.4 API

- sklearn.naive_bayes.MultinomialNB(alpha = 1.0)
  - 朴素贝叶斯分类
  - alpha：拉普拉斯平滑系数

4、案例：20类新闻分类

![新闻分类介绍](https://i0.hdslb.com/bfs/album/e3428ab7f4353d864fef7fd48fc28bde089910ba.png)

4.1 分析

- 分割数据集
- tfidf进行的特征抽取
- 朴素贝叶斯预测

4.2 代码

```python
def nbcls():
    """
    朴素贝叶斯对新闻数据集进行预测
    :return:
    """
    # 获取新闻的数据，20个类别
    news = fetch_20newsgroups(subset='all')

    # 进行数据集分割
    x_train, x_test, y_train, y_test = train_test_split(news.data, news.target, test_size=0.3)

    # 对于文本数据，进行特征抽取
    tf = TfidfVectorizer()

    x_train = tf.fit_transform(x_train)
    # 这里打印出来的列表是：训练集当中的所有不同词的组成的一个列表
    print(tf.get_feature_names())
    # print(x_train.toarray())

    # 不能调用fit_transform
    x_test = tf.transform(x_test)

    # estimator估计器流程
    mlb = MultinomialNB(alpha=1.0)

    mlb.fit(x_train, y_train)

    # 进行预测
    y_predict = mlb.predict(x_test)

    print("预测每篇文章的类别：", y_predict[:100])
    print("真实类别为：", y_test[:100])

    print("预测准确率为：", mlb.score(x_test, y_test))

    return None
```

5、总结

- 优点：
  - 朴素贝叶斯模型发源于古典数学理论，有稳定的分类效率。
  - 对缺失数据不太敏感，算法也比较简单，常用于文本分类。
  - 分类准确度高，速度快
- 缺点：
  - 由于使用了样本属性独立性的假设，所以如果特征属性有关联时其效果不好









## 3.6决策树

学习目标

- 目标
  - 说明信息熵的公式以及作用
  - 说明信息增益的公式作用
  - 应用信息增益实现计算特征的不确定性减少程度
  - 了解决策树的三种算法实现
- 应用
  - 泰坦尼克号乘客生存预测

1、认识决策树

决策树思想的来源非常朴素，程序设计中的条件分支结构就是if-then结构，最早的决策树就是利用这类结构分割数据的一种分类学习方法

怎么理解这句话？通过一个对话例子

![相亲对话](https://i0.hdslb.com/bfs/album/900f05c4381bd49c37476e765105fb0c280456fe.png)

想一想这个女生为什么把年龄放在最上面判断！！！！！！！！！

2、决策树分类原理详解

为了更好理解决策树具体怎么分类的，我们通过一个问题例子？

![银行贷款数](https://i0.hdslb.com/bfs/album/c4440814025b4402e3f6ab08f24b02f79a38358b.png)

问题：如何对这些客户进行分类预测？你是如何去划分？

有可能你的划分是这样的

![贷款划分1](https://i0.hdslb.com/bfs/album/bf0c2896e02a6aedb0b283354f4170cc8591ab77.png)

那么我们怎么知道这些特征哪个更好放在最上面，那么决策树的真是划分是这样的

![贷款划分2](https://i0.hdslb.com/bfs/album/8b51dbac3eabd2d21642a701f0ed172c5e7ea0b9.png)

2.1 原理

- 信息熵、信息增益等

**需要用到信息论的知识！！！问题：通过例子引入信息熵**

2.2 信息熵

那来玩个猜测游戏，猜猜这32支球队那个是冠军。并且猜测错误付出代价。每猜错一次给一块钱，告诉我是否猜对了，那么我需要掏多少钱才能知道谁是冠军？ （前提是：不知道任意球队的信息、历史比赛记录、实力等）

![足球队](https://i0.hdslb.com/bfs/album/ad161d34e98b89ba982608b33a209dd17e419f8e.png)

**为了使代价最小，可以使用二分法猜测：**

我可以把球编上号，从1到32，然后提问：冠 军在1-16号吗？依次询问，只需要五次，就可以知道结果。

![二分法猜测](https://i0.hdslb.com/bfs/album/b95efbef09da8611b6b459dcb985da5fdf09d4a1.png)

我们来看这个式子：

- 32支球队，log32=5**比特**
- 64支球队，log64=6**比特**

![香农](https://i0.hdslb.com/bfs/album/c413f9b2e5376fa5011238f54b8678a872e89bd1.png)

**香农指出，它的准确信息量应该是，p为每个球队获胜的概率（假设概率相等，都为1/32），我们不用钱去衡量这个代价了，香浓指出用比特**：

```python
H = -(p1logp1 + p2logp2 + ... + p32log32) = - log32
```

2.2.1 信息熵的定义

- H的专业术语称之为信息熵，单位为比特。

![信息熵公式](https://i0.hdslb.com/bfs/album/ddb6b33c6130fd321fd077ca1f3ad280636861ad.png)

“谁是世界杯冠军”的信息量应该比5比特少，特点（重要）：

- 当这32支球队夺冠的几率相同时，对应的信息熵等于5比特
- 只要概率发生任意变化，信息熵都比5比特大

2.2.2 总结（重要）

- 信息和消除不确定性是相联系的

当我们得到的额外信息（球队历史比赛情况等等）越多的话，那么我们猜测的代价越小（猜测的不确定性减小）

问题： 回到我们前面的贷款案例，怎么去划分？可以利用当得知某个特征（比如是否有房子）之后，我们能够减少的不确定性大小。越大我们可以认为这个特征很重要。那怎么去衡量减少的不确定性大小呢？

2.3 决策树的划分依据之一------信息增益

2.3.1 定义与公式

特征A对训练数据集D的信息增益g(D,A),定义为集合D的信息熵H(D)与特征A给定条件下D的信息条件熵H(D|A)之差，即公式为：

![信息增益公式](https://i0.hdslb.com/bfs/album/dfbd2ed91befb377ca07ae17ba52c2fde4b92cf0.png)

公式的详细解释：

![信息增益公式详解](https://i0.hdslb.com/bfs/album/03e796d5685a24fb3e95f3304287fa6c6b361189.png)

> 注：信息增益表示得知特征X的信息而息的不确定性减少的程度使得类Y的信息熵减少的程度

2.3.2 贷款特征重要计算

![银行贷款数](https://i0.hdslb.com/bfs/album/c4440814025b4402e3f6ab08f24b02f79a38358b.png)

- 我们以年龄特征来计算：

```python
1、g(D, 年龄) = H(D) -H(D|年龄) = 0.971-[5/15H(青年)+5/15H(中年)+5/15H(老年]

2、H(D) = -(6/15log(6/15)+9/15log(9/15))=0.971

3、H(青年) = -(3/5log(3/5) +2/5log(2/5))
H(中年)=-(3/5log(3/5) +2/5log(2/5))
H(老年)=-(4/5og(4/5)+1/5log(1/5))
```

我们以A1、A2、A3、A4代表年龄、有工作、有自己的房子和贷款情况。最终计算的结果g(D, A1) = 0.313, g(D, A2) = 0.324, g(D, A3) = 0.420,g(D, A4) = 0.363。所以我们选择A3 作为划分的第一个特征。这样我们就可以一棵树慢慢建立

2.4 决策树的三种算法实现

当然决策树的原理不止信息增益这一种，还有其他方法。但是原理都类似，我们就不去举例计算。

- ID3
  - 信息增益 最大的准则
- C4.5
  - 信息增益比 最大的准则
- CART
  - 分类树: 基尼系数 最小的准则 在sklearn中可以选择划分的默认原则
  - 优势：划分更加细致（从后面例子的树显示来理解）

2.5 决策树API

- class sklearn.tree.DecisionTreeClassifier(criterion=’gini’, max_depth=None,random_state=None)
  - 决策树分类器
  - criterion:默认是’gini’系数，也可以选择信息增益的熵’entropy’
  - max_depth:树的深度大小
  - random_state:随机数种子
- 其中会有些超参数：max_depth:树的深度大小
  - 其它超参数我们会结合随机森林讲解

- 网站显示结构
  - http://webgraphviz.com/
  - [Graphviz Online (dreampuf.github.io)](https://dreampuf.github.io/GraphvizOnline/#digraph Tree { node [shape%3Dbox] %3B 0 [label%3D"petal length (cm) <%3D 2.45\nentropy %3D 1.584\nsamples %3D 112\nvalue %3D [39%2C 37%2C 36]"] %3B 1 [label%3D"entropy %3D 0.0\nsamples %3D 39\nvalue %3D [39%2C 0%2C 0]"] %3B 0 -> 1 [labeldistance%3D2.5%2C labelangle%3D45%2C headlabel%3D"True"] %3B 2 [label%3D"petal width (cm) <%3D 1.75\nentropy %3D 1.0\nsamples %3D 73\nvalue %3D [0%2C 37%2C 36]"] %3B 0 -> 2 [labeldistance%3D2.5%2C labelangle%3D-45%2C headlabel%3D"False"] %3B 3 [label%3D"petal length (cm) <%3D 5.05\nentropy %3D 0.391\nsamples %3D 39\nvalue %3D [0%2C 36%2C 3]"] %3B 2 -> 3 %3B 4 [label%3D"sepal length (cm) <%3D 4.95\nentropy %3D 0.183\nsamples %3D 36\nvalue %3D [0%2C 35%2C 1]"] %3B 3 -> 4 %3B 5 [label%3D"sepal width (cm) <%3D 2.45\nentropy %3D 1.0\nsamples %3D 2\nvalue %3D [0%2C 1%2C 1]"] %3B 4 -> 5 %3B 6 [label%3D"entropy %3D 0.0\nsamples %3D 1\nvalue %3D [0%2C 1%2C 0]"] %3B 5 -> 6 %3B 7 [label%3D"entropy %3D 0.0\nsamples %3D 1\nvalue %3D [0%2C 0%2C 1]"] %3B 5 -> 7 %3B 8 [label%3D"entropy %3D 0.0\nsamples %3D 34\nvalue %3D [0%2C 34%2C 0]"] %3B 4 -> 8 %3B 9 [label%3D"sepal length (cm) <%3D 6.05\nentropy %3D 0.918\nsamples %3D 3\nvalue %3D [0%2C 1%2C 2]"] %3B 3 -> 9 %3B 10 [label%3D"entropy %3D 0.0\nsamples %3D 1\nvalue %3D [0%2C 1%2C 0]"] %3B 9 -> 10 %3B 11 [label%3D"entropy %3D 0.0\nsamples %3D 2\nvalue %3D [0%2C 0%2C 2]"] %3B 9 -> 11 %3B 12 [label%3D"petal length (cm) <%3D 4.85\nentropy %3D 0.191\nsamples %3D 34\nvalue %3D [0%2C 1%2C 33]"] %3B 2 -> 12 %3B 13 [label%3D"entropy %3D 0.0\nsamples %3D 1\nvalue %3D [0%2C 1%2C 0]"] %3B 12 -> 13 %3B 14 [label%3D"entropy %3D 0.0\nsamples %3D 33\nvalue %3D [0%2C 0%2C 33]"] %3B 12 -> 14 %3B })



3、案例：泰坦尼克号乘客生存预测

- 泰坦尼克号数据

在泰坦尼克号和titanic2数据帧描述泰坦尼克号上的个别乘客的生存状态。这里使用的数据集是由各种研究人员开始的。其中包括许多研究人员创建的旅客名单，由Michael A. Findlay编辑。我们提取的数据集中的特征是票的类别，存活，乘坐班，年龄，登陆，home.dest，房间，票，船和性别。

**1、乘坐班是指乘客班（1，2，3），是社会经济阶层的代表。**

**2、其中age数据存在缺失。**

> 数据：http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic.txt

![泰坦尼克号数据](https://i0.hdslb.com/bfs/album/fc08bec1eaf774b216b443dfa3cb5dedf9d844c6.png)

3.1 分析

- 选择我们认为重要的几个特征 ['pclass', 'age', 'sex']
- 填充缺失值
- 特征中出现类别符号，需要进行one-hot编码处理(DictVectorizer)
  - x.to_dict(orient="records") 需要将数组特征转换成字典数据
- 数据集划分
- 决策树分类预测

3.2 代码

```python
def decisioncls():
    """
    决策树进行乘客生存预测
    :return:
    """
    # 1、获取数据
    titan = pd.read_csv("http://biostat.mc.vanderbilt.edu/wiki/pub/Main/DataSets/titanic.txt")

    # 2、数据的处理
    x = titan[['pclass', 'age', 'sex']]

    y = titan['survived']

    # print(x , y)
    # 缺失值需要处理，将特征当中有类别的这些特征进行字典特征抽取
    x['age'].fillna(x['age'].mean(), inplace=True)

    # 对于x转换成字典数据x.to_dict(orient="records")
    # [{"pclass": "1st", "age": 29.00, "sex": "female"}, {}]

    dict = DictVectorizer(sparse=False)

    x = dict.fit_transform(x.to_dict(orient="records"))

    print(dict.get_feature_names())
    print(x)

    # 分割训练集合测试集
    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)

    # 进行决策树的建立和预测
    dc = DecisionTreeClassifier(max_depth=5)

    dc.fit(x_train, y_train)

    print("预测的准确率为：", dc.score(x_test, y_test))

    return None
```

由于决策树类似一个树的结构，我们可以保存到本地显示

3.3 保存树的结构到dot文件

- 1、sklearn.tree.export_graphviz() 该函数能够导出DOT格式
  - tree.export_graphviz(estimator,out_file='tree.dot’,feature_names=[‘’,’’])
- 2、工具:(能够将dot文件转换为pdf、png)
  - 安装graphviz
  - ubuntu:sudo apt-get install graphviz Mac:brew install graphviz
- 3、运行命令
  - 然后我们运行这个命令
  - dot -Tpng tree.dot -o tree.png

```python
export_graphviz(dc, out_file="./tree.dot", feature_names=['age', 'pclass=1st', 'pclass=2nd', 'pclass=3rd', '女性', '男性'])
```

4、 决策树总结

- 优点：
  - 简单的理解和解释，树木可视化。
- 缺点：
  - **决策树学习者可以创建不能很好地推广数据的过于复杂的树，这被称为过拟合。**
- 改进：
  - 减枝cart算法(决策树API当中已经实现，随机森林参数调优有相关介绍)
  - **随机森林**

**注：企业重要决策，由于决策树很好的分析能力，在决策过程应用较多， 可以选择特征**









## 3.7集成学习方法之随机森林

学习目标

- 目标
  - 说名随机森林每棵决策树的建立过程
  - 知道为什么需要随机有放回(Bootstrap)的抽样
  - 说明随机森林的超参数
- 应用
  - 泰坦尼克号乘客生存预测

1、 什么是集成学习方法

集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是**生成多个分类器/模型**，各自独立地学习和作出预测。**这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。**



集成学习通过建立几个模型组合的来解决单一预测问题。它的工作原理是生成多个分类器/模型，各自独立地学习和作出预测。这些预测最后结合成组合预测，因此优于任何一个单分类的做出预测。

2、 什么是随机森林

在机器学习中，**随机森林是一个包含多个决策树的分类器**，并且其输出的类别是由个别树输出的类别的众数而定。

![随机森林](https://i0.hdslb.com/bfs/album/4ba65e7ba765597732f9dafb31681a8d774c18aa.png)

例如, 如果你训练了5个树, 其中有4个树的结果是True, 1个数的结果是False, 那么最终投票结果就是True

![投票](https://i0.hdslb.com/bfs/album/c3378c4da95419478c23eee68e4b56e90b6de619.png)

3、 随机森林原理过程

学习算法根据下列算法而建造每棵树：

- 用N来表示训练用例（样本）的个数，M表示特征数目。
  - 1、一次随机选出一个样本，重复N次， （有可能出现重复的样本）
  - 2、随机去选出m个特征, m <<M，建立决策树
- 采取bootstrap抽样

3.1 为什么采用BootStrap抽样

- 为什么要随机抽样训练集？　　
  - 如果不进行随机抽样，每棵树的训练集都一样，那么最终训练出的树分类结果也是完全一样的
- 为什么要有放回地抽样？
  - 如果不是有放回的抽样，那么每棵树的训练样本都是不同的，都是没有交集的，这样每棵树都是“有偏的”，都是绝对“片面的”（当然这样说可能不对），也就是说每棵树训练出来都是有很大的差异的；而随机森林最后分类取决于多棵树（弱分类器）的投票表决。

3.2 API

- class sklearn.ensemble.RandomForestClassifier(n_estimators=10, criterion=’gini’, max_depth=None, bootstrap=True, random_state=None, min_samples_split=2)
  - 随机森林分类器
  - n_estimators：integer，optional（default = 10）森林里的树木数量120,200,300,500,800,1200
  - criteria：string，可选（default =“gini”）分割特征的测量方法
  - max_depth：integer或None，可选（默认=无）树的最大深度 5,8,15,25,30
  - max_features="auto”,每个决策树的最大特征数量
    - If "auto", then `max_features=sqrt(n_features)`.
    - If "sqrt", then `max_features=sqrt(n_features)` (same as "auto").
    - If "log2", then `max_features=log2(n_features)`.
    - If None, then `max_features=n_features`.
  - bootstrap：boolean，optional（default = True）是否在构建树时使用放回抽样
  - min_samples_split:节点划分最少样本数
  - min_samples_leaf:叶子节点的最小样本数

- 超参数：n_estimator, max_depth, min_samples_split,min_samples_leaf

3.3 代码

```python
# 随机森林去进行预测
rf = RandomForestClassifier()

param = {"n_estimators": [120,200,300,500,800,1200], "max_depth": [5, 8, 15, 25, 30]}

# 超参数调优
gc = GridSearchCV(rf, param_grid=param, cv=2)

gc.fit(x_train, y_train)

print("随机森林预测的准确率为：", gc.score(x_test, y_test))
```

4、总结

- 在当前所有算法中，具有极好的准确率
- 能够有效地运行在大数据集上，处理具有高维特征的输入样本，而且不需要降维
- 能够评估各个特征在分类问题上的重要性





## 3.8总结



## 3.9每日作业

1、估计器的工作流程是什么?

答案:

第一步: 实例化估计器

第二步: 调用估计器的fit函数, 用训练集的特征值和目标值训练

第三步: 调用预测函数predict, 用测试集的特征值预测

2、决策树的划分依据是什么?(课程介绍的主要方法)

答案: 更具信息增益最大的属性划分.

3、编程: 通过K近邻算法对鸢尾花数据集进行分类预测







# 4.回归与聚类算法

- 说明线性回归的原理
- 应用LinearRegression或SGDRegressor实现回归预测
- 记忆回归算法的评估标准及其公式
- 说明线性回归的缺点
- 说明过拟合与欠拟合的原因以及解决方法
- 说明岭回归的原理即与线性回归的不同之处
- 说明正则化对于权重参数的影响
- 说明L1和L2正则化的区别
- 说明逻辑回归的原理
- 知道逻辑回归的应用场景
- 说明分类(主要针对二分类)问题的评估标准
- 应用classification_report实现精确率、召回率计算
- 应用roc_auc_score实现指标计算
- 应用joblib实现模型的保存与加载
- 说明K-means算法原理
- 说明K-means的性能评估标准轮廓系数
- 说明K-means的优缺点





## 4.1线性回归

学习目标

- 目标
  - 记忆线性回归的原理过程
  - 应用LinearRegression或SGDRegressor实现回归预测
  - 记忆回归算法的评估标准及其公式
- 应用
  - 波士顿房价预测

- 内容预览
  - 4.1.1 线性回归的原理
  - 4.1.2 线性回归的损失和优化原理（理解记忆）
  - 4.1.3 线性回归API
  - 4.1.4 波士顿房价预测



回忆一下回归问题的判定是什么？

1、 线性回归的原理

1.1 线性回归应用场景

- 房价预测
- 销售额度预测
- 金融：贷款额度预测、利用线性回归以及系数分析因子

![销售额度](https://i0.hdslb.com/bfs/album/39771f5024c7eebf217c558e34605963bc010a97.png)

1.2 什么是线性回归

1.2.1定义与公式

线性回归(Linear regression)是利用**回归方程(函数)**对一个或**多个自变量(特征值)和因变量(目标值)之间**关系进行建模的一种分析方式。

- 特点：只有一个自变量的情况称为单变量回归，大于一个自变量情况的叫做多元回归

![线性回归公式](https://i0.hdslb.com/bfs/album/41c94799b91cbe2e849cae89ef96ae853f3c6d7f.png)

那么怎么理解呢？我们来看几个例子

- **期末成绩：0.7×考试成绩+0.3×平时成绩**
- **房子价格 = 0.02×中心区域的距离 + 0.04×城市一氧化氮浓度 + (-0.12×自住房平均房价) + 0.254×城镇犯罪率**

上面两个例子，**我们看到特征值与目标值之间建立的一个关系，这个可以理解为回归方程**。

1.2.2 线性回归的特征与目标的关系分析

线性回归当中的关系有两种，一种是线性关系，另一种是非线性关系。**在这里我们只能画一个平面更好去理解，所以都用单个特征举例子。**

- 线性关系

![线性关系图](https://i0.hdslb.com/bfs/album/be9648519308f466ba7d022a7c9b7cb30dd817d3.png)

![多变量线性关系](https://i0.hdslb.com/bfs/album/a25cee7787701365c87556b6d49431eca7fb642b.png)

> 注释：如果在单特征与目标值的关系呈直线关系，或者两个特征与目标值呈现平面的关系
>
> 更高维度的我们不用自己去想，记住这种关系即可

- 非线性关系

![非线性关系](https://i0.hdslb.com/bfs/album/aa8ed52b9f32387eda42ed7e6e05a4e69bc4ba3b.png)

> 注释：为什么会这样的关系呢？原因是什么？我们后面 讲解过拟合欠拟合重点介绍
>
> 如果是非线性关系，那么回归方程可以理解为：w1x1+w2x2^2+w3x3^2

2、线性回归的损失和优化原理（理解记忆）

**假设刚才的房子例子，真实的数据之间存在这样的关系**

```python
真实关系：真实房子价格 = 0.02×中心区域的距离 + 0.04×城市一氧化氮浓度 + (-0.12×自住房平均房价) + 0.254×城镇犯罪率
```

那么现在呢，我们随意指定一个关系（猜测）

```python
随机指定关系：预测房子价格 = 0.25×中心区域的距离 + 0.14×城市一氧化氮浓度 + 0.42×自住房平均房价 + 0.34×城镇犯罪率
```

请问这样的话，会发生什么？真实结果与我们预测的结果之间是不是存在一定的误差呢？类似这样样子

![误差](https://i0.hdslb.com/bfs/album/04046079817765352dbd3a4e53ac860057e8a796.png)

那么存在这个误差，我们将这个误差给衡量出来

2.1 损失函数

总损失定义为：

![线性回归损失函数](https://i0.hdslb.com/bfs/album/ba06639abe1c69883c998af84e9b9857e0385b8b.png)

- y_i为第i个训练样本的真实值
- h(x_i)为第i个训练样本特征值组合预测函数
- 又称最小二乘法

**如何去减少这个损失，使我们预测的更加准确些？既然存在了这个损失，我们一直说机器学习有自动学习的功能，在线性回归这里更是能够体现。这里可以通过一些优化方法去优化（其实是数学当中的求导功能）回归的总损失！！！**

2.2 优化算法

**如何去求模型当中的W，使得损失最小？（目的是找到最小损失对应的W值）**

线性回归经常使用的两种优化算法

- 正规方程

![正规方程](https://i0.hdslb.com/bfs/album/0da91142a64df607c3162b802cbdaf7a7f4737df.png)

> 理解：X为特征值矩阵，y为目标值矩阵。直接求到最好的结果
>
> 缺点：当特征过多过复杂时，求解速度太慢并且得不到结果

![损失行数求解1](https://i0.hdslb.com/bfs/album/8fcad52020649f2ace1b615210696f504a92d95b.png)

- **梯度下降(Gradient Descent)**

![梯度下降公式](https://i0.hdslb.com/bfs/album/e3d574c81c2b9f8798feded7f6ada23f787dc080.png)

> 理解：α为学习速率，需要手动指定（超参数），α旁边的整体表示方向
>
> 沿着这个函数下降的方向找，最后就能找到山谷的最低点，然后更新W值
>
> 使用：面对训练数据规模十分庞大的任务 ，能够找到较好的结果

我们通过两个图更好理解梯度下降的过程

![单变量的梯度下降](https://i0.hdslb.com/bfs/album/d35c1a8dd969f7dd226796c9338a5cd1345fe525.png)

![多变量的梯度下降](https://i0.hdslb.com/bfs/album/b3e40276936b60da0a9ce257ed87d486ac007c35.png)

**所以有了梯度下降这样一个优化算法，回归就有了"自动学习"的能力**

2.3 优化动态图演示

![线性回归优化动态图](https://i0.hdslb.com/bfs/album/a617e590802ca079861a0776a1d8540ace11d201.gif)

3、 线性回归API

- sklearn.linear_model.LinearRegression(fit_intercept=True)
  - 通过正规方程优化
  - fit_intercept：是否计算偏置
  - LinearRegression.coef_：回归系数
  - LinearRegression.intercept_：偏置
- sklearn.linear_model.SGDRegressor(loss="squared_loss", fit_intercept=True, learning_rate ='invscaling', eta0=0.01)
  - SGDRegressor类实现了随机梯度下降学习，它支持不同的**loss函数和正则化惩罚项**来拟合线性回归模型。
  - loss:损失类型
    - **loss=”squared_loss”: 普通最小二乘法**
  - fit_intercept：是否计算偏置
  - learning_rate : string, optional
    - 学习率填充
    - **'constant': eta = eta0**
    - **'optimal': eta = 1.0 / (alpha \* (t + t0)) [default]**
    - 'invscaling': eta = eta0 / pow(t, power_t)
      - **power_t=0.25:存在父类当中**
    - **对于一个常数值的学习率来说，可以使用learning_rate=’constant’ ，并使用eta0来指定学习率。**
  - SGDRegressor.coef_：回归系数
  - SGDRegressor.intercept_：偏置

> sklearn提供给我们两种实现的API， 可以根据选择使用

4、波士顿房价预测

- 数据介绍

![房价数据集介绍](https://i0.hdslb.com/bfs/album/b75bfe7db8e20b03cf5f898f6cf4726e88335f0a.png)

![属性](https://i0.hdslb.com/bfs/album/b8fff5ae75daef6d6536d388d5a13cac55bf6ca9.png)

> 给定的这些特征，是专家们得出的影响房价的结果属性。我们此阶段不需要自己去探究特征是否有用，只需要使用这些特征。到后面量化很多特征需要我们自己去寻找

4.1 分析

回归当中的数据大小不一致，是否会导致结果影响较大。所以需要做标准化处理。同时我们对目标值也需要做标准化处理。

- 数据分割与标准化处理
- 回归预测
- 线性回归的算法效果评估

4.2 回归性能评估

均方误差(Mean Squared Error)MSE)评价机制：

![线性回归评估](https://i0.hdslb.com/bfs/album/7a4a286298b5c5e172cca6401add0ee24e3e64aa.png)

> 注：y^i为预测值，¯y为真实值

- sklearn.metrics.mean_squared_error(y_true, y_pred)
  - 均方误差回归损失
  - y_true:真实值
  - y_pred:预测值
  - return:浮点数结果

4.2 代码

```python
def mylinearregression():
    """
    线性回归预测房子价格
    :return:
    """
    lb = load_boston()
    #
    # print(lb.data)
    #
    # print(lb.target)

    # 对数据集进行划分
    x_train, x_test, y_train, y_test = train_test_split(lb.data, lb.target, test_size=0.3, random_state=24)

    # 需要做标准化处理对于特征值处理
    std_x = StandardScaler()

    x_train = std_x.fit_transform(x_train)
    x_test = std_x.fit_transform(x_test)
    # print(x_train)

    # 对于目标值进行标准化
    std_y = StandardScaler()

    y_train = std_y.fit_transform(y_train)
    y_test = std_y.transform(y_test)
    y_test = std_y.inverse_transform(y_test)

    # 使用线性模型进行预测
    # 使用正规方程求解
    lr = LinearRegression()
    # # 此时在干什么？
    lr.fit(x_train, y_train)

    y_lr_predict = std_y.inverse_transform(lr.predict(x_test))

    print(lr.coef_)

    print("正规方程预测的结果为：", y_lr_predict)

    print("正规方程的均方误差为：", mean_squared_error(y_test, y_lr_predict))

    # 梯度下降进行预测
    sgd = SGDRegressor()
    #
    sgd.fit(x_train, y_train)
    print("SGD的权重参数为：", sgd.coef_)
    #
    y_sgd_predict = std_y.inverse_transform(sgd.predict(x_test))
    #
    print("SGD的预测的结果为：", y_sgd_predict)
    #
    # # 怎么评判这两个方法好坏
    print("SGD的均方误差为：", mean_squared_error(y_test, y_sgd_predict))

    return None
```

我们也可以尝试去修改学习率

```python
sgd = SGDRegressor(learning_rate='constant', eta0=0.001)
```

此时我们可以通过调参数，找到学习率效果更好的值。

4.3 正规方程和梯度下降对比

![正规方程和梯度下降对比](https://i0.hdslb.com/bfs/album/7e83144113a0f22ddf9289f41f36fd58d846e580.png)

- 文字对比

|       梯度下降       |            正规方程             |
| :------------------: | :-----------------------------: |
|    需要选择学习率    |             不需要              |
|     需要迭代求解     |          一次运算得出           |
| 特征数量较大可以使用 | 需要计算方程，时间复杂度高O(n3) |

- 选择：
  - 小规模数据：
    - **LinearRegression(不能解决拟合问题)**
    - 岭回归
  - 大规模数据：SGDRegressor

5、拓展-关于优化方法GD、SGD、SAG

5.1 GD

**梯度下降(Gradient Descent)，原始的梯度下降法需要计算所有样本的值才能够得出梯度，计算量大，所以后面才有会一系列的改进。**

5.2 SGD

**随机梯度下降(Stochastic gradient descent)是一个优化方法。它在一次迭代时只考虑一个训练样本。**

- SGD的优点是：
  - 高效
  - 容易实现
- SGD的缺点是：
  - SGD需要许多超参数：比如正则项参数、迭代数。
  - SGD对于特征标准化是敏感的。

5.3 SAG

随机平均梯度法(Stochasitc Average Gradient)，由于收敛的速度太慢，有人提出SAG等基于梯度下降的算法

> Scikit-learn：SGDRegressor、岭回归、逻辑回归等当中都会有SAG优化

6、总结

- 线性回归的损失函数-均方误差
- 线性回归的优化方法
  - 正规方程
  - 梯度下降
- 线性回归的性能衡量方法-均方误差
- sklearn的SGDRegressor API 参数



## 4.2欠拟合与过拟合

学习目标

- 目标
  - 说明线性回归（不带正则化）的缺点
  - 说明过拟合与欠拟合的原因以及解决方法
- 应用
  - 无

问题：训练数据训练的很好啊，误差也不大，为什么在测试集上面有问题呢？

当算法在某个数据集当中出现这种情况，可能就出现了过拟合现象。

1、 什么是过拟合与欠拟合

- 欠拟合

![欠拟合](https://i0.hdslb.com/bfs/album/5e6d251039972175f6e9817af0ea475f4f941bd1.png)

- 过拟合

![过拟合](https://i0.hdslb.com/bfs/album/28bc36a368c2bc756ebcd5ad9686dff59d50497e.png)

- 分析
  - 第一种情况：因为机器学习到的天鹅特征太少了，导致区分标准太粗糙，不能准确识别出天鹅。
  - 第二种情况：机器已经基本能区别天鹅和其他动物了。然后，很不巧已有的天鹅图片全是白天鹅的，于是机器经过学习后，会认为天鹅的羽毛都是白的，以后看到羽毛是黑的天鹅就会认为那不是天鹅。

1.1 定义

- 过拟合：一个假设在训练数据上能够获得比其他假设更好的拟合， 但是在测试数据集上却不能很好地拟合数据，此时认为这个假设出现了过拟合的现象。(模型过于复杂)
- 欠拟合：一个假设在训练数据上不能获得更好的拟合，并且在测试数据集上也不能很好地拟合数据，此时认为这个假设出现了欠拟合的现象。(模型过于简单)

![欠拟合过拟合图示](https://i0.hdslb.com/bfs/album/8e1125f8e787ca3efbd844c7957348799264132a.png)

那么是什么原因导致模型复杂？线性回归进行训练学习的时候变成模型会变得复杂，这里就对应前面再说的线性回归的两种关系，非线性关系的数据，也就是存在很多无用的特征或者现实中的事物特征跟目标值的关系并不是简单的线性关系。

2、 原因以及解决办法

- 欠拟合原因以及解决办法
  - 原因：学习到数据的特征过少
  - 解决办法：增加数据的特征数量
- 过拟合原因以及解决办法
  - 原因：原始特征过多，存在一些嘈杂特征， 模型过于复杂是因为模型尝试去兼顾各个测试数据点
  - 解决办法：
    - 正则化

> 在这里针对回归，我们选择了正则化。但是对于其他机器学习算法如分类算法来说也会出现这样的问题，除了一些算法本身作用之外（决策树、神经网络），我们更多的也是去自己做特征选择，包括之前说的删除、合并一些特征

![模型复杂](https://i0.hdslb.com/bfs/album/fac4b6d19167e695e1bf550e4ec45b795120dddf.png)

如何解决？

![正则化](https://i0.hdslb.com/bfs/album/1525ffbdc0fffdc1ec9090241b0bc3f0fc9dd321.png)

> 在学习的时候，数据提供的特征有些影响模型复杂度或者这个特征的数据点异常较多，所以算法在学习的时候尽量减少这个特征的影响（甚至删除某个特征的影响），这就是正则化
>
> 注：调整时候，算法并不知道某个特征影响，而是去调整参数得出优化的结果

2.1 正则化类别

- L2正则化
  - 作用：可以使得其中一些W的都很小，都接近于0，削弱某个特征的影响
  - 优点：越小的参数说明模型越简单，越简单的模型则越不容易产生过拟合现象
  - Ridge回归
- L1正则化
  - 作用：可以使得其中一些W的值直接为0，删除这个特征的影响
  - LASSO回归

2.2 拓展-原理(了解)x

> 线性回归的损失函数用最小二乘法，等价于当预测值与真实值的误差满足正态分布时的极大似然估计；岭回归的损失函数，是最小二乘法+L2范数，等价于当预测值与真实值的误差满足正态分布，且权重值也满足正态分布（先验分布）时的最大后验估计；LASSO的损失函数，是最小二乘法+L1范数，等价于等价于当预测值与真实值的误差满足正态分布，且且权重值满足拉普拉斯分布（先验分布）时的最大后验估计





## 4.3线性回归的改进-岭回归

学习目标

- 目标
  - 说明岭回归的原理即与线性回归的不同之处
  - 说明正则化对于权重参数的影响
  - 说明L1和L2正则化的区别
- 应用
  - 波士顿房价预测

1、 带有L2正则化的线性回归-岭回归

岭回归，其实也是一种线性回归。只不过在算法建立回归方程时候，加上正则化的限制，从而达到解决过拟合的效果

1.1 API

- sklearn.linear_model.Ridge(alpha=1.0, fit_intercept=True,solver="auto", normalize=False)
  - 具有l2正则化的线性回归
  - alpha，也叫 λ
    - **λ取值：0~1 1~10**
  - solver:会根据数据自动选择优化方法
    - **sag:如果数据集、特征都比较大，选择该随机梯度下降优化**
  - normalize:数据是否进行标准化
    - normalize=False:可以在fit之前调用preprocessing.StandardScaler标准化数据
  - Ridge.coef_:回归权重
  - Ridge.intercept_:回归偏置

> ```python
> All last four solvers support both dense and sparse data. However,
> only 'sag' supports sparse input when `fit_intercept` is True.
> ```

Ridge方法相当于SGDRegressor(penalty='l2', loss="squared_loss"),只不过SGDRegressor实现了一个普通的随机梯度下降学习，推荐使用Ridge(实现了SAG)

- sklearn.linear_model.RidgeCV(_BaseRidgeCV, RegressorMixin)
  - 具有l2正则化的线性回归，可以进行交叉验证
  - coef_:回归系数

```python
class _BaseRidgeCV(LinearModel):
    def __init__(self, alphas=(0.1, 1.0, 10.0),
                 fit_intercept=True, normalize=False, scoring=None,
                 cv=None, gcv_mode=None,
                 store_cv_values=False):
```

1.2 观察正则化程度的变化，对结果的影响？

![正则化力度](https://i0.hdslb.com/bfs/album/43e9e89b6d8584779ab075dc0800971a2c9670f8.png)

- 正则化力度越大，权重系数会越小
- 正则化力度越小，权重系数会越大

1.3 波士顿房价预测

```python
rd = Ridge(alpha=1.0)

rd.fit(x_train, y_train)
print("岭回归的权重参数为：", rd.coef_)

y_rd_predict = std_y.inverse_transform(rd.predict(x_test))

print("岭回归的预测的结果为：", y_rd_predict)


print("岭回归的均方误差为：", mean_squared_error(y_test, y_rd_predict))
```







## 4.4分类算法-逻辑回归与二分类

学习目标

- 目标
  - 说明逻辑回归的损失函数
  - 说明逻辑回归的优化方法
  - 说明sigmoid函数
  - 知道逻辑回归的应用场景
  - 知道精确率、召回率指标的区别
  - 知道F1-score指标说明召回率的实际意义
  - 说明如何解决样本不均衡情况下的评估
  - 了解ROC曲线的意义说明AUC指标大小
  - 应用classification_report实现精确率、召回率计算
  - 应用roc_auc_score实现指标计算
- 应用
  - 癌症患者预测

逻辑回归（Logistic Regression）是机器学习中的一种分类模型，逻辑回归是一种分类算法，虽然名字中带有回归，但是它与回归之间有一定的联系。由于算法的简单和高效，在实际中应用非常广泛。

1、逻辑回归的应用场景

- 广告点击率
- 是否为垃圾邮件
- 是否患病
- 金融诈骗
- 虚假账号

看到上面的例子，我们可以发现其中的特点，那就是都属于两个类别之间的判断。逻辑回归就是解决二分类问题的利器

2、 逻辑回归的原理

2.1 输入

![逻辑回归输入](https://i0.hdslb.com/bfs/album/f148fed557d6b9ea071d47a43cdd5efcf5399f1e.png)

逻辑回归的输入就是一个线性回归的结果。

2.2 激活函数

- sigmoid函数

![sigmoid公式](https://i0.hdslb.com/bfs/album/11b7649ee6ca63aaf53a2cca98f07955f8a96a64.png)

- 分析
  - 回归的结果输入到sigmoid函数当中
  - 输出结果：[0, 1]区间中的一个概率值，默认为0.5为阈值

> 逻辑回归最终的分类是通过属于某个类别的概率值来判断是否属于某个类别，并且这个类别默认标记为1(正例),另外的一个类别会标记为0(反例)。（方便损失计算）

输出结果解释(重要)：假设有两个类别A，B，并且假设我们的概率值为属于A(1)这个类别的概率值。现在有一个样本的输入到逻辑回归输出结果0.6，那么这个概率值超过0.5，意味着我们训练或者预测的结果就是A(1)类别。那么反之，如果得出结果为0.3那么，训练或者预测结果就为B(0)类别。

所以接下来我们回忆之前的线性回归预测结果我们用均方误差衡量，那如果对于逻辑回归，我们预测的结果不对该怎么去衡量这个损失呢？我们来看这样一张图

![逻辑回归运算过程](https://i0.hdslb.com/bfs/album/e24df96a8952de42ebc3595fca878ccb8a2a344d.png)

那么如何去衡量逻辑回归的预测结果与真实结果的差异呢？

2.3 损失以及优化

2.3.1 损失

逻辑回归的损失，称之为**对数似然损失**，公式如下：

- 分开类别：

![单个对数似然损失](https://i0.hdslb.com/bfs/album/7335d637c4b5c43b659f66a4d2c32dd66c68f2d6.png)

怎么理解单个的式子呢？这个要根据log的函数图像来理解

![单个损失解释](https://i0.hdslb.com/bfs/album/8ad15d664d3220d976cb13cb71fc8e09562c6329.png)

- 综合完整损失函数

![完整对数似然损失](https://i0.hdslb.com/bfs/album/94207ca3ecf231d72fe1d631d49d1c553edcc903.png)

> 看到这个式子，其实跟我们讲的信息熵类似。

接下来我们呢就带入上面那个例子来计算一遍，就能理解意义了。

![损失计算过程](https://i0.hdslb.com/bfs/album/14e3c2ad179d1bad9fe7732439042dff89d0ff90.png)

> 我们已经知道，log(P), P值越大，结果越小，所以我们可以对着这个损失的式子去分析

2.3.2 优化

同样使用梯度下降优化算法，去减少损失函数的值。这样去更新逻辑回归前面对应算法的权重参数，**提升原本属于1类别的概率，降低原本是0类别的概率。**

3、逻辑回归API

- sklearn.linear_model.LogisticRegression(solver='liblinear', penalty=‘l2’, C = 1.0)
  - solver:优化求解方式（默认开源的liblinear库实现，内部使用了坐标轴下降法来迭代优化损失函数）
    - sag：根据数据集自动选择，随机平均梯度下降
  - penalty：正则化的种类
  - C：正则化力度

> **默认将类别数量少的当做正例**

LogisticRegression方法相当于 SGDClassifier(loss="log", penalty=" "),SGDClassifier实现了一个普通的随机梯度下降学习，也支持平均随机梯度下降法（ASGD），可以通过设置average=True。而使用LogisticRegression(实现了SAG)

4、 案例：癌症分类预测-良／恶性乳腺癌肿瘤预测

- 数据介绍

![癌症数据](https://i0.hdslb.com/bfs/album/9b0c92781563e9d3bf86962735f4fae87d6f4d98.png)

原始数据的下载地址：[https://archive.ics.uci.edu/ml/machine-learning-databases/](https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/)

> 数据描述
>
> （1）699条样本，共11列数据，第一列用语检索的id，后9列分别是与肿瘤
>
> 相关的医学特征，最后一列表示肿瘤类型的数值。
>
> （2）包含16个缺失值，用”?”标出。

4.1 分析

- 缺失值处理
- 标准化处理
- 逻辑回归预测

4.2 代码

```python
def logisticregression():
    """
    逻辑回归进行癌症预测
    :return: None
    """
    # 1、读取数据，处理缺失值以及标准化
    column_name = ['Sample code number', 'Clump Thickness', 'Uniformity of Cell Size', 'Uniformity of Cell Shape',
                   'Marginal Adhesion', 'Single Epithelial Cell Size', 'Bare Nuclei', 'Bland Chromatin',
                   'Normal Nucleoli', 'Mitoses', 'Class']

    data = pd.read_csv("https://archive.ics.uci.edu/ml/machine-learning-databases/breast-cancer-wisconsin/breast-cancer-wisconsin.data",
                       names=column_name)

    # 删除缺失值
    data = data.replace(to_replace='?', value=np.nan)

    data = data.dropna()

    # 取出特征值
    x = data[column_name[1:10]]

    y = data[column_name[10]]

    # 分割数据集
    x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.3)

    # 进行标准化
    std = StandardScaler()

    x_train = std.fit_transform(x_train)

    x_test = std.transform(x_test)

    # 使用逻辑回归
    lr = LogisticRegression()

    lr.fit(x_train, y_train)

    print("得出来的权重：", lr.coef_)

    # 预测类别
    print("预测的类别：", lr.predict(x_test))

    # 得出准确率
    print("预测的准确率:", lr.score(x_test, y_test))
    return None
```

在很多分类场景当中我们不一定只关注预测的准确率！！！！！

![手机评判好坏](https://i0.hdslb.com/bfs/album/dbc5cde1d024a3fa84550c1449b2f0c21020d312.png)

比如以这个癌症举例子！！！我们并不关注预测的准确率，而是关注在所有的样本当中，癌症患者有没有被全部预测（检测）出来。

5、分类的评估方法

5.1 精确率与召回率

5.1.1混淆矩阵

在分类任务下，预测结果(Predicted Condition)与正确标记(True Condition)之间存在四种不同的组合，构成混淆矩阵(适用于多分类)

![混淆矩阵](https://i0.hdslb.com/bfs/album/f7472aaded5451d2046cede5269b4ccb0fee5050.png)

5.1.2 精确率(Precision)与召回率(Recall)

- 精确率：预测结果为正例样本中真实为正例的比例（了解）

![精确率](https://i0.hdslb.com/bfs/album/22466e3770a770e598234f7539901a9871b2d7b7.png)

- 召回率：真实为正例的样本中预测结果为正例的比例（查的全，对正样本的区分能力）

![召回率](https://i0.hdslb.com/bfs/album/e36a778653436c0cdc088cdf2012fb5601c4b172.png)

那么怎么更好理解这个两个概念

![精确率与召回率理解](https://i0.hdslb.com/bfs/album/c58e09acecddded4ebc8346ebf7d5f9ae62539cf.png)

还有其他的评估标准，F1-score，反映了模型的稳健型

![F1](https://i0.hdslb.com/bfs/album/492ba4151b7c9bc26a902a4397e55dfa3b7ae433.png)

5.1.3 分类评估报告API

- sklearn.metrics.classification_report(y_true, y_pred, labels=[], target_names=None )
- - y_true：真实目标值
  - y_pred：估计器预测目标值
  - labels:指定类别对应的数字
  - target_names：目标类别名称
  - return：每个类别精确率与召回率

```python
print("精确率和召回率为：", classification_report(y_test, lr.predict(x_test), labels=[2, 4], target_names=['良性', '恶性']))
```

**假设这样一个情况，如果99个样本癌症，1个样本非癌症，不管怎样我全都预测正例(默认癌症为正例),准确率就为99%但是这样效果并不好，这就是样本不均衡下的评估问题**

问题：如何衡量样本不均衡下的评估？

5.2 ROC曲线与AUC指标

5.2.1 知道TPR与FPR

- TPR = TP / (TP + FN)
  - 所有真实类别为1的样本中，预测类别为1的比例
- FPR = FP / (FP + FN)
  - 所有真实类别为0的样本中，预测类别为1的比例

5.2.2 ROC曲线

- ROC曲线的横轴就是FPRate，纵轴就是TPRate，当二者相等时，表示的意义则是：对于不论真实类别是1还是0的样本，分类器预测为1的概率是相等的，此时AUC为0.5

![ROC](https://i0.hdslb.com/bfs/album/d23803dda36caf849c35bebac32281f2e77b697e.png)

5.2.3AUC指标

- AUC的概率意义是随机取一对正负样本，正样本得分大于负样本的概率
- AUC的最小值为0.5，最大值为1，取值越高越好
- **AUC=1，完美分类器，采用这个预测模型时，不管设定什么阈值都能得出完美预测。绝大多数预测的场合，不存在完美分类器。**
- **0.5<AUC<1，优于随机猜测。这个分类器（模型）妥善设定阈值的话，能有预测价值。**

> **最终AUC的范围在[0.5, 1]之间，并且越接近1越好**

5.2.4 AUC计算API

- from sklearn.metrics import roc_auc_score
  - sklearn.metrics.roc_auc_score(y_true, y_score)
    - 计算ROC曲线面积，即AUC值
    - y_true:每个样本的真实类别，必须为0(反例),1(正例)标记
    - y_score:每个样本预测的概率值

```python
# 0.5~1之间，越接近于1约好
y_test = np.where(y_test > 2.5, 1, 0)

print("AUC指标：", roc_auc_score(y_test, lr.predict(x_test)))
```

5.2.5、总结

- AUC只能用来评价二分类
- AUC非常适合评价样本不平衡中的分类器性能









## 4.5模型保存和加载

学习目标

- 目标
  - 应用joblib实现模型的保存与加载
- 应用
  - 无

当训练或者计算好一个模型之后，那么如果别人需要我们提供结果预测，就需要保存模型（主要是保存算法的参数）

1、sklearn模型的保存和加载API

- from sklearn.externals import joblib
  - 保存：joblib.dump(rf, 'test.pkl')
  - 加载：estimator = joblib.load('test.pkl')

2、线性回归的模型保存加载案例

- 保存

```python
# 使用线性模型进行预测
# 使用正规方程求解
lr = LinearRegression()
# 此时在干什么？
lr.fit(x_train, y_train)
# 保存训练完结束的模型
joblib.dump(lr, "test.pkl")
```

- 加载

```python
# 通过已有的模型去预测房价
model = joblib.load("test.pkl")
print("从文件加载进来的模型预测房价的结果：", std_y.inverse_transform(model.predict(x_test)))
```





## 4.6无监督学习-K-means算法

学习目标

- 目标
  - 说明K-means算法原理
  - 说明K-means的性能评估标准轮廓系数
  - 说明K-means的优缺点
- 应用
  - instacart用户聚类
- 内容预览
  - 4.6.1 什么是无监督学习
  - 4.6.2 无监督学习包含算法
  - 4.6.3 K-means原理
  - 4.6.4 K-meansAPI
  - 4.6.5 案例：k-means对Instacart Market用户聚类
  - 4.6.6 Kmeans性能评估指标


回忆非监督学习的特点？

1、 什么是无监督学习

![人员聚类](https://i0.hdslb.com/bfs/album/fa039113861479ca6ac1d43ed10826fb27a5e872.png)

- 一家广告平台需要根据相似的人口学特征和购买习惯将美国人口分成不同的小组，以便广告客户可以通过有关联的广告接触到他们的目标客户。
- Airbnb 需要将自己的房屋清单分组成不同的社区，以便用户能更轻松地查阅这些清单。
- 一个数据科学团队需要降低一个大型数据集的维度的数量，以便简化建模和降低文件大小。

我们可以怎样最有用地对其进行归纳和分组？我们可以怎样以一种压缩格式有效地表征数据？**这都是无监督学习的目标，之所以称之为无监督，是因为这是从无标签的数据开始学习的。**

2、 无监督学习包含算法

- 聚类
  - K-means(K均值聚类)
- 降维
  - PCA

3、 K-means原理

我们先来看一下一个K-means的聚类效果图

![K-means如何聚类效果](https://i0.hdslb.com/bfs/album/636ef814c565fda763c8e6b213a9e85b598c8be6.png)

3.1 K-means聚类步骤

- 1、随机设置K个特征空间内的点作为初始的聚类中心
- 2、对于其他每个点计算到K个中心的距离，未知的点选择最近的一个聚类中心点作为标记类别
- 3、接着对着标记的聚类中心之后，重新计算出每个聚类的新中心点（平均值）
- 4、如果计算得出的新中心点与原中心点一样，那么结束，否则重新进行第二步过程

我们以一张图来解释效果

![K-means过程分析](https://i0.hdslb.com/bfs/album/acaa2af85dd1c0145976937ce975f05590fe9720.png)

4、K-meansAPI

- sklearn.cluster.KMeans(n_clusters=8,init=‘k-means++’)
  - k-means聚类
  - n_clusters:开始的聚类中心数量
  - init:初始化方法，默认为'k-means ++’
  - labels_:默认标记的类型，可以和真实值比较（不是值比较）

5、 案例：k-means对Instacart Market用户聚类

5.1 分析

- 1、降维之后的数据
- 2、k-means聚类
- 3、聚类结果显示

5.2 代码

```python
# 取500个用户进行测试
cust = data[:500]
km = KMeans(n_clusters=4)
km.fit(cust)
pre = km.predict(cust)
```

问题：如何去评估聚类的效果呢？

6、Kmeans性能评估指标

6.1 轮廓系数

![轮廓系数公式](https://i0.hdslb.com/bfs/album/20c40a8e44dd5aa5e5c6303a750b8903d1d524e5.png)

> 注：对于每个点i 为已聚类数据中的样本 ，b_i 为i 到其它族群的所有样本的距离最小值，a_i 为i 到本身簇的距离平均值。最终计算出所有的样本点的轮廓系数平均值

6.2 轮廓系数值分析

![img](https://i0.hdslb.com/bfs/album/d56c5dee03a88db48668160c9af742fa70a44bf3.png)

- 分析过程（我们以一个蓝1点为例）
  - 1、计算出蓝1离本身族群所有点的距离的平均值a_i
  - 2、蓝1到其它两个族群的距离计算出平均值红平均，绿平均，取最小的那个距离作为b_i
  - 根据公式：极端值考虑：如果b_i >>a_i: 那么公式结果趋近于1；如果a_i>>>b_i: 那么公式结果趋近于-1

6.3 结论

**如果b_i>>a_i:趋近于1效果越好， b_i<<a_i:趋近于-1，效果不好。轮廓系数的值是介于 [-1,1] ，越趋近于1代表内聚度和分离度都相对较优。**

6.4 轮廓系数API

- sklearn.metrics.silhouette_score(X, labels)
  - 计算所有样本的平均轮廓系数
  - X：特征值
  - labels：被聚类标记的目标值

6.5 用户聚类结果评估

```python
silhouette_score(cust, pre)
```

7、K-means总结

- 特点分析：采用迭代式算法，直观易懂并且非常实用
- 缺点：容易收敛到局部最优解(多次聚类)

> 注意：聚类一般做在分类之前



## 4.7总结



## 4.8每日作业

1、线性回归的参数求解的方法是什么?

答案: 正规方程和梯度下降

2、什么是过拟合? 原因有哪些?

答案: 过拟合就是训练误差很小,但是测试误差很大

 原因有: 样本偏差, 模型过于复杂

3、分类问题, 回归问题, 聚类问题的评估方法分别是什么?

答案: 分类问题的评估方法是准确率, 精确率和召回率

回归问题的评估方法是均方差

聚类问题的评估方法是轮廓系数

1、线性回归的参数求解的方法是什么?

答案: 正规方程和梯度下降

2、什么是过拟合? 原因有哪些?

答案: 过拟合就是训练误差很小,但是测试误差很大

 原因有: 样本偏差, 模型过于复杂

3、分类问题, 回归问题, 聚类问题的评估方法分别是什么?

答案: 分类问题的评估方法是准确率, 精确率和召回率

回归问题的评估方法是均方差

聚类问题的评估方法是轮廓系数

