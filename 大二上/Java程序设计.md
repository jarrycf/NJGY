# 随记



# 终章

## 选择题15*2



![image-20220524155529498](https://i0.hdslb.com/bfs/album/e923d3a316fc4e9d195eb6678a226230d798bba9.png)

![image-20220524155646120](https://i0.hdslb.com/bfs/album/30ef56632a8010c0e69ffb3ba17044955034ee1e.png)

![image-20220524155655367](https://i0.hdslb.com/bfs/album/4f4a927d476f663ee30b82f0784e43a97bf0dd05.png)

![image-20220524155922833](https://i0.hdslb.com/bfs/album/342db7c19d234fc9dda49167aec5dd8e04342869.png)

![image-20220524155937469](https://i0.hdslb.com/bfs/album/00e8ff67dcdec424ceb74b8cc16ab1b6a8efb7ba.png)

![image-20220524160037716](https://i0.hdslb.com/bfs/album/6ccb0bc7bdd1d6ac441f7bd5c2709173e7ab2a16.png)

![image-20220524160052142](https://i0.hdslb.com/bfs/album/a1557e49ec136b9ace95ceefd16c05b933f302c2.png)

、

![image-20220524160336331](https://i0.hdslb.com/bfs/album/e47c7827d7729dc191f7f3eaa24d4d54f7f721dd.png)





![image-20220524160648772](https://i0.hdslb.com/bfs/album/4ec47669e4519969d9ef7fb838ff136580b9ae40.png)

 

![image-20220524160848276](https://i0.hdslb.com/bfs/album/d7aa317cb42b13de8c290491c0400511f05e84ec.png)



![image-20220524161159349](https://i0.hdslb.com/bfs/album/4a3dd37f89c2bffb4309cbf9060fd945e889ad63.png)



![image-20220524161519717](https://i0.hdslb.com/bfs/album/ac102a476a04fb50a6d95adedf5c9dc20ac565f4.png)


c,abcd,d,a,d
ac,a,b,d,c
d,b,d,a,b
b,d,b,d,c
b,c,a,a,a
bc,b,abcd,d,c
ab,c,a,c,c
c,c,c,d,bc
a,a,b,b,c








## 判断5*2

![image-20220524155542057](https://i0.hdslb.com/bfs/album/9031c5dd3281c92f4fefdd29a152fb26690eed7c.png)

![image-20220524155815639](https://i0.hdslb.com/bfs/album/955fe4a805c9de22ef7a1a69cdb16dea513a7ece.png)

![image-20220524155906980](https://i0.hdslb.com/bfs/album/6c98301e7492c4eb5870d9855c54f3668cc030ca.png)

![image-20220524160013824](https://i0.hdslb.com/bfs/album/028b82e15d4f8d21d018bb85110b69dd6e55a75c.png)



![image-20220524160320061](https://i0.hdslb.com/bfs/album/24c5e9567916281d374d06b4a266fbca83e3fcf0.png)



![image-20220524160623362](https://i0.hdslb.com/bfs/album/8d92f451f20c5a05ff19dbf5d762a1ad085f650e.png)



![image-20220524160829999](https://i0.hdslb.com/bfs/album/896f24096961d621fd2d21f4a02a15ab048473ad.png)



![image-20220524161057273](https://i0.hdslb.com/bfs/album/dfe7133acbede897ffa0c7de8bf0a8e330edb6b7.png)



![image-20220524161500606](https://i0.hdslb.com/bfs/album/e825b291cf0a2ee71b8a72efd5a7803414a550d1.png)



对错错对错
错错对对对
错错对对对
对对错对错
错错错对对
错对对对错
错对错错
错错对对对
错错对错错




## 填空5*2

![image-20220524155251803](https://i0.hdslb.com/bfs/album/c61404e21ffb57463a17e3a8299523e2f448a97c.png)


![image-20220524155806628](https://i0.hdslb.com/bfs/album/8753a32120d94208fe5731c24d4d0ce2fd0cf2ef.png)



![image-20220524155843982](https://i0.hdslb.com/bfs/album/1236138c3d4dd29ce2534d16fdc52535629eff97.png)




![image-20220524160002204](https://i0.hdslb.com/bfs/album/2d2a365456caddb29d293827b4a33239c1aea55e.png)



![image-20220524160254359](https://i0.hdslb.com/bfs/album/ad7f71829d4d31b63770fa263b432d88b56b75d7.png)





![image-20220524160610641](https://i0.hdslb.com/bfs/album/bbc2e0000c65781a681ce441ad8aa34e193192b3.png)


![image-20220524160803538](https://i0.hdslb.com/bfs/album/76a49c998c1896b6e5068aee7eb3b5eb228a8c0c.png)







![image-20220524161044992](https://i0.hdslb.com/bfs/album/8204b8a121d49514b5423b3327f8bb05d4abc3dc.png)


![image-20220524161447208](https://i0.hdslb.com/bfs/album/1b646c5f13314d32a90813f2e1fa4e6207c229e4.png)






1.
面向对象，SUN
JavaSE JavaEE JavaME
面向对象，跨平台性，支持多线程
JDK
bin目录

2.
class
单行注释，多行注释，文档注释
基本数据，引用数据
&,&&,|,||
容器，0

3.
封装，继承，多态
class
private，protected，public
static
private

4.
1
重写
final
instanceof
implements

5.
String，StringBuffer
length()
Math.abs()
随机产生数字
Long字段，标准Java计算时代，纳秒数


6.
Collection
hashNext(),next()
ArrayList,LinkedList,HashSet,TreeSet,HashMap,TreeMap
Key,Value
数组

7.
字节流、字符流
java.io
二进制(字节)
BufferedInputStream,BufferedOutputStreanm
InputStreamReader,OutputStreamWriter

8.
Thread,Runnable
新建状态(New)、就绪状态(Runnable)、运行状态(Running)
start()、run()
sleep()
synchronized

9.
java.sql.DriverManager
classpath
update
预编译
1


## 简答5*4




![image-20220524155604307](https://i0.hdslb.com/bfs/album/9fab134bd23f083a259ad8eb3fb9062b18191e8a.png)



> 简单性、安全性、分布性
>
> 面向对象、跨平台性、支持多线程



> 首先将后缀名为.java的源文件进行编译，生成后缀名为.class的字节码文件。
>
> 然后Java虚拟机将字节码文件进行解释执行，并将结果显示出来。





![image-20220524155716890](https://i0.hdslb.com/bfs/album/751d2c3948a7f65aa3065736d3b3c61929cd115b.png)



> byte字节型 1字节
>
> short短整型 2
>
> int 整型 4
>
> long 长整型 8
>
> float 单精度浮点型 4
>
> double 双精度浮点型 8
>
> char 字符型 4
>
> boolean型 表示逻辑值 有ture和false两个值，分别占1个字节







![image-20220524160124253](https://i0.hdslb.com/bfs/album/6c2dc942575ce7edb9f1a4a066d10d5432562558.png)



> 





![image-20220524160147781](https://i0.hdslb.com/bfs/album/26ec773cb5cc1cce6f99a06de015379ee1d6ceaf.png)

![image-20220524160356149](https://i0.hdslb.com/bfs/album/59bd1b138dbbc7b2fff3c545fa0bb16a6ef89c4f.png)



![image-20220524160701885](https://i0.hdslb.com/bfs/album/b52225ce8d651186a6f40e5bbf000cf4f7d2067a.png)



![image-20220524160909551](https://i0.hdslb.com/bfs/album/43b9c4ea82202029a71bb9e245678dd0b4c3421b.png)





 ![image-20220524161213077](https://i0.hdslb.com/bfs/album/6c8a4f54f5aaf8ecf6d5dc77f97a830613662ece.png)

>1. 一种是继承java.lang包下Thread类，覆写Thread类下的run()方法，在run()方法中实现运行线程上的代码
>     new Thread(){
> 	  public void run(){}
>     }.start();


>1. 另一种是实现java.lang.Runnable接口，同样在run()方法中实现运行线程上的代码
		class MyThread implements Runnable(){
		public void run(){}
		}

同步代码块的作用是控制线程，保证同步代码块中只有一个线程在运行，保证了多线程操作数据的安全性




![image-20220524161532603](https://i0.hdslb.com/bfs/album/b27c514cc0400825e087535aa51b8498f3d915be.png)


1.参考答案：

（1）加载并注册数据库驱动；

（2）通过DriverManager获取数据库连接；

（3）通过Connection对象获取Statement对象；

（4）使用Statement执行SQL语句；

（5）操作ResultSet结果集；

（6）回收数据库资源。



2． 参考答案

当相同的SQL语句再次执行时,数据库只需使用缓冲区中的数据,
而无需对SQL语句再次编译,从而有效提高数据的访问效率。




## 编程3*10

![image-20220524155752420](https://i0.hdslb.com/bfs/album/fd2ec23ad7acd59fc6bf5beec980c04ee877b534.png)


![image-20220524160522753](https://i0.hdslb.com/bfs/album/1970926ae72c0fc4852fe8d72bf39ca6b0cf0587.png)


![image-20220524150041833](https://i0.hdslb.com/bfs/album/4866da44f2a9db8d6a6a1b5ccc59183eaf8e080c.png)



![image-20220524160736856](https://i0.hdslb.com/bfs/album/71f8b6e977a0dcb0a8e2e00cacd07b0e2ca3b13c.png)

![](https://i0.hdslb.com/bfs/album/c94b9eba5e21bf6912279338b5be4d76f6e78eef.png)




# 应试-没用

![image-20220524141256980](https://i0.hdslb.com/bfs/album/2f7c06ee6e402234840fcab6d9669cf2b8dc523a.png)



## 填空

### java基础



1．Java程序代码必须放在一个类中，类使用________关键词定义。__

> class



2．Java中的注释有三类，分别是________、________和________。__

> 单行注释、 多行注释、文档注释



3．在Java中，变量的数据类型分为两种，即___类型和________类型。

> 基本数据、引用数据



4．在逻辑运算符中，运算符________和________用于表示逻辑与，______和_表示逻辑或

> &、&&、|、||



5．数组是一个________，存储到数组中的每个元素，都有自己的自动编号，最小值为________。

> 容器、0





---

### 面向对象上



1．面向对象的三大特征是________、________、________。

> 封装、继承、多态



2．定义类的关键字为________。

>class



3．针对类、成员方法和属性，Java提供了4种访问控制权限，分别是____、____、___和defualt。

>private、protected、public



4．静态方法必须使用________关键字来修饰。

>static



5．类的封装是指在定义一个类时，将类中的属性私有化，即使用________关键字来修饰。

>private



---

### 面向对象下



1．Java中一个类最多可以继承________个类。

> 1



2．在继承关系中，子类会自动继承父类中的方法，但有时在子类中需要对继承的方法进行一些修改，即对父类的方法进行________。

>重写



3．________关键字可用于修饰类、变量和方法，它有“这是无法改变的”或者“最终”的含义。

>final



4．Java提供了一个关键字________，可以判断一个对象是否为某个类(或接口)的实例或者子类实例。

> instanceof



5．一个类如果要实现一个接口，可以通过关键字________来实现这个接口。

> implements



---



### API

![image-20220524144706180](https://i0.hdslb.com/bfs/album/00d39c156408952b0573a5e61fdcc3ebe009b07e.png)

![image-20220524144745767](https://i0.hdslb.com/bfs/album/e4103b857b9a85ad9ebfb1289f777b147de25e63.png)





### 集合





1． ________是所有单列集合的父接口，它定义了单列集合（List和Set）通用的一些方法。

>Collection
>
>



2．使用Iterator遍历集合时，首先需要调用________方法判断是否存在下一个元素，若存在下一个元素，则调用________方法取出该元素。

>hashNext()  next()
>
>



3．List集合的主要实现类有________、_______，Set集合的主要实现类有________、________，Map集合的主要实现类有________、________。

>ArrayList、LinkedList，HashSet、TreeSet，HashMap、TreeMap
>
>



4．Map接口是一种双列集合，它的每个元素都包含一个键对象________和值对象________，键和值对象之间存在一种对应关系，称为映射。

>Key、Value
>
>



5．ArrayList内部封装了一个长度可变的________。

>数组
>
>

---

### I/0



1．Java中的I/O流，按照传输数据的不同，可分为________和________。

> 字节流、字符流



2．File类中________包中唯一代表磁盘文件本身的对象，它定义了一些与平台无关的方法用于操作文件。

> java.io



3．计算机中，无论是文本、图片、音频还是视频，所有文件都是以________形式存在的。

>二进制（字节）



4．IO提供两个带缓冲的字节流，分别是________和________。

>BufferedInputStream   、BufferedOutputStream



5．在JDK中提供了两个类可以将字节流转换为字符流，它们分别是________和________。

>InputStreamReader、OutputStreamWriter



----



## 判断



### java基础

1．Java语言不区分大小写。

> 错



2．continue语句只用于循环语句中，它的作用是跳出循环。

>错



3．三元运算符的语法格式为“判断条件？表达式1：表达式2”。

>对



4．循环嵌套是指在一个循环语句的循环体中再定义一个循环语句的语法结构。while、do…while、for循环语句都可以进行嵌套，并且它们之间也可以互相嵌套。

>对



5．在switch条件语句和循环语句中都可以使用break语句。

>对



---



### 面向对象上

1．在成员方法中出现的this关键字，代表的是调用这个方法的对象。

> 错



2．静态变量只能在静态方法中使用。

>错



3．与普通方法一样，构造方法也可以重载。

>对



4．私有属性只能在它所在类中被访问，为了能让外界访问私有属性，需要提供一些使用public修饰的公有方法。

>对



5．封装就是隐藏对象的属性和实现细节，仅对外提供公有的方法。

>对



---

### 面向对象下



1．Exception类称为异常类，它表示程序本身可以处理的错误，在开发Java程序中进行的异常处理，都是针对Exception类及其子类。

> 对



2．在try…catch语句中，try语句块存放可能发生异常的语句。

> 对



3．当一个类实现接口时，沒有必要实现接口中的所有方法。

> 错



4．父类的引用指向自己子类的对象是多态的一种体现形式。

> 对



5．方法重写时，子类抛出的异常类型大于等于父类抛出的异常类型。

> 错



---

### API

![image-20220524144829536](https://i0.hdslb.com/bfs/album/39d57bf13190f62d2a99c4ca8cf3efa722784ba3.png)











![image-20220524144842079](https://i0.hdslb.com/bfs/album/f8d33dd2bb0b0693db9bd271f78430fb0b82fbdf.png)



---







### 集合



1．Set集合时通过键值对的方式来存储对象的。

>错
>
>



2．ArrayList集合查询元素的速度很快，但是增删改查效率较低。 

>对
>
>



3．Set接口主要有两个实现类，分别是HashSet和TreeSet。

>对
>
>



4．Map接口是一种双列集合，它的每个元素都包含一个键对象Key和值对象Value。

>对
>
>



5．Lambda表达式只能是一个语句块。

>错
>
>

---

### I/0



1．如果一个File表示目录下有文件或者子目录，调用delete()方法也可以将其删除。

>错



2．File类提供了一系列方法，用于操作其内部封装的路径指向的文件或者目录，boolean exists()方法是判断文件或目录是否存在。

>对



3．JDK提供了两个抽象类InputStream和OutputStream，它们是字节流的顶级父类，所有的字节输入流都继承自OutputStream，所有的字节输出流都继承自InputStream。

>错
>



4．InputStreamReader是Reader的子类，它可以将一个字节输出流转换成字符输出流。

>错



## 选择



### java基础



1．下列选项中，关于类的定义格式正确的是（  ）（多选）
A、 修饰符 class 类名{
程序代码
}
B、修饰符 类名class {
程序代码
}
C、class 类名{
程序代码
}
D、类名 class {
程序代码
}

>AC



2．下列选项中，那些属于合法的标识符？（  ）
A、	username
B、	class
C、	123username
D、	Hello World

>A



3．下列选项中，使用比较运算符正确的是（ ）
A、	4！=3结果为false
B、	4==3 结果为false
C、	4<=3结果为true
D、	4>=3结果为true

>B



4．请阅读下面代码。

```java
int a=3；
int b=2；
switch (b){
	case 1:
		a--；
		break;
	case 2:
		a++；
	case 3:
		a=a+3；
	default:
		a++;
		break;
}
System.out.println(“a=”+a);
```

上述程序运行结束时，变量a的值为（ ）
A、4
B、5
C、7
D、8

>D



5．假设int x=2,三元表达式x>0？x+1：5（ ）
A、0
B、2
C、3
D、5

>C



---



### 面向对象上



1．下列关于this的说法中，错误的是（  ）

A、只能在构造方法中使用this调用其它的构造方法，不能在成员方法中使用。

B、在构造方法中，使用this调用构造方法的语句必须位于第一行，且只能出现一次。

C、this关键字可以用于区分成员变量与局部变量。

D、this可以出现在任何方法中。

>D



2．阅读下列程序：

```java
class Test {
	private static String name;
	static {
	name = "World";
	System.out.print (name);
}
  
public static void main(String[] args) {
	System.out.print("Hello");
	Test test = new Test();
}
}
```

下列选项中，程序运行结果是（  ）

A、HelloWorld

B、WorldHello

C、Hello

D、World

>B
>
>注：因为有静态代码块





3．下列关于构造方法的描述中，错误的是（ ）

A、构造方法的方法名必须和类名一致。

B、构造方法不能写返回值类型。

C、构造方法可以重载。

D、构造方法的访问权限必须和类的访问权限一致。

>D



4．被声明为private，protected 及public 的类成员，在类外部可以被访问的成员是（）

A、只能访问到声明为public的成员

B、只可能访问到声明为protected和public的成员

C、都可以访问

D、都不能访问

>A



5．阅读下列程序：

class A{

​	int x;

​	static int y;

​	void fac(String s){

​		System.out.println(“字符串：”+s);

​	}

}

下列选项中描述正确的是（  ）

A、x,y和s都是成员变量

B、x是实例变量，y是类变量，s是局部变量

C、x和y是实例变量，s是参数

D、x,y和s都是实例变量

>B



---

### 面向对象下



1．下面程序运行的结果是（ ）

```java
class Demo{
     public static void main(String[] args){
            int x = div(1,2);
            try{
            }catch(Exception e){
                System.out.println(e);
            }
            System.out.println(x);
        }
        public static int div(int a,int b){
            return a / b ;
        }
    }
```

A、输出1

B、输出0

C、输出0.5

D、编译失败

> B

> int会抛弃后面的小数



2．现有两个类A、B，以下描述中表示B继承自A的是（）

A、class A extends B.class

B、class B implements A

C、class A implements B

D、class B extends A

>D



3．函数重写与函数重载的相同之处是（）

A、权限修饰符

B、函数名

C、返回值类型

D、形参列表

> B



4．下列关于接口的说法中，错误的是（  ）

A、接口中定义的方法默认使用“public abstract”来修饰

B、接口中的变量默认使用“public static final”来修饰

C、接口中的所有方法都是抽象方法

D、接口中定义的变量可以被修改

> D



5．阅读下段代码：

```java
class Dog {
   public String name;
   Dog(String name){
      this.name =name; 
   }
}
public class Demo1 {
  public static void main(String[] args){
	Dog dog1 = new Dog("xiaohuang");
	Dog dog2 = new Dog("xiaohuang");
    String s1 = dog1.toString();
    String s2 = dog2.toString();
    String s3 = "xiaohuang";
    String s4 = "xiaohuang";
 }
}
```



返回值为true的是（  ）

A、dog1.equals(dog2)

B、s1.equals(s2)

C、s3.equals(s4)

D、dog1==dog2

> C



---

### java

![image-20220524144935738](https://i0.hdslb.com/bfs/album/e217334e2a243d87a702f3bcaca05804bbcbddcc.png)



![image-20220524144953070](https://i0.hdslb.com/bfs/album/5f0034a361eaeea8a16b23e9fcd930bf8e605d1e.png)









---



### 集合

1．以下那些集合可以保存具有映射关系的数据（ ）（多选）
A、ArrayList
B、TreeMap
C、HashMap
D、TreeSet

>BC
>
>



2．下列关于LinkedList类的方法，不是从List接口中继承而来的是（ ）
A、toArray()
B、pop()
C、remove()
D、isEmpty()

>B
>
>



3．以下属于Map接口集合常用方法的有（ ）（多选）
A、boolean containsKey(Object key)
B、Collection values()
C、void forEach(BiConsumer action)
D、boolean replace(Object key, Object value)

>ABCD
>
>



4．使用Iterator时，判断是否存在下一个元素可以使用以下哪个方法（   ）
A、next()
B、hash()
C、hasPrevious()
D、hasNext()

>D
>
>



5．阅读下面的代码：

```java
public class Example{
    public static void main(String[] args) {
        String[] strs = { "Tom", "Jerry", "Donald" };
        // foreach循环遍历数组
        for (String str : strs) {
            str = "Tuffy";
        }
        System.out.println(strs[0]+ "," + strs[1] + "," + strs[2]);
    }
}
```

程序的运行结果是（ ）
A. Tom,Jerry
B. Tom,Jerry, Tuffy
C. Tom,Jerry,Donald
D. 以上都不对

>C
>
>



---



### I/0

1．下列选项中，那些是标准输入输出流？（  ）（多选）

A、System.In

B、System.Out

C、InputStream

D、OutputStream

>AB
>



2．File类中以字符串形式返回文件绝对路径的方法是哪一项？（  ）

A、	getParent()

B、	getName()

C、	getAbsolutePath()

D、	getPath()

>C



3．下列选项中，那个流使用到了缓冲技术？（ ）

A、	BuffereOutputStream

B、 FileIutputStream

C、	DataOutputStream

D、	FileReader

>A



4．在程序开发中，经常需要对文本文件的内容进行读取，如果想从文件中直接读取字符便可以使用字符输入流（  ）

A、Reader

B、Writer

C、FileReader

D、FileWriter

>C
>



5．File类提供了一系列方法，用于操作其内部封装的路径指向的文件或者目录，当File对象对应的文件不存在时，使用哪个方法将新建的一个File对象指定到新文件中。（  ）

A、String getAbsolutePath()

B、boolean canRead()

C、boolean createNewFile()

D、boolean exists()

>C



---





## 简答

### java基础

1．简述Java语言中的8中基本数据类型，并说明每种数据类型所占用的空间大小。

>byte字节型，占一个字节。
>
>short短整型，占两个字节。
>
>int整型，占4个字节。
>
>long长整型，占8个字节。
>
>float单精度浮点型，占4个字节。
>
>double双精度浮点型，占8个字节。
>
>char字符型，占两个字节。
>
>boolean型，表示逻辑值，有true和false两个值，分别占一个字节。



2．简述跳转语句break与continue的作用和区别。

>break是跳出循环，使用在switch条件语句和循环语句中。
>
>- 当它在switch语句中时，它的作用是终止某个case并跳出switch结构
>
>- 当它在循环语句中，它的作用是跳出循环语句，执行循环后面的代码
>
>continue是跳出本次循环，使用在循环语句中。
>
>- 当它在循环语句中，它的作用是终止本次循环，执行下一次循环
>
>







---

### 面向对象上

1．简述你对面向对象的三大特征的理解。

>封装性·：是面向对象核心思想,将对象的属性和行为封装起来,不让外界知道具体实现细节。
>
>继承性：是描述类与类之间的关系,通过继承，可以在无需重新编写原有类的情况下，对原有类的功能进行使用和扩展。
>
>多态性：是指在程序中允许出现重名现象，一个类中定义的属性和方法被其它类继承后，它们可以具有不同的数据类型或表现出不同的行为。这使得同一个属性和方法在不同的类中具有不同的语义。
>
>






2．简述成员变量与局部变量的区别。


成员变量：定义在类中的变量

局部变量：定义在方法中的变量

如果在某一个方法中定义的局部变量与成员变量同名，这种情况是允许的。
此时，在方法中通过变量名访问到的是局部变量。


---

### 面向对象下



1．请简述Java中继承的概念以及使用继承的好处。

> 概念：类的继承是指在一个现有类的基础上去构建一个新的类，构建的一个新类被称作子类,现有类被称作父类，子类会自动拥有父类所有可继承的属性和方法。
>
> 好处：继承性：是描述类与类之间的关系，通过继承，可以在无需重新编写原有类的情况下，对原有类的功能进行使用和扩展。




2．简要概述多态的作用。

> 1、应用程序不必为每一个子类编写功能调用，只需对抽象父类进行处理即可。提高程序的可复用性。
>
> 2、子类的功能可以被父类的方法或引用变量所调用，这叫向后兼容，提高可扩充性和可维护性。
>
> 3、使用多态可以解决项目中紧偶合的问题，提高程序的可扩展性.是OCP原则的一个具体的实现。





----

### API

![image-20220524145815659](https://i0.hdslb.com/bfs/album/57246fe930251a6ee1ec972b0f443a8b30d013ee.png)



![image-20220524145954598](https://i0.hdslb.com/bfs/album/7aad2710d43972894b86bead3648220657e62422.png)


>两个类的对象都可以被多次修改，并不产生新的未使用对象。
>最大区别在于StringBuilder的方法是线程安全的，也就是说StringBuilder可以被同步访问的
> 
> 2.
> byte-Byte
> char-Character
> int-Integer
> short-Short
> long-Long
> float-Float
> double-Double
> boolean-Boolean
>



  

![image-20220524145742769](https://i0.hdslb.com/bfs/album/8ff3c2a002ffe8a41a59af777ca9236630a44d1e.png)



---



### 集合



1．简述集合List、Set和Map的区别。
.

> List的特点是元素有序、可重复。它的主要实现类有ArrayList和LinkedList。
> Set的特点是元素无序、不可重复。它的主要实现类有HashSet和TreeSet。
> Map的特点是存储的元素是键(Key)、值(Value)映射关系，元素都是成对出现的。它的主要实现类有HashMap和TreeMap。

> List的特点是元素有序，可重复，它的主要实现类是ArrayList和LinkedList
> Set的特点的元素无序，不可重复，它的主要实现类是HashSet和TreeSet
> Map的特点是存储的元素是键值映射关系，元素都是成对出现的。它的主要实现类是MapSet和TreeSet



2．简述为什么ArrayList的增删操作比较慢,查找操作比较快。

> 因为Arraylist集合的底层是以一个数组来保存元素的，在对指定位置的元素进行增删操作，会导致创建新的数组，所以比较慢。
> 但数组这种结构允许程序通过索引来访问元素，所以比较快



---



### I/0



1．简述字符流与字节流的区别。

>字节流的两个基类是InputStream和OutputStream，字符流的两个基类是Reader和Writer
>它们都是Object类的直接子类。
>字节流是处理以8位字节为基本单位的字节流类；Reader和Writer类是专门处理16位字节的字符流类。
>



2．简述InputStreamReader类与OutputStreamWriter类的作用。

>InputStreamReader是Reader的子类，它可以将一个字节输入流转换成字符输入流，方便直接读取字符。
OutputStreamWriter是Writer的子类，它可以将一个字节输出流转换成字符输出流，方便直接写入字符。





## 编程

### java基础



1.请编写程序，实现计算“1+3+5+7+…+99”的值，要求如下。

（1）使用循环语句实现自然数1~99的遍历。

（2）在遍历过程中，通过条件判断当前遍历的书是否为奇数，如果是就累加，否则不加。

>```java
>
>package com.homework;
>
>public class charper1 {
>    public static void main(String[] args) {
>        
>        int sum = 0;
>        for(int i = 1; i < 100; i++){
>            if(i % 2 != 0){
>                sum += i;
>            }
>        }
>        System.out.println(sum);
>    }
>}
>
>```
>
>



2.请编写程序，实现获取数组{22,24,76,12,21,33}的最大数。

>```java
>package com.homework;
>
>public class charper1 {
>    public static void main(String[] args) {
>        int[] arr = {22,24,76,12,21,33 };
>        int max = getMax(arr);
>        System.out.println(max);
>
>    }
>    
>    static int getMax(int[] arr){
>        int max = arr[0];
>        for (int i = 1; i < arr.length; i++) {
>            if(max < arr[i]){
>                max = arr[i];
>            }
>        }
>        return max;
>    }
>}
>```
>
>



---

### 面向对象上



定义一个表示学生信息的类Student，要求如下：
   （1）类Student的成员变量：
sNO　表示学号；sName表示姓名；sSex表示性别；sAge表示年龄；sJava：表示Java课程成绩。
   （2）类Student带参数的构造方法：
在构造方法中通过形参完成对成员变量的赋值操作。
   （3）类Student的方法成员：

- getNo（）：获得学号；

- getName（）：获得姓名；

- getSex（）：获得性别；

- getAge（）获得年龄；

- getJava（）：获得Java 课程成绩

  根据类Student的定义，创建五个该类的对象，输出每个学生的信息，计算并输出这五个学生Java语言成绩的平均值，以及计算并输出他们Java语言成绩的最大值和最小值。

> ```java
>  1public class Student {
>  2    private String sNo;
>  3    private String sName;
>  4    private String sSex;
>  5    private int sAge;
>  6    private int sJava;
>  7    //getter&setter方法
>  8    public String getsNo() {
>  9        return sNo;
>  10    }
>  11    public void setsNo(String sNo) {
>  12        this.sNo = sNo;
>  13    }
>  14    public String getsName() {
>  15        return sName;
>  16    }
>  17    public void setsName(String sName) {
>  18        this.sName = sName;
>  19    }
>  20    public String getsSex() {
>  21        return sSex;
>  22    }
>  23    public void setsSex(String sSex) {
>  24        this.sSex = sSex;
>  25    }
>  26    public int getsAge() {
>  27        return sAge;
>  28    }
>  29    public void setsAge(int sAge) {
>  30        this.sAge = sAge;
>  31    }
>  32    public int getsJava() {
>  33        return sJava;
>  34    }
>  35    public void setsJava(int sJava) {
>  36        this.sJava = sJava;
>  37    }
>  38    public Student(String sNo, String sName, String sSex, int sAge, int 	sJava) {
>  39        this.sNo = sNo;
>  40        this.sName = sName;
>  41        this.sSex = sSex;
>  42        this.sAge = sAge;
>  43        this.sJava = sJava;
>  44    }
>  45}
> Test.java
>  46public class Test {
>  47	public static void main(String[] args) {
>  48		Student[] students = new Student[5];
>  49		students[0] = new Student("220110", "Tom", "男", 18, 85);
>  50		students[1] = new Student("220111", "Tohm", "男", 18, 82);
>  51		students[2] = new Student("220112", "Tomf", "女", 18, 79);
>  52		students[3] = new Student("220113", "WTom", "男", 18, 85);
>  53		students[4] = new Student("220114", "seTom", "男", 18, 90);
>  54		int sum = 0;
>  55		int average = 0;
>  56		int max = students[0].getsJava();
>  57		int min = students[0].getsJava();
>  58		for (Student student : students) {
>  59			int java = student.getsJava();
>  60			sum += java;
>  61			if (max < java) {
>  62				max = java;
>  63			}
>  64			if (min > java) {
>  65				min = java;
>  66			}
>  67		}
>  68		average = sum/(students.length);
>  69		System.out.println("Java语言的平均成绩是:"+average);
>  70		System.out.println("Java语言成绩的最大值是:"+max);
>  71		System.out.println("Java语言成绩的最小值是:"+min);
>  72	}
> ```
>
> 

---

### 面向对象下



某公司的雇员分为以下若干类：

```
某公司的雇员分为以下若干类：
(1) Employee：这是所有员工总的父类。
① 属性：员工的姓名,员工的生日月份
② 方法：getSalary(int month) 根据参数月份来确定工资，如果该月员工过生日，则公司会
额外奖励100 元。
(2) SalariedEmployee：Employee 的子类，拿固定工资的员工。
① 属性：月薪。
(3)HourlyEmployee：Employee 的子类，按小时拿工资的员工，每月工作超出160小时的部分按照1.5 倍工资发放。
① 属性：每小时的工资、每月工作的小时数。
(4) SalesEmployee：Employee 的子类，销售，工资由月销售额和提成率决定。
① 属性：月销售额、提成率。
(5) BasePlusSalesEmployee：SalesEmployee 的子类，有固定底薪的销售人员，工资由底薪加
上销售提成部分。
① 属性：底薪。
要求：
创建一个Employee 数组，分别创建若干不同的Employee对象，并打
印某个月的工资。
注意：要求把每个类都做成完全封装，不允许非私有化属性。
```



 标准答案

```python
 73	abstract class Employee{
 74		private String name; 				//定义姓名name并私有化属性
 75		private int month;     				//定义生日月份month并私有化属性
 76		public Employee(){} 				       //无参构造器
 77		public Employee(String name,int month){  //有参构造方法
 78			this.name = name;    //给属性name初始化赋值
 79			this.month = month;  //给属性month初始化赋值
 80		}
 81		//获取属性name的方法
 82		public String getName(){
 83			return name;   //返回name属性
 84		}
 85		//获取属性month的方法
 86		public int getMonth(){
 87			return month;  //返回month属性
 88		}
 89		//给属性name赋初始值
 90		public void setName(String name){
 91			this.name = name;  //本类中的属性name
 92		}
 93		//给属性month赋初始值
 94		public void setMonth(int month){
 95			this.month = month; //本类中的属性month
 96		}
 97	//创建getSalary()方法计算工资，参数month是月份，如果当月是员工生日，奖励100元
 98		public double getSalary(int month){
 99			double salary = 0;      //定义工资变量
 100			//判断当前月份是否是员		工的生日月份，如果是奖励100元
 101			if(this.month == month){
 102				salary = salary + 100;  		
 103				return salary;    //返回工资salary
 104			}
 105		}
 106	}
SalariedEmployee.java
 107	class SalariedEmployee extends Employee{
 108		private double monthSalary; 		   //封装monthSalary属性
 109		public SalariedEmployee(){}   		   //无参构造方法
 110		//有参构造方法   参数  姓名 生日月份  月薪
 111		public SalariedEmployee(String name,int month,double monthSalary){
 112			super(name,month);                  //调用父类有参构造方法
 113			this.monthSalary = monthSalary;   //为属性monthSalary初始化赋值
 114		}
 115		//获取monthSalary的值
 116			public double getMonthSalary(){
 117			return monthSalary;
 118		}
 119		//给monthSalary赋值
 120		public void setMonthSalary(double monthSalary){
 121			this.monthSalary = monthSalary;
 122		}
 123		//覆盖父类中的方法
 124		public double getSalary(int month){
 125	          //定义工资变量
 126			double salary = monthSalary+super.getSalary(month); 
 127			return salary;    
 128		}
 129	}
HourlyEmployee.java
 130	class HourlyEmployee extends Employee{
 131		private double hourlySalary;  //定义属性hourlySalary每小时的工资
 132		private int hours; 			  //定义属性hours每月工作的小时数
 133		public HourlyEmployee(){}    //无参构造方法
 134		//有参构造方法  参数 姓名 生日月份  每小时的工资 每月工作的小时数  
 135		public HourlyEmployee(String name,int month,double hourlySalary,int 			hours){
 136			super(name,month);                  	//调用父类有参构造方法     
 137			this.hourlySalary = hourlySalary ;	//为属性hourlySalary初始化赋值
 138			this.hours = hours; 				//为属性hours 初始化赋值
 139		}
 140		public double getHourlySalary(){    //获取hourlySalary的值
 141			return hourlySalary;
 142		}
 143		public int getHours(){             //获取hours的值
 144			return hours;
 145		}
 146		//定义set方法设置hourlySalary  hours的值
 147		public void setHourlySalary(double hourlySalary){
 148			this.hourlySalary =hourlySalary;
 149		}
 150		public void setHourly(int hours){
 151			this.hours = hours;
 152		}
 153		//覆盖父类方法
 154		public double getSalary(int month){
 155			if(hours < 0){      //如果工作小时数小于0  输出数据错误
 156			System.out.println("数据错误");
 157			return 0;
 158			}	
 159			//小于160个小时的 按照每个月的工作小时数乘以每小时的工资
 160			else if(hours <= 160) 
 161				return hourlySalary*hours+super.getSalary(month); 
 162			//超出160个小时的小时数 按照1.5倍计算		
 163			else return hourlySalary*160+hourlySalary*1.5*(hours-						160)+super.getSalary(month);
 164		}
 165	}
SalesEmployee.java
 166	class SalesEmployee extends Employee{
 167		private double sales ;			//定义销售额sales
 168		private double rate; 			//定义提成率rate
 169		public SalesEmployee(){}
 170		public SalesEmployee(String name,int month,double sales,double rate){
 171			super(name,month);
 172			this.sales = sales;
 173			this.rate = rate;
 174		}
 175		public double getSales(){
 176			return sales;
 177		}
 178		public double getRate(){
 179			return rate;
 180		}
 181		public void setSales(double sales){
 182			this.sales = sales;
 183		}
 184		public void setRate(double rate){
 185			this.rate = rate;
 186		}
 187		public double getSalary(int month){
 188			return this.getSales()*(1+this.getRate())+super.getSalary(month);
 189		}
 190	}
BasePlusSalesEmployee.java
 191	class BasePlusSalesEmployee extends SalesEmployee{
 192		private double baseSalary; //定义基础工资baseSalary
 193		//无参构造方法
 194		public BasePlusSalesEmployee(){}
 195		//有参构造方法
 196		public BasePlusSalesEmployee(String name,int month,double sales,double 		rate,double baseSalary){
 197			super(name,month,sales,rate);
 198			this.baseSalary = baseSalary;
 199		}
 200		//get/set方法对私有属性的调用和设置
 201		public double gatBaseSalary(){
 202			return baseSalary;
 203		}
 204		public void setBaseSalary(){
 205			this.baseSalary = baseSalary;
 206		}
 207		public double getSalary(int month){
 208			return baseSalary+super.getSalary(month);
 209		}
 210	}
Test.java
 211	//定义一个测试类
 212	public class Test{
 213		public static void main(String[] args){
 214		//声明一个Employee类型的数组，并创建不同子类型的对象
 215		Employee[] employee = {new SalariedEmployee(“张三”,1,6000),new 			HourlyEmployee(“李	四”,2,50,180),new SalesEmployee(“王				    五”,3,6500,0.15),new BasePlusSalesEmployee(“赵	六”,4,5000,0.15,2000)};
 216		//打印每个员工的工资
 217		for(int i = 0; i < employee.length ;i++)
 218			System.out.println(Math.round(employee[i].getSalary(10)));
 219		}
 220	}

```







网上答案

```java
//Employee类
public class Employee{
	private String name;
	private int month;
	private double salary;
    //无参构造函数
	public Employee(){

	}
	//有参构造函数
	public Employee(String name,int month,double salary){
		this.name=name;
		this.month=month;
		this.salary=salary;
	}
	public void setName(String name){
		this.name=name;
	}
	public String getName(){
		return name;
	}
	public void setMonth(int month){
		this.month=month;
	}
	public int getMonth(){
		return month;
	}
	public void setSalary(double salary){
		this.salary=salary;
	}
	public double getSalary(){
		return salary;
	}

	public double getSalary(int month){
		if(this.month == month){
			salary += 100;
		}
		System.out.println("员工"+ getName()+"的薪水为："+salary);
		return salary;
	}
}










//SalariedEmployee类
public class SalariedEmployee extends Employee{
	private double salary1;
	 //无参构造函数
	public  SalariedEmployee(){

	}
	//有参构造函数
	public  SalariedEmployee(double salary1){
		this.salary1=salary1;
	}
	public void setSalary1(double salary1){
		this.salary1=salary1;
	}
	public double getSalary1(){
		return salary1;
	}

	public double getSalary(int month){		
		if(this.getMonth() == month){
			salary1 += 100;
		}
		System.out.println("该员工"+getName()+"的薪水为："+salary1);
		return salary1;
	}	

}









//HourlyEmployee类
public class HourlyEmployee extends Employee{
	private int hour;
	private double price;
	private double salary2;
	//无参构造函数
	public  HourlyEmployee(){

	}
	//有参构造函数
	public  HourlyEmployee(int hour,double price,double salary2){
		this.hour=hour;
		this.price=price;
		this.salary2=salary2;
	}
	public void setHour(int hour){
		this.hour=hour;
	}
	public int getHour(){
		return hour;
	}
	public void setPrice(double price){
		this.price=price;
	}
	public double getPrice(){
		return price;
	}
	public void setSalary2(double salary2){
		this.salary2=salary2;
	}
	public double getSalary2(){
		return salary2;
	}

	public double getSalary(int month){
		
		if( hour <= 160){
			salary2=price * hour;
		}
		else{
			hour=hour-160;
			salary2=160 * price + hour *1.6*price;
		}
		if(getMonth() == month){
			salary2+=100;
		}
		System.out.println("该员工"+getName()+"的薪水为："+salary2);
		return salary2;
	}
	

}








//SalesEmployee类
public class SalesEmployee extends Employee{
	private double salemonth;
	private double rate;
	//无参构造函数
	public  SalesEmployee(){

	}
	//有参构造函数
	public SalesEmployee(double salemonth,double rate){
		this.salemonth=salemonth;
		this.rate=rate;
	}
	public void setSalemonth(double salemonth){
		this.salemonth=salemonth;
	}
	public double getSalemonth(){
		return salemonth;
	}
	public void setRate(double rate){
		this.rate=rate;
	}
	public double getRate(){
		return rate;
	}
	public double getSalary(int month){
		if(this.getMonth() == month){
		System.out.println("该员工"+getName()+"的薪水为："+(100+salemonth*rate));
		return (salemonth * rate)+100;
		}else{
		System.out.println("该员工"+getName()+"的薪水为："+salemonth * rate);
		return salemonth * rate;
		}
	}
	
}







//BasePlusSalesEmployee类
public class BasePlusSalesEmployee extends Employee{
	private double minsalary;
	private double salemonth1;
	private double rate1;

	//无参构造函数
	public  BasePlusSalesEmployee(){

	}
	//有参构造函数
	public BasePlusSalesEmployee(double minsalary,double salemonth1,double rate1){
		this.minsalary=minsalary;
		this.salemonth1=salemonth1;
		this.rate1=rate1;
	}
	public void setMinsalary(double minsalary){
		this.minsalary=minsalary;
	}
	public double getMinsalary(){
		return minsalary;
	}
	public void setSalemonth1(double salemonth1){
		this.salemonth1=salemonth1;
	}
	public double getSalemonth1(){
		return salemonth1;
	}
	public void setRate1(double rate1){
		this.rate1=rate1;
	}
	public double getRate1(){
		return rate1;
	}
	public double getSalary(int month){
		if(this.getMonth() == month){
			System.out.println("该员工"+getName()+"的薪水为："+(minsalary+salemonth1*rate1+100));
			return minsalary+salemonth1*rate1+100;
		}
		System.out.println("该员工"+getName()+"的薪水为："+(minsalary+salemonth1*rate1));
		return minsalary+salemonth1*rate1;
	}
}






//某公司
public class test{
	public static void main(String[] args){
		Employee e1 = new Employee("张三",9,0);
		e1.getSalary(6);
		SalariedEmployee s1 = new SalariedEmployee();
		s1.setName("李四");
		s1.setSalary1(6300);
		s1.setMonth(6);
		s1.getMonth();
		s1.getSalary(6);
		HourlyEmployee h1 = new HourlyEmployee(192,36,0);
		h1.setName("王二");
		h1.setMonth(6);
		h1.getMonth();
		h1.getSalary(6);
		SalesEmployee ss1 = new SalesEmployee(26000,0.4);
		ss1.setName("陈一");
		ss1.setMonth(9);
		ss1.getMonth();
		ss1.getSalary(6);
		//System.out.println("该员工"+ss1.getName()+"的薪水为："+ss1.getSalary(6));
		BasePlusSalesEmployee b1 =new BasePlusSalesEmployee(3000,9000,0.5);
		b1.setName("刘六");
		b1.setMonth(9);
		b1.getMonth();
		System.out.println("输出刘六的生日月份："+b1.getMonth());
		b1.getSalary(9);

	}
}
```





---

### API

![image-20220524150019079](https://i0.hdslb.com/bfs/album/156a18528feaf9820a9d551454510d0f46f3a9e2.png)





![image-20220524150041833](https://i0.hdslb.com/bfs/album/4866da44f2a9db8d6a6a1b5ccc59183eaf8e080c.png)





























----



### 集合

1. 请按照下列要求编写程序。 

```
（1） 编写一个Student类，包含name和age属性，提供有参构造方法。 
（2） 在Student类中，重写toString()方法，输出age和name的值。 
（3） 在Student类中，重写hashCode()和equals()方法 a.hashCode()的返回值是name的hash值与age的和。b.equals()判断对象的name和age是否相同，相同则返回true不同返回false。 
（4）最后编写一个测试类，创建一个HashSet<Student>对象hs，向hs中添加多个Student对象，假设有两个Student对象相等，输出HashSet，观察是否添加成功。
```



![image-20220617073503080](/Users/jarrycf/Library/Application Support/typora-user-images/image-20220617073503080.png)

![image-20220617073519884](/Users/jarrycf/Library/Application Support/typora-user-images/image-20220617073519884.png)






>```java
> 1import java.util.*;
> 2class Student {
> 3    private int age;
> 4    private String name;
> 5    public Student(int age, String name) {
> 6        this.age = age;
> 7        this.name = name;
> 8    }
> 9    public String toString() {
> 10        return age + ":" + name;
> 11    }
> 12    public int hashCode() {
> 13        return name.hashCode() + age;
> 14    }
> 15    public boolean equals(Object obj) {
> 16        if (this == obj)
> 17            return true;
> 18        if (!(obj instanceof Student))
> 19            return false;
> 20        Student stu = (Student) obj;
> 21        return this.name.equals(stu.name) && this.age == stu.age;
> 22    }
> 23}
> 24public class Test {
> 25    public static void main(String[] args) {
> 26        HashSet<Student> hs = new HashSet<Student>();
> 27        hs.add(new Student(18, "zhangsan"));
> 28        hs.add(new Student(20, "lisa"));
> 29        hs.add(new Student(20, "lisa"));
> 30        System.out.println(hs);
> 31    }
> 32}
>```
>
>
>
>



2. 请按照下列提示编写一个泛型接口以及其实现类。 

 提示： 

（1）创建一个泛型接口Generic<T>，并创建一个抽象方法get(T t)； 

（2）创建一个实现类GenericImpl<T>，空实现get(T t)方法。

>```java
> 1interface Generic<T>{    
> 2 public abstract void get(T t){} 
> 3}
> 4class Generic<T> implements Generic{    
> 5     public void get(T t){}
> 6 }
>```
>
>
>
>





---

I/0

五、编程题

1.编写一个程序,分别使用字节流和字符流拷贝一个文本文件。要求如下:

（1）使用FileInputStream、FileOutputStreaem和FileReader、FileWriter分别进行拷贝。

（2）使用字节流拷贝时,定义一个1024长度的字节数组作为缓冲区，使用字符流拷贝，使用BufferedReader和BufferedWriter包装流进行包装。

> ```java
>  1	import java.io.*;
>  2	public class Test01 {
>  3		public static void main(String[] args) throws Exception {
>  4			// 字节流拷贝
>  5			FileInputStream in = new FileInputStream("E:/src.txt");
>  6			FileOutputStream out = new FileOutputStream("E:/des1.txt");
>  7			byte[] buf = new byte[1024];
>  8			int len;
>  9			while ((len = in.read(buf)) != -1) {
>  10				out.write(buf, 0, len);
>  11			}
>  12			in.close();
>  13			out.close();
>  14			// 字符流拷贝
>  15			BufferedReader bf = new BufferedReader(new FileReader("E:/src.txt"));
>  16			BufferedWriter bw = new BufferedWriter(new FileWriter("E:/des2.txt"));
>  17			String str;
>  18			while ((str = bf.readLine()) != null) {
>  19				bw.write(str);
>  20				bw.newLine();
>  21			}
>  22			bf.close();
>  23			bw.close();
>  24		}
>  25	}
> 
> 
> 
> ```
>
> 





## 不一定考

## java入门

![image-20220517184834561](https://i0.hdslb.com/bfs/album/439a056850ab69d8f6ccf550521c23e0519c3ae9.png)

> ![image-20220517185155969](https://i0.hdslb.com/bfs/album/485154c43d4054644344fe5230cd9b9f32243ed6.png)







## API

![image-20220517190805975](https://i0.hdslb.com/bfs/album/288f44515d47761e6088464d50ae36adbe04082c.png)



> ![image-20220517185901488](https://i0.hdslb.com/bfs/album/b1ba53246c7a3c39da6b0799e981b11b64c50751.png)
>
> ![image-20220517185919120](https://i0.hdslb.com/bfs/album/bd065cb81549f296b4fd25cb6bade108a0929699.png)











## 集合



![image-20220524150307484](https://i0.hdslb.com/bfs/album/829c1e77d79c782e8a3026f6d7ade56957de28f1.png)

![image-20220524150331764](https://i0.hdslb.com/bfs/album/801afa332a7039ea82a438e9277a2ca1bc711fde.png)



![image-20220524150418578](https://i0.hdslb.com/bfs/album/d1699375817d19769ddcd9c6e1b1f62c07352312.png)





![image-20220524150345569](https://i0.hdslb.com/bfs/album/9e3fa8e49548f567ecb6ad240e206cd750d96a35.png)







![image-20220524150437855](https://i0.hdslb.com/bfs/album/afa23e66ba5183050263474c4974c49932c65fba.png)



![image-20220524150449989](https://i0.hdslb.com/bfs/album/d271ebc21726f90c30b3b08e0786e9f9ccbe92fd.png)



















## 多线程

![image-20220517185635455](https://i0.hdslb.com/bfs/album/2604fbe22502dda82d06b31b31109fd761fdd50b.png)

>
>
>![image-20220517185732952](https://i0.hdslb.com/bfs/album/92446981149eeabb1f0ff372488b4e737cf35a63.png)
>
>![image-20220517185753675](https://i0.hdslb.com/bfs/album/66177b33e230177a03a241c9266b3cbabc5f17ed.png)







## JDBC

![image-20220518101814832](https://i0.hdslb.com/bfs/album/d1f4979b9ac9ec23170a712b4e1598515947b797.png)

![image-20220518101830139](https://i0.hdslb.com/bfs/album/fb43e02f8289e4122d2a9319c46eb4b0182cfc19.png)

![image-20220518101907927](https://i0.hdslb.com/bfs/album/4e0586fa179a2e625cf8b861c9d6fa4bebefbcee.png)







# test 

## java基础



java中语句分两种有何区别？

> 功能执行语句要加；结构定义语句不用



下面的字符串如何从“我的”处后换行？

```java
System.out.println("这是我的第一个语言");
```

> ```java
>         System.out.println("这是我的" +
>                 "第一个语言");
> ```



单行、多行、文档注释符分别是什么?

> ```java
>         /**System.out.println("人" + //服务
>                 "民");*/
>    ```





- 标识符命名时不能出现哪两种情况？

- 开头可以出现哪2种特殊符号？
- 以helloworld命名：包名、类名、常量名、方法名、参数




>以数字开头
>关键字

> _、$

> com.helloword
>
> Helloworld
>
> HELLO_WORLD
>
> helloWorld
>
> helloword





- java中常用哪些关键字？

  - 两个保留关键字是什么？

  - 有哪些不是关键字但也不能用作标识符的？

  - main是否是关键字



><img src="https://i0.hdslb.com/bfs/album/5a7659df3e82689a724f2d56ca222070f2d20103.png" alt="image-20220223000408854"  />

> const、goto

> true、false、null

> 不是





- 6类常量请举例

  - 整型的四种进制以数字85举例？


  - 默认单精度还是双精度


  - 用转义字符表示数字1


  - 字符变量占几个字节

    


> 整型：0b1010101、0125、85、0x55
>
> 浮点：85、85.0(默认)
>
> 字符：'\u0030',2个字符
>
> 字符串：“123”
>
> 布尔：true、false
>
> null：null





- 用2种方式“123”让输出语句换行？



>```java
>System.out.print("123\r\n");
>
>System.out.println("123");
>```





- 数据类型可以分成哪两类？

- 分别又有哪些（英文表示）？
- 最小的整型数据类型和最大的分别表示多大的取值范围
- float和double分别占个字节



> 基本数据类型和引用数据

> 基本：
>
> - byte、short、int、long
> - double、float
> - char
> - boolearn
>
> 引用：
>
> - class
> - interface
> - 数组
> - enum
> - annotation

> -2的7次方～2的7次方-1
> -2的63次方～2的63次方





- 下列这段程序的运行结果是什么？

- L的用处是什么

```java
        long num = 40L;
        System.out.print("num");
```



> 40
> 只有加了L40才从int变成了long类型





- 下列这段程序的运行结果是什么？

- 如何将num1变成float类型

```java
        double num = 40;
				float num1 = 40;
        System.out.print(num);
				System.out.print(num1);
```



> 40.0
>
> 40.0
>
> float num1 = 40f;





- java使用的是哪个字符编码系统，这个系统包括ascII码字符码，还会会为每个字符制定了一个唯一的数值



> Unicode





- char a = 'c';还可以写成什么



> char a = 97;





- 下列这段程序的运行结果是什么？

```java
        boolean b1 = true;
        boolean b2 = false;
        System.out.println(b1);
        System.out.println(b2);
```



> true
>
> false





- 判断：java通过一行代码可以来定义多个变量，但不能在一行对多个变量同时完成赋值




> 正确





- 查看看下列自动类型转换

><img src="https://i0.hdslb.com/bfs/album/15095996a7190226414f7bcb57907c80e7efc0ee.png" alt="image-20220223163829916" style="zoom:50%;" />





- 如何强制转换下列程序b为byte类型？

- 强制转换后的运行结果是什么？

```java
int num = 298;//1 0010 1010
byte b = num;
```




> ```java
> int num = 298;
> byte b = (byte)num;
> ```

>  42





- 下列代码的b3是什么类型？

- 修改语句使b3为byte类型

```java
public class Example03 {
	public static void main(String[] args) {
		byte b1 = 3; // 定义一个byte类型的变量
		byte b2 = 4;
		// 两个byte类型变量相加，赋值给一个byte类型变量
		byte b3 = b1 + b2; 		
		System.out.println("b3=" + b3);
	}
}

```



> int

> byte b3 = (byte)b1 + b2





- 下列这段程序的运行结果是什么？

```java
public class HelloWorld {
    public static void main(String[] args) {
        int x = 12;

        {
            int y = 20;
            System.out.println(x);
            System.out.println(y);


        }
    }
}
```



> 12
>
> 20





- 如何使打印5/2时输出为2.5



> ```java
> sout(5.0/2)
> ```
>





- 下列代码中最后num1的数据类型是什么？

```java
byte num1 = 5;
int num2 = 0;
num1 += num2
```



> Byte





- 表示与、或、非、异或的逻辑运算符分别是什么



> &、｜、！、^





- 写出短路与的符号并说明短路与和与的区别，同理短路或



> &&：左边为false，右边不执行
>
> ||：左边为ture，右边不执行









- 查看下列运算符的优先级

> <img src="https://i0.hdslb.com/bfs/album/78ad73403477a32e883d045c2da6bf2d6d6b7074.png" alt="image-20220225074034228" style="zoom:50%;" />





- 下列代码是对一个学生的考试成绩进行等级划分，如果分数大于80分，则等级为优；如果分数大于70分，则等级为良；如果分数大于60分，则等级为中；如果分数小于60分，则等级为差。画出代码的流程图

```java
public class HelloWorld {
    public static void main(String[] args) {
        int score = 65;
        if(score > 80){
            System.out.println("优秀");
        }else if(score >70){
            System.out.println("良好");
        }else if(score > 60){
            System.out.println("及格");
        }else{
            System.out.println("一般");
        }
    }
}
```



> <img src="https://i0.hdslb.com/bfs/album/9ab25969799abef3178d22c8505867f89276cd2e.png" alt="image-20220227200254740" style="zoom:50%;" />





- 将下列程序写成三元运算符的形式

- 使用三元运算符时要注意哪三点

  

  <img src="https://i0.hdslb.com/bfs/album/98949a57f84cc0a1de3a2c7e26c63a0d6901433b.png" alt="image-20220227200512171" style="zoom:50%;" />



> ```java
> mac = x > y ? x : y;
> ```
>
> 

> 1. ?和：不可分开
> 2. 条件运算符只于赋值运算符
> 3. 嵌套自右向左算





- 用switch条件语句编写下列代码,再添加一个default
  <img src="https://i0.hdslb.com/bfs/album/9dcf23ff43dee93e859c84950085a23725f50e9c.png" alt="image-20220227201042997" style="zoom:50%;" />



> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         int week = 5;
>         switch(week){
>             case 1:
>                 System.out.printf("星期一");
>                 break;
>             case 2:
>                 System.out.printf("星期二");
>                 break;
>             case 3:
>                 System.out.printf("星期三");
>                 break;
>             case 4:
>                 System.out.printf("星期四");
>                 break;
>             case 5:
>                 System.out.printf("星期五");
>                 break;
>             case 6:
>                 System.out.printf("星期六");
>                 break;
>             case 7:
>                 System.out.printf("星期天");
>                 break;
>             default:
>                 System.out.println("天气数字有误");
>                 break;
>         }
>     }
> }
> 
> ```
>
> 





- 修改上面代码，1～5为工作日，6～7位休息日



> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         int week = 5;
>         switch(week){
>             case 1:
>             case 2:
>             case 3:
>             case 4:
>             case 5:
>                 System.out.printf("工作日");
>                 break;
>             case 6:
>             case 7:
>                 System.out.printf("休息日");
>                 break;
>             default:
>                 System.out.println("天气数字有误");
>                 break;
>         }
>     }
> }
> 
> ```







- 写出下面代码运行的结果

```java
public class HelloWorld {
    public static void main(String[] args) {
      
        int x = 5;
        do{
            x++;
        }while(x <= 4);
        
        System.out.println("x = " +x);
      
    }
}
```



> 6





- 编写for循环，实现1～4的累加

- 并说出for循环的执行顺序并说出x最后的值
  ![image-20220312180733634](https://i0.hdslb.com/bfs/album/1344f5e76ed3145d18f0ff23e1ccb9fbde91609e.png)



> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         int sum = 0;
>         for(int x = 1; x <= 4; x++){
>             sum += x;
>         }
>         System.out.println(sum);
>     }
> }
> ```
>

> 1-2-4-3-2-…-3
> 5





- 编写打印n行，每行对应n个*,n设为9



```java
package com.demo01;

public class HelloWord {
    public static void main(String[] args) {
        int n = 9;
        for(int i = 1; i <= n; i++){
            for(int j = 1; j <= i; j++){
                System.out.print("*");
            }
            System.out.println();
        }
    }
}

```





- 改写上面代码，当i>4时结束最外层循环



```java
package com.demo01;

public class HelloWord {
    public static void main(String[] args) {
        int n = 9;
        w:for(int i = 1; i <= n; i++){
            for(int j = 1; j <= i; j++){
                if(i>4){
                    break w;
                }
            System.out.print("*");
            }
            System.out.println();
        }
    }
}

```





- 编写程序求1～100之间的奇数数字和



> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         int sum = 0;
>         for(int i = 1; i <= 100; i++){
>             if(i % 2 == 0){
>                 continue;
>             }
>             sum += i;
>         }
>         System.out.println(sum);
>     }
> } 
> ```





- 编写方法printRectangle，使其能打印任意行、任意列的*号矩型。并将height设为3，width设为5调用。
  编写方法getArea返回矩形的面积，传参值设为3和5，并打印返回值



> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         printRangle(3, 5);
>         int area = getArea(3,5);
>         System.out.println(area);
> 
>     }
>     public static void printRangle(int height, int width){
>         for (int i = 0; i < height; i++) {
>             for (int j = 0; j < width; j++) {
>                 System.out.print("*");
>             }
>             System.out.println();
>         }
>     }
> 
>     public static int getArea(int x, int y){
>         int area = x * y;
>         return area;
>     }
> }
> 
> 
> ```





- 重载方法：定义三个add方法，第一个返回x和y和的方法，第二个返回z,y,z的方法，第三个获取2个小数x,y的方法。并赋值10，20调用



> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         int sum = add(10, 20);
>         System.out.println(sum);
> 
>     }
>     public static int add(int x, int y){
>         return x + y;
>     }
> 
>     public static int add(int x, int y, int z){
>         return x + y + z;
>     }
> 
>     public  static double add(double x, double y){
>         return x + y;
>     }
> }
> 
> 
> ```
>





- 创建arr数组，int类型、长度为3，并打印arr。

  - 打印查看arr的长度


  - 创建arr1的数组，int类型，静态初始化3个值：10，20，30。并查看索引为0的值


  - 将arr清空：空指针

  - 说出arr的打印值“[I@75b84c92”的含义



> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         int[] arr = new int[3];
>         System.out.println(arr);
>         System.out.println(arr.length);
>         int[] arr1 = {10, 20, 30};
>         System.out.println(arr1[0]);
>         arr = null;
>     }
> }
> 
> 
> ```

> 数组 int类型 拼接符 16位地址码





- 写出下列数组类型的默认初始化值

  - 整数类型

  - 小数类型

  - 字符类型

  - 布尔类型

  - 引用类型




> 0
>
> 0.0
>
> 空白字符
>
> false
>
> null





- 创建数组 arr = {20,10,30,40}; int类型，对数组取最大值

- 用冒泡排序法对arr排序并答应排序后的值

  - 排序后是从大到小，还是从小到大

  - 比较了多少轮
  - 每轮比较了多少次



> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         int[] arr = {20,10,30,40};
>         int max = arr[0];
>         for (int i = 0; i < arr.length; i++) {
>             if(arr[i] > max){
>                 max = arr[i];
>             }
>         }
>         System.out.println(max);
>     }
> }
> ```

> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         int[] arr = {20,10,30,40};
>         int max = arr[0];
>         for (int i = 0; i < arr.length - 1; i++) {
>             for (int j = 0; j < arr.length - 1 - i; j++) {
>                 if(arr[j] > arr[j + 1]){
>                     int temp = arr[j];
>                     arr[j] = arr[j+1];
>                     arr[j+1] = temp;
>                 }
>             }
>         }
>         for (int i = 0; i < arr.length; i++) {
>             System.out.print(arr[i] + " ");
>         }
>         System.out.println(max);
>     }
> }
> ```
>
> 从小到大
>
> 数组的长度-1
>
> 比上一轮少一次



- 创建三种方法，方法里分别用三种不同的方式创建一个长度为2的二维数组{{10,20},{30,40}}，并打印其中的10，在主程序完成三种方法的调用



> ```java
> package com.demo01;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         method();
>         method2();
>         method3();
> 
>     }
>     public static void method(){
>         int[][] arr = {{10,20},{30,40}};
>         System.out.println(arr[0][0]);
>     }
> 
>     public static void method2(){
>         int[][] arr = new int[2][];
>         int[] arr1 = {10, 2};
>         int[] arr2 = {30, 40};
>         arr[0] = arr1;
>         arr[1] = arr2;
>         System.out.println(arr[0][0]);
>     }
> 
>     public static void method3(){
>         int[][] arr = new int[2][2];
>         int[] arr1 = {10, 2};
>         int[] arr2 = {30, 40};
>         arr[0] = arr1;
>         arr[1] = arr2;
>         System.out.println(arr[0][0]);
>     }
> 
> }
> 
> 
> ```





- 如何给变量a接受一个整型变量的键盘输入数据



> ```java
> package com.demo01;
> 
> import java.util.Scanner;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         Scanner sc = new Scanner(System.in);
>         int a;
>         a = sc.nextInt();
>         System.out.println(a);
>     }
> }
> ```





- 编写程序，在while循环内给flag的输入数据是“Y”时，继续while循环，当输入“N”时，结束。



> ```java
> package com.demo01;
> 
> import java.util.Scanner;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         Scanner sc = new Scanner(System.in);
>         String flag = "Y";
>         while("Y".equals(flag)){
>             flag = sc.next();
>         }
>  }
>    }
> ```
> 





- 编写程序，赋值给整型变量num一个随机生成数字，范围在1～3



> ```java
> package com.demo01;
> 
> import java.util.Random;
> 
> public class HelloWord {
>     public static void main(String[] args) {
>         Random r = new Random();
>         int num = r.nextInt(3) + 1;
>         System.out.println(num);
>     }
> }
> ```
>



- 设计一个查看登录注册退出的系统
  - 初始化两个数组arr1[0] = "张三"; arr2[0] = "123";



> ```java
> package com.demo01;
> 
> import java.util.Scanner;
> 
> import static sun.security.jgss.GSSUtil.login;
> 
> public class HelloWorld{
> static  String[] arr1 = new String[3];
>  static  String[] arr2 = new String[3];
>  static Scanner sc = new Scanner(System.in);
>  public static void main(String[] args) {
>    arr1[0] = "张三";
>      arr2[0] = "123";
>    
>   while (true) {
>          System.out.println("--------------系统---------------");
>          System.out.println("1、查看功能");
>          System.out.println("2、登录功能");
>          System.out.println("3、注册功能");
>          System.out.println("4、退出系统");
>          int id = sc.nextInt();
>          switch (id){
>              case 1:
>                  show();
>                  break;
>              case 2:
>                  login();
>                  break;
>              case 3:
>                  regist();
>                  break;
>              case 4:
>                  System.out.println("感谢您的使用");
>                  System.exit(0);
>                  break;
>              default:
>                  System.out.println("您输入的有误");
>                  break;
>          }
>      }
>    
> }
>  
> private static void regist() {
>    String username = null;
>      while (true) {
>          System.out.println("请输入用户名：");
>          username = sc.next();
>    
>       boolean flag = false;
>          for (int i = 0; i < arr1.length; i++) {
>               if(arr1[i] != null){
>                   if(arr1[i].equals(username)){
>                       flag = true;
>                       break;
>                   }
>               }
>          }
>          if(flag == true){
>              System.out.println("用户名已存在，请重新输入：");
>          }else{
>              break;
>          }
>      }
>      System.out.println("请输入密码：");
>      String password = sc.next();
>    
>   //判断：当前数组是否装满了
>      boolean flag = true;
>      for (int i = 0; i < arr1.length; i++) {
>          if(arr1[i] == null){
>              flag = false;
>              break;
>          }
>      }
>    
>   if(flag == false){
>          //没有装满
>          for (int i = 0; i < arr1.length; i++) {
>              if(arr1[i] == null){
>                  arr1[i] = username;
>                  arr2[i] = password;
>                  break;
>              }
>          }
>      }else{
>          String[] newArr1 = new String[arr1.length + 3];
>          String[] newArr2 = new String[arr2.length + 3];
>          System.arraycopy(arr1,0,newArr1,0,arr1.length);//arr1[0]开始复制到newArr1[0]，复制元素的个数为arr1.length个
>          System.arraycopy(arr2,0,newArr2,0,arr2.length);
>          arr1 = newArr1;
>          arr2 = newArr2;
>    
>       for (int i = 0; i < arr1.length; i++) {
>              if(arr1[i] == null){
>                  arr1[i] = username;
>                  arr2[i] = password;
>                  break;
>              }
>          }
>      }
>      System.out.println("注册成功");
>    }
>  
> private static void login() {
>    System.out.println("请输入用户名：");
>      String username = sc.next();
>      System.out.println("请输入密码：");
>      String password = sc.next();
>    
>   for (int i = 0; i < arr1.length; i++) {
>          if(arr1[i] != null){
>              if(arr1[i].equals(username) && arr2[i].equals(password)){
>                  System.out.println("登录成功");
>                  return;
>              }
>          }
>      }
>      System.out.println("登录失败");
>    }
>  
> private static void show() {
>    for (int i = 0; i < arr1.length; i++) {
>          if(arr1[i] != null){
>              System.out.println("用户名：" + arr1[i] + ",密码" + arr2[i]);
>          }
>      }
>    }
>  
> }
> ```
> 
>







- 下列关于方法的描述中，正确的是（ ）
  A、方法是对功能代码块的封装
  B、当方法没有返回值时，返回值类型可以不写
  C、当方法没有返回值时，不能有return语句
  D、方法是不可以没有参数的



> A





- 判断

  - 选择语句分为if条件语句和switch条件语句

  - 循环语句有：while语句、do-while语句和for语句

  - 条件语句有：if语句、if-else 语句和if-else if-else 语句



> 对、对、对





- 写出下列程序的值

```java
public class HelloWorld {
    public static void main(String[] args) {
        int a = 0;
        int b = 0;
        for (int i = 1; i <= 5; i++) {
            a = i % 2;
            while (a-- >= 0) {
                b++;
            }
        }
        System.out.println("a=" + a + ",b=" + b);
    }
}
```



> a=-2,b=8





- 关于continue语句的使用范围，下列说法正确的是（）

A、continue语句可以在选择语句中使用

B、continue语句可以在条件语句中使用

C、continue语句可以在循环语句中使用

D、不输出任何内容



> C





- 下列关于方法重载的说法中，正确的是（ ）
  A.形式参数的个数不同。
  B.形式参数的个数不同，数据类型不同。
  C.形式参数的个数相同，数据类型不同。
  D.形式参数的个数相同，数据类型顺序不同。




> ABCD





- 下列选项中，哪一个不能通过编译（ ）

A、byte a=1;

B、short b=100;

C、int c='a';

D、long d=8888888888



> D



- 下列选项中，不属于Java中关键字的是（）

A、const

B、false

C、Final

D、try



> C



- 说出Java中单引号和双引号的区别并举例



> 单引号：char类型，只能有一个字母，数字。char c='c'；
>
> 双引号：String类，可以是一个，也可能是多个字母，数字汉字等。String s="adsaf";





- 查看下列ASCII码表

<img src="https://i0.hdslb.com/bfs/album/da85c3be1c978e745fdbaadb49217268309687de.png" alt="image-20220223140420050" style="zoom:50%;" />





- 对下面的登录注册代码调测，增加功能
  1.主菜单中，修改系统名称，加入自己姓名
  2.增加菜单: 4.删除用户
  3.增加菜单: 5. 修改密码

```java
package com.demo07;
import static sun.security.jgss.GSSUtil.login;
import java.util.Scanner;

        public class StringDemo01{
            static  String[] arr1 = new String[3];
            static  String[] arr2 = new String[3];
            static Scanner sc = new Scanner(System.in);
            public static void main(String[] args) {
                arr1[0] = "张三";
                arr2[0] = "123";

                while (true) {
                    System.out.println("--------------系统---------------");
                    System.out.println("1、查看功能");
                    System.out.println("2、登录功能");
                    System.out.println("3、注册功能");
                    System.out.println("4、退出系统");
                    int id = sc.nextInt();
                    switch (id){
                        case 1:
                            show();
                            break;
                        case 2:
                            login();
                            break;
                        case 3:
                            regist();
                            break;
                        case 4:
                            delete();
                        case 5:
                            alter();
                        case 6:
                            System.out.println("感谢您的使用");
                            System.exit(0);
                            break;
                        default:
                            System.out.println("您输入的有误");
                            break;
                    }
                }

            }

            private static void regist() {
                String username = null;
                while (true) {
                    System.out.println("请输入用户名：");
                    username = sc.next();

                    boolean flag = false;
                    for (int i = 0; i < arr1.length; i++) {
                        if(arr1[i] != null){
                            if(arr1[i].equals(username)){
                                flag = true;
                                break;
                            }
                        }
                    }
                    if(flag == true){
                        System.out.println("用户名已存在，请重新输入：");
                    }else{
                        break;
                    }
                }
                System.out.println("请输入密码：");
                String password = sc.next();

//判断：当前数组是否装满了
                boolean flag = true;
                for (int i = 0; i < arr1.length; i++) {
                    if(arr1[i] == null){
                        flag = false;
                        break;
                    }
                }

                if(flag == false){
                    //没有装满
                    for (int i = 0; i < arr1.length; i++) {
                        if(arr1[i] == null){
                            arr1[i] = username;
                            arr2[i] = password;
                            break;
                        }
                    }
                }else{
                    String[] newArr1 = new String[arr1.length + 3];
                    String[] newArr2 = new String[arr2.length + 3];
                    System.arraycopy(arr1,0,newArr1,0,arr1.length);//arr1[0]开始复制到newArr1[0]，复制元素的个数为arr1.length个
                    System.arraycopy(arr2,0,newArr2,0,arr2.length);
                    arr1 = newArr1;
                    arr2 = newArr2;

                    for (int i = 0; i < arr1.length; i++) {
                        if(arr1[i] == null){
                            arr1[i] = username;
                            arr2[i] = password;
                            break;
                        }
                    }
                }
                System.out.println("注册成功");
            }

            private static void login() {
                System.out.println("请输入用户名：");
                String username = sc.next();
                System.out.println("请输入密码：");
                String password = sc.next();

                for (int i = 0; i < arr1.length; i++) {
                    if(arr1[i] != null){
                        if(arr1[i].equals(username) && arr2[i].equals(password)){
                            System.out.println("登录成功");
                            return;
                        }
                    }
                }
                System.out.println("登录失败");
            }

            private static void show() {
                for (int i = 0; i < arr1.length; i++) {
                    if(arr1[i] != null){
                        System.out.println("用户名：" + arr1[i] + ",密码" + arr2[i]);
                    }
                }
            }

        }
```





> ```java
> package com.demo08;
> 
> import java.util.Scanner;
> 
> public class StringDemo02{
>     static  String[] arr1 = new String[3];
>     static  String[] arr2 = new String[3];
>     static Scanner sc = new Scanner(System.in);
>     public static void main(String[] args) {
>         arr1[0] = "张三";
>         arr2[0] = "123";
> 
>         while (true) {
>             System.out.println("--------------"+arr1[0]+"系统---------------" );
>             System.out.println("1、查看功能");
>             System.out.println("2、登录功能");
>             System.out.println("3、注册功能");
>             System.out.println("4、删除用户");
>             System.out.println("5、修改密码");
>             System.out.println("6、退出系统");
>             int id = sc.nextInt();
>             switch (id){
>                 case 1:
>                     show();
>                     break;
>                 case 2:
>                     login();
>                     break;
>                 case 3:
>                     regist();
>                     break;
>                 case 4:
>                     delete();
>                     break;
>                 case 5:
>                     alter();
>                     break;
>                 case 6:
>                     System.out.println("感谢您的使用");
>                     System.exit(0);
>                     break;
>                 default:
>                     System.out.println("您输入的有误");
>                     break;
>             }
>         }
> 
>     }
> 
>     private static void alter() {
> 
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 System.out.println("用户名：" + arr1[i] + ",密码" + arr2[i]);
>             }
>         }
> 
>         System.out.println("输入你要修改的用户名");
>         String name = sc.next();
> 
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 if(arr1[i].equals(name)){
>                     System.out.println("输入你新的密码");
>                     String password = sc.next();
>                     arr2[i] = password;
>                     }
>                 }
>             }
> 
> 
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 System.out.println("用户名：" + arr1[i] + ",密码" + arr2[i]);
>             }
>         }
> 
>     }
> 
>     private static void delete() {
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 System.out.println("用户名：" + arr1[i] + ",密码" + arr2[i]);
>             }
>         }
> 
>         System.out.println("输入你要删除的用户名");
>         String name = sc.next();
> 
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 if(arr1[i].equals(name)){
>                     for (int j = i; j < arr1.length-1; j++) {
>                             arr1[j] = arr1[j+1];
>                             arr2[j] = arr2[j+1];
>                         }
>                     }
>                     }
>                 }
> 
> 
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 System.out.println("用户名：" + arr1[i] + ",密码" + arr2[i]);
>             }
>         }
> 
>     }
> 
> 
> 
>     private static void regist() {
>         String username = null;
>         while (true) {
>             System.out.println("请输入用户名：");
>             username = sc.next();
> 
>             boolean flag = false;
>             for (int i = 0; i < arr1.length; i++) {
>                 if(arr1[i] != null){
>                     if(arr1[i].equals(username)){
>                         flag = true;
>                         break;
>                     }
>                 }
>             }
>             if(flag == true){
>                 System.out.println("用户名已存在，请重新输入：");
>             }else{
>                 break;
>             }
>         }
>         System.out.println("请输入密码：");
>         String password = sc.next();
> 
> //判断：当前数组是否装满了
>         boolean flag = true;
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] == null){
>                 flag = false;
>                 break;
>             }
>         }
> 
>         if(flag == false){
>             //没有装满
>             for (int i = 0; i < arr1.length; i++) {
>                 if(arr1[i] == null){
>                     arr1[i] = username;
>                     arr2[i] = password;
>                     break;
>                 }
>             }
>         }else{
>             String[] newArr1 = new String[arr1.length + 3];
>             String[] newArr2 = new String[arr2.length + 3];
>             System.arraycopy(arr1,0,newArr1,0,arr1.length);//arr1[0]开始复制到newArr1[0]，复制元素的个数为arr1.length个
>             System.arraycopy(arr2,0,newArr2,0,arr2.length);
>             arr1 = newArr1;
>             arr2 = newArr2;
> 
>             for (int i = 0; i < arr1.length; i++) {
>                 if(arr1[i] == null){
>                     arr1[i] = username;
>                     arr2[i] = password;
>                     break;
>                 }
>             }
>         }
>         System.out.println("注册成功");
>     }
> 
>     private static void login() {
>         System.out.println("请输入用户名：");
>         String username = sc.next();
>         System.out.println("请输入密码：");
>         String password = sc.next();
> 
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 if(arr1[i].equals(username) && arr2[i].equals(password)){
>                     System.out.println("登录成功");
>                     return;
>                 }
>             }
>         }
>         System.out.println("登录失败");
>     }
> 
>     private static void show() {
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 System.out.println("用户名：" + arr1[i] + ",密码" + arr2[i]);
>             }
>         }
>     }
> 
> }
> ```





## 面向对象

> 查看demo01，demo02





面向对象的三大特性是什么？



> 封装、继承、多态





- 编写一个学生类

  - 成员变量age

  - 方法print(无返回值）用于打印成员变量age和创建局部变量name

  - 并分别创建对象是stu和stu2分别调用。

- 成员变量和局部变量相同命名，采取什么原则



> ```java
> package com.demo02;
> 
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student stu = new Student();
>         stu.age = 12;
>         stu.print();
> 
>         Student stu2 = new Student();
>         stu.age = 20;
>         stu.print();
> 
>     }
> }
> 
> ```
>
> ```java
> package com.demo02;
> 
> public class Student {
>     int age;
>     public void print(){
>         String name;
>         System.out.println(age);
>     }
> }
> 
> ```
>
> 

> 就近原则





- java中三类内存的作用分别是什么？
- 并描述下列代码在内存中的变化过程。

```java
public class Student {
 String name;
 int age;
 String sex;

 public void read() {
     System.out.println("姓名是：" + name);
     System.out.println("年龄是：" + age);
     System.out.println("性别是：" + sex);
     System.out.println("好好学习");
 }
}
```

```java
public class StudentDemo01 {
 public static void main(String[] args) {
     Student stu = new Student();
//        System.out.println(stu);
     stu.name = "张三";
     stu.age = 23;
     stu.sex = "男";
     System.out.println(stu.name);
     stu.read(); 

     Student stu2 = new Student();
     stu2.name = "李四";
     stu2.age = 24;
     stu2.sex = "女";
     stu2.read();
 }
}
```



> 栈内存:执行方法
>
> 堆内存:保存对象
>
> 方法区:保存类编译后产生的自解码文件

> ![image-20220302054238658](https://i0.hdslb.com/bfs/album/01fae40ddbd6cd5988a65789ce8b63fd8cd0000e.png)
>
> - 方法区编译StudentDemo01
> - 运行主程序main()
> - main方法首先会加载到栈内存中
> - 方法区加载student.class
> - Student stu= 会在栈内存中产生学生类对象
> - new Student() 会对应的堆中会创建出学生对象
> - 堆中加载成员变量 #1.成员方法不会进入到堆内存中的对象空间 2.成员变量会有默认初始化值，Java 没有内置的字符串类型，只提供一个类string来操作字符串，所以string是引用类型
> - 但堆中会有成员方法的引用：在方法区对应方法的内存地址
> - 堆中的学生对象会有自己独立的内存地址002，并赋值给栈中的stu，使stu完成访问
> - 栈中进行对象变量name的赋值，根据stu对象名的地址002 找内存空间，修改堆中的成员变量name的值
> - 栈中成员方法read()的调用，会进入栈中执行，read()执行完后，会立即在栈内存中消失，重新回到栈main()中。最后main()执行完后也会在栈内存中消失  
> - #：一个类可以创建多个对象，每个对象间都是相互独立，互不影响的





如何将上述学生类的对象stu2引用传递给新对象stu3？并解释为什么两个对象是一样的？



> ```java
> Student stu2 = stu3;
> ```

> 内存地址一样
>





- 访问控制又称为什么？

- 四种访问控制权限的特点分别是什么?



> 权限修饰符

> private：本类
>
> （default）：本包
>
> protected：不同包间的子类
>
> public：所有类





为什么要封装



> 防止本类的代码和数据被外界程序随意访问





添加下列代码，封装Stdent类的成员变量age，并为姓名创建一个间接访问和修改方法getAge和setAge。并在主程序实现修改和调用，确保年龄在0到120之间

```java
public class StudentDemo01 {
 public static void main(String[] args) {
     Student stu = new Student();
     stu.setAge(20);
     int age = stu.getAge();
     stu.print();
 }
}
```

```java
public class Student {
 private int age;

  
  
 public  void print(){
     String name;
     System.out.println(age);
 }

}
```



> ```java
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student stu = new Student();
>         stu.setAge(20);
>         int age = stu.getAge();
>         stu.print();
>     }
> }
> ```
>
> ```java
> public class Student {
>     private int age;
> 
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         if(age >= 0 && age <= 120) {
>             this.age = age;
>         }
>     }
> 
> 
>     public  void print(){
>         String name;
>         System.out.println(age);
>     }
> 
> }
> ```
>
> 





修添加下列代码，用快捷方法创建带name和age参数的构造方法。并在主程序完成调用

```java
package com.demo02;

public class StudentDemo01 {
    public static void main(String[] args) {
        Student stu = new Student(20, "张三");
        stu.setAge(20);
        int age = stu.getAge();
        stu.print();
    }
}

```

```java
package com.demo02;

public class Student {
    private int age;
    private  String name;



    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if(age >= 0 && age <= 120) {
            this.age = age;
        }
    }


    public  void print(){
        String name;
        System.out.println(age);
    }

}

```





> ```java
> package com.demo02;
> 
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student stu = new Student(20, "张三");
>         stu.setAge(20);
>         int age = stu.getAge();
>         stu.print();
>     }
> }
> ```
>
> ```java
> package com.demo02;
> 
> public class Student {
>     private int age;
>     private  String name;
> 
>     public Student(int age, String name) {
>         this.age = age;
>         this.name = name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         if(age >= 0 && age <= 120) {
>             this.age = age;
>         }
>     }
> 
> 
>     public  void print(){
>         String name;
>         System.out.println(age);
>     }
> 
> }
> 
> 
> ```
>





添加下列代码，重载一个一个无参构造方法和一个只有name参数的构造方法和，再重新调用。

```java
package com.demo02;

public class StudentDemo01 {
    public static void main(String[] args) {
        Student stu = new Student("张三",20);
        stu.setAge(20);
        int age = stu.getAge();
        stu.print();

        Student stu1 = new Student();
        stu1.print();
        Student stu2 = new Student("李四");
        stu2.print();
    }
}
```

```java
package com.demo02;

public class Student {
    private int age;
    private  String name;


    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        if(age >= 0 && age <= 120) {
            this.age = age;
        }
    }


    public  void print(){
        System.out.println(age);
    }

}

```



> ```java
> package com.demo02;
> 
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student stu = new Student("张三",20);
>         stu.setAge(20);
>         int age = stu.getAge();
>         stu.print();
> 
>         Student stu1 = new Student();
>         stu1.print();
>         Student stu2 = new Student("李四");
>         stu2.print();
>     }
> }
> ```
>
> ```java
> package com.demo02;
> 
> public class Student {
>     private int age;
>     private  String name;
> 
>     public  Student(){
> 
>     }
> 
>     public Student(String name){
>         this.name = name;
>     }
> 
>     public Student(String name,int age){
>         this.name = name;
>         this.age = age;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         if(age >= 0 && age <= 120) {
>             this.age = age;
>         }
>     }
> 
> 
>     public  void print(){
>         System.out.println(age);
>     }
> 
> }
> 
> 
> ```
>





查看下列代码，问this关键字的三个作用是什么？分别要注意什么？

```java
public Student(String name,int age){
    this.name = name;
}

public String getName() {
    //name = name;
    name = this.name;
}
```

```java
    public void method01() {
//        method01();
        this.method01();
    }
    
    public void method02() {
        System.out.println("method02");
    }
```

```java
public  Student(){
    System.out.println("空参构造方法执行了……");
}

public Student(String name,int age){
    this();
    this.name = name;
    //this(); //this调用其他构造方法，必须放在第一行有效代码上
}
```



> 1. 调用本类的成员变量
>    - 相同命名下，用来区分传参和成员变量
> 2. 调用本类的成员方法
>    - 调用本类中的其他成员变量，this可以忽略
> 3. 调用本类的构造方法
>    - 本类的空参构造方法调是：this()
>    - this调用构造方法，必须放在第一行有效代码上





查看下列四类代码块，“{}"四类代码块是什么？前三类的作用是什么？

```java
public class Student {

    {
        System.out.println("执行了");
    }
    
    
    public  Student(){
        System.out.println("空参构造方法执行了……");
    }
    
    }
```

```java
public class Student {

    static{
        System.out.println("执行了");
    }


    public  Student(){
        System.out.println("空参构造方法执行了……");
    }
  
}
```



> 普通：方法中
>
> - 限定变量的生命周期，当}执行完后，里面的变量也会消失，提高内存的利用率
>
> 构造：类中，方法外
>
> - 在构造方法之前执行
>
> 静态：同上，但{前加一个static
>
> - 当这个类一被加载到内存时，静态代码块就会执行，而且只会执行一次
>
> 同步：





构造方法有什么用



> 对类进行初始化



判断：被static修饰的属性，可以被该类的所有对象所共享使用，该属性可以直接使用类名进行调用，被称为静态属性



> 对





修改代码

- 使得对school赋值一次，就能将所有学校都设为 黑马程序员，

- 如果将方法show变为静态方法，并在主程序用Student.show()调用会报错，是为什么

```java
package com.demo02;

public class StudentDemo01 {
    public static void main(String[] args) {
        Student s1 = new Student("张三", 23, "黑马程序员");
        Student s2 = new Student("李四", 22, "黑马程序员");
        s1.show();
        Student.show()// 为何报错


    }
}
```

```java
package com.demo02;

public class Student {
    private String name;
    private int age;
    private String school;

    public Student() {
    }

    public Student(String name, int age, String school) {
        this.name = name;
        this.age = age;
        this.school = school;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public String getSchool() {
        return school;
    }

    public void setSchool(String school) {
        this.school = school;
    }

    public void show(){
        System.out.println(name + age + school);
    }




}
```



> ```java
> package com.demo02;
> 
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student.school = "黑马程序员";
> 
>         Student s1 = new Student("张三", 23);
>         Student s2 = new Student("李四", 23);
>         s1.show();
>         
>     }
> }
> 
> ```
>
> ```java
> package com.demo02;
> 
> public class Student {
>     private String name;
>     private int age;
>     static String school;
> 
>     public Student() {
>     }
> 
>     public Student(String name, int age) {
>         this.name = name;
>         this.age = age;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         this.age = age;
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public String getSchool() {
>         return school;
>     }
> 
>     public void setSchool(String school) {
>         this.school = school;
>     }
> 
>     public  void show(){
>         System.out.println(name + age + school);
>     }
> }
> ```
>
> 

> 静态方法只能访问静态方法和静态变量





修改代码

- 将Student类的成员变量name和普通方法print方法分别设置为静态变量和方法，
- 在print方法中创建name字符变量，完成对成员变量age的打印，并创建无返回值的show方法，完成print()的调用

- 并说明非静态和静态的区别

  ```java
  package com.demo02;
  
  public class StudentDemo01 {
   public static void main(String[] args) {
       Student.age = 100;
  
       Student stu = new Student("张三",20);
       stu.setAge(20);
       int age = stu.getAge();
       Student.print();
       stu.show();
  
       Student stu1 = new Student();
       stu1.print();
       Student stu2 = new Student("李四");
       stu2.print();
   }
  }
  
  ```

  ```java
  package com.demo02;
  
  public class Student {
   static int age;
   private String name;
  
   public  Student(){
  
   }
  
   public Student(String name){
       this.name = name;
   }
  
   public Student(String name,int age){
       this.name = name;
       this.age = age;
   }
  
   public int getAge() {
       return age; 
   }
  
   public void setAge(int age) {
       if(age >= 0 && age <= 120) {
           this.age = age;
       }
   }
  }
  ```

  

 

> ```java
> package com.demo02;
> 
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student.age = 100;
> 
>         Student stu = new Student("张三",20);
>         stu.setAge(20);
>         int age = stu.getAge();
>         Student.print();
>         stu.show();
> 
>         Student stu1 = new Student();
>         stu1.print();
>         Student stu2 = new Student("李四");
>         stu2.print();
>     }
> }
> 
> 
> ```
>
> ```java
> package com.demo02;
> 
> public class Student {·
>     static int age;
>     private String name;
> 
>     public  Student(){
> 
>     }
> 
>     public Student(String name){
>         this.name = name;
>     }
> 
>     public Student(String name,int age){
>         this.name = name;
>         this.age = age;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         if(age >= 0 && age <= 120) {
>             this.age = age;
>         }
>     }
> 
>     public static void print(){
>         String name;
>         System.out.println(Student.age);
>     }
> 
>     public void show(){
>         print();
>     }
> 
> 
> }
> ```

> 非静态是创造对象后存在的
> 静态是随着类加载存在的





为下面的Test设计一个Voter类，实现下面学生投票系统
![image-20220308163025157](https://i0.hdslb.com/bfs/album/6d1d3fe71d20f2b2998a26e8a837c582521999fd.png)

![image-20220406083131003](https://i0.hdslb.com/bfs/album/9a0e0073cbd560d18bde7ba457fb580a802a418e.png)

![image-20220406083141924](https://i0.hdslb.com/bfs/album/9269efaf6d1d0499892d502e9a294b3807f286f8.png)

```java
package com.demo02;

public class Test {
 public static void main(String[] args) {
     Voter v1 = new Voter("tom");
     Voter v2 = new Voter("jack");
     Voter v3 = new Voter("mike");

     v1.voterFor("是");
     v1.voterFor("否");
     v2.voterFor("是");
     v3.voterFor("否");

     v1.printResult();
     v2.printResult();
     v3.printResult();
 }
}
```



> ```java
> package com.demo02;
> 
> import java.util.HashSet;
>    
>    public class Voter {
>        public static final int MAX_COUNT = 100;
>        public static int count;
>     public static HashSet<Voter> voters = new HashSet<>();
>        public String name;
>        public String answer;
>    
>        public Voter(String name) {
>         this.name = name;
>        }
>    
>        public void voterFor(String answer){
>            if(count == MAX_COUNT){
>             System.out.println("投票数量已达上线");
>             return;
>         }
>
>         if(voters.contains(this)){
>             System.out.println(name+"请勿重复投票");
>         }else{
>             this.answer = answer;
>             count++;
>             voters.add(this);
>                System.out.println(name + "感谢您的投票");
>            }
>        }
>        public void printResult(){
>            System.out.println("参与投票的数量"+count+"个");
>         System.out.println("参与投票的结果如下：");
>            for (Voter voter : voters) {
>                System.out.println(voter.name + " 意见 " + voter.answer);
>            }
>     }
>    }
> 
>    ```







Dog类如何继承父类Animal

```java
public class Dog 
```



> ```java
> public class Dog extends Animal{}
> ```
>
> 



查看下列代码，继承与继承间要哪两个特点

```java
class A{}
class B{}
class C extends A,B{}// 不可以
```

```java
class A{}
class B extends A{}
class C extends A{}// 可以
```



> 1. java只支持单继承
> 2. 但可以多层继承





cat子类重写下面父类animal的eat方法，用注解检测是否是正确的重写格式

```java
package com.demo02;

import com.demo01.Animal;

public class Cat extends Animal {
    public void eat(){
        System.out.println("猫吃鱼……");
    }
}

```

```java
package com.demo01;

public class Animal {
    public void eat(){
        System.out.println("动物吃饭");
    }
}
```



> ```java
> package com.demo02;
> 
> import com.demo01.Animal;
> 
> public class Cat extends Animal {
>     @Override
>     public void eat(){
>         System.out.println("猫吃鱼……");
>     }
> }
> 
> 
> ```
>
> 





下列程序报错，子类重写父类方法时权限修饰符要注意哪一点

```java
package com.demo02;

import com.demo01.Animal;

public class Cat extends Animal {
    public void eat(){
        System.out.println("猫吃鱼……");
    }
}

```

```java
package com.demo01;

public class Animal {
   	void eat(){
        System.out.println("动物吃饭");
    }
}
```

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.eat();
    }
}
```



> 大于等于父类方法的权限修饰符





判断：super关键词用来解决，子类重写方法后，无法访问父类被重写的方法，除了方法，还有普通属性和构造方法



> 对





下列代码那里有错误
- Animal中构造方法的super()访问的是谁

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {
        Cat cat = new Cat("折耳猫",20,"红");
        System.out.println(cat.getName() + "," + cat.getAge() + "," + cat.color);

    }
}
```

```java
package com.demo02;

public class Cat extends Animal{
    public String color;

    public  Cat(){
        this("aaa",10,"红");//访问子类带有参数的构造方法
        super();//访问父类空参数构造方法，系统默认编写

    }

    public  Cat(String name, int age, String color){
        //将接受到的参数传给父类的有参构造方法传递
        super(name,age);
        this.color = color;

    }
}
```

```java
package com.demo02;

public class Animal {
    private String name;
    private int age;
  
    public Animal(){
      	super()
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    public  Animal(){
    }

    public  Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }


}
```



> this 和 super 不能同时访问构造方法

> Object类
>





查看下列代码，final关键字在修饰类、方法、变量、引用数据类型时分别有什么用？

```java
package com.demo02;

public class TestFinal {
    public static void main(String[] args) {
        Zi zi = new Zi();
        zi.show();
//自定义常量：单词全部大写，如果多个单词，单词之间使用下划线分割
        final int NUM = 10;
//        NUM = 20;

        // 变量变成常量、其值不能发生改变
        final Fu f = new Fu(); //001
        f.setName("张三");
        f.setName("李四");

        //final 修饰引用类型变量，指的是内存地址不能发生改变，但内部属性值可以改变
        f = new Fu(); //002 创建失败


    }
}

class Fu{
    private String name;

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public final void show(){
        System.out.println("fu……show……");
    }

}

// 类不能被继承，但自身可以继承
/*final class Fu extends Object{

}*/

class Zi extends Fu{
    //方法不能被重写，但方法可以被继承下来使用
    public void  show(){

    }

}
```



> 类不能被继承
>
> 方法不能被重写，但方法可以被继承下来使用
>
> 变量变成常量、其值不能发生改变
>
> 内存地址不能发生改变，但内部属性值可以改变





将下面的自定义常量用来自定义常量命名规则来命名

```java
final int num_tree = 10;
```



> final int NUM_ TREE= 10;





将下列代码中Animal类eat方法变成抽象方法，并在类中用快捷方法创建eat方法并打印？

```java
package com.demo02;


public class Animal {
    public void eat() {
        System.out.println("动物吃肉");
    }
}
```

```java
package com.demo02;

public class Cat extends Animal{

}
```

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {
        Cat cat = new Cat();
        cat.eat();
    }
}
```



> ```java
> package com.demo01;
> 
> public abstract class Animal {
>     public abstract void eat();
>     
> }
> ```
>
> ```java
> package com.demo01;
> 
> public class Dog extends Animal{
> 
>     @Override
>     public void eat() {
>         System.out.println("狗吃肉");
>     }
> }
> }
> ```
>
> ```java
> package com.demo02;
> 
> public class Test {
>     public static void main(String[] args) {
>         Cat cat = new Cat();
>         cat.eat();
>     }
> }
> ```





判断：abstract不能被private修饰



> 对





JDK8之前，什么时候会用到接口



> 类中只有抽象方法和全局变量





判断：接口不能包含普通方法和构造方法



> 对





判断：JDK8的接口还可以包含默认方法和静态方法



> 对





创建接口的关键词是什么



> interface





判断：类与类之间是单继承，而接口与接口间允许多继承



> 对





添加下列代码创建接口InterA

- 常量NUM
- 抽象方法method
- 静态方法show，打印，无返回值
- 默认方法fun，打印，无返回值

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {

    }
}
```



> ```java
> package com.demo02;
> 
> public class Test {
>     public static void main(String[] args) {
> 
>     }
> }
> 
> interface InterA{
>     public static final int NUM = 10;
> 
>     public abstract void method();
> 
>     public static void show(){
>         System.out.println(1);
>     }
> 
>     public default void fun(){
>         System.out.println(2);
>     }
> }
> ```





创建实现类InterImpl，实现下面InterA接口

- 创建实现类对象ii
- 调用默认方法fun和show
- 用两种方式打印NUM

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {

    }
}

interface InterA{
    public static final int NUM = 10;

    public abstract void method();

    public static void show(){
        System.out.println("静态");
    }

    public default void fun(){
        System.out.println("默认");
    }
}
```



> ```java
> package com.demo02;
> 
> public class Test {
>     public static void main(String[] args) {
>         InterImpl ii = new InterImpl();
>         ii.fun();
>         InterA.show();
>         System.out.println(ii.NUM);
>         System.out.println(InterA.NUM);
> 
>     }
> }
> 
> interface InterA{
>     public static final int NUM = 10;
> 
>     public abstract void method();
> 
>     public static void show(){
>         System.out.println("静态");
>     }
> 
>     public default void fun(){
>         System.out.println("默认");
>     }
> }
> 
> class InterImpl implements InterA{
> 
>     @Override
>     public void method() {
>         System.out.println("重写后的method");
>     }
> }
> ```







判断

- 实现类必须继承在前，实现在后，实现可以实现多个接口
- 接口与接口之间是继承关系

```java
interface InterB extends InterA{
    
}

class InterImpl extends Object implements InterA, InterB{

    @Override
    public void method() {
        System.out.println("重写后的method");
    }
}
```



> 对





写出下列代码的运行结果

```java
package com.demo02;


public class Test implements Face{
    private static int counter;
    public static void main(String[]args){
        System.out.println(++counter);
    }
}

interface Face{
    int counter = 40;
}
```



> 1 





### 多态

判断：多态是指事物的不同形态，使用它必须满足3点

- 有继承或实现关系
- 有方法重写
- 必须有父类引用指向子类对象

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {
        //父类引用指向子类对象
        Animal a = new Dog();
        a.shout();
    }
}

abstract class Animal{
    public abstract void shout();
}

//继承
//重写
class Dog extends Animal{
    @Override
    public void shout() {
        System.out.println("汪汪叫...");
    }
}

class Cat extends Animal{
    @Override
    public void shout() {
        System.out.println("喵喵叫...");
    }
}
```



> 对





修改代码，用多态的概念编写一个通用方法，可以接受Animal任意的子类对象来使用shout方法

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
        useDog(d);

        Cat c = new Cat();
        useCat(c);
    }

    public static void useDog(Dog dog){
        dog.shout();
    }

    public static void useCat(Cat cat){
        cat.shout();
    }
}

abstract class Animal{
    public abstract void shout();
}

class Dog extends Animal{
    @Override
    public void shout() {
        System.out.println("汪汪叫...");
    }
}

class Cat extends Animal{
    @Override
    public void shout() {
        System.out.println("喵喵叫...");
    }
}
```



> ```java
> package com.demo02;
> 
> public class Test {
>     public static void main(String[] args) {
>         Dog d = new Dog();
>         useAnimal(d);
> 
>         Cat c = new Cat();
>         useAnimal(c);
>     }
> 
>     public static void useAnimal(Animal a){ // Animal a = new Dog()
>         a.shout();
>     }
> 
> 
> }
> 
> 
> 
> abstract class Animal{
>     public abstract void shout();
> }
> 
> class Dog extends Animal{
>     @Override
>     public void shout() {
>         System.out.println("汪汪叫...");
>     }
> }
> 
> class Cat extends Animal{
>     @Override
>     public void shout() {
>         System.out.println("喵喵叫...");
>     }
> }
> ```





判断：如果一个方法中使用父类或父接口作为形式参数，将来调用该方法时，可以传递任意的子类对象，即多态可以提高方法的灵活性



> 对





下列代码发生了向上转型还是向下转型

```java
public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
        useAnimal(d);

        Cat c = new Cat();
        useAnimal(c);
    }

    public static void useAnimal(Animal a){ // Animal a = new Dog()
        a.shout();
    }
```



> 向上





判断：多态无法使用子类的特有成员，如果想使用子类特有的成员，就需要向下转型



> 对





用来判断一个对象是否是某个类的关键词是什么



> instanceof





对下面报错的语句进行向下转型，并解决类型转换异常的报错

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {
        Dog d = new Dog();
        useAnimal(d);

        Cat c = new Cat();
        useAnimal(c);
    }

    public static void useAnimal(Animal a){ // Animal a = new Dog()
        a.shout();
        a.show(); // 报错
    }
}


abstract class Animal{
    public abstract void shout();
}

class Dog extends Animal{
    @Override
    public void shout() {
        System.out.println("汪汪叫...");
    }

    public void show(){
        System.out.println(" dog …… show ");
    }
}

class Cat extends Animal{
    @Override
    public void shout() {
        System.out.println("喵喵叫...");
    }
}
```



> ```java
> package com.demo02;
> 
> public class Test {
>     public static void main(String[] args) {
>         Dog d = new Dog();
>         useAnimal(d);
> 
>         Cat c = new Cat();
>         useAnimal(c);
>     }
> 
>     public static void useAnimal(Animal a){ // Animal a = new Dog()
>         a.shout();
> 
>         if(a instanceof Dog){
>             Dog dog = (Dog)a;
>             dog.show();
>         }
> 
>     }
> }
> 
> 
> abstract class Animal{
>     public abstract void shout();
> }
> 
> class Dog extends Animal{
>     @Override
>     public void shout() {
>         System.out.println("汪汪叫...");
>     }
> 
>     public void show(){
>         System.out.println(" dog …… show ");
>     }
> }
> 
> class Cat extends Animal{
>     @Override
>     public void shout() {
>         System.out.println("喵喵叫...");
>     }
> }
> ```





判断：Object类被称为超类，它是所有类的父类



> 对





Object类提供了三个常用的方法，根据使用效果写出方法名

- 打印对象的内存地址
- 比较两个对象的内存地址是否相等
- 打印对象内存的哈希码值




> toString
>
> equals
>
> hashCode





查看下列学生类，用idea快捷方式重写上面的三个个方法，使其完成以下效果

- toString():打印对象的属性值
- equals():比较两个对象是否相等
- hashCode():打印对象哈希码值

```java
package com.dem02;

public class StudentDemo01{
    public static void main(String[] args) {
        Student s1 = new Student("张三",23);
        Student s2 = new Student("张三",23);
      
      //完善代码

        System.out.println(s1.toString());
        System.out.println(s1.equals(s2));
        System.out.println(s1.hashCode());

    }
}
```

```java
package com.dem02;

public class Student {
    static int age;
    private String name;

    public  Student(){
    }

    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;

    }
}
```





> ```java
> package com.dem02;
> 
> public class StudentDemo01{
>     public static void main(String[] args) {
>         Student s1 = new Student("张三",23);
>         Student s2 = new Student("张三",23);
>       
>       //完善代码
> 
>         System.out.println(s1.toString());
>         System.out.println(s1.equals(s2));
>         System.out.println(s1.hashCode());
> 
>     }
> }
> ```
>
> 





### 内部类

判断：内部类分为成员内部类、局部内部类(方法内部类）、静态内部类、匿名内部类



> 对





判断：内部类可以访问外部类的私有变量和方法



> 对





查看下列代码，如何在主程序中调用run方法

```java
package com.dem02;

public class Outer {
    String brand = "奔驰";
  
    class Engine{
        public void run(){
            System.out.println(brand + "发动机启动了");
        }
    }
}
```

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {
        
        
    }
}
```



> ```java
> package com.demo02;
> 
> public class Test {
>     public static void main(String[] args) {
>         Car.Engine ce = new Car().new Engine();
>         ce.run();
>         
>     }
> }
> 
> ```
>
> 





局部内部类只能在当前类下创建局部内部类对象，查看下列代码，在主程序中调用show方法

```java
package com.dem02;

public class Outer {
    int num = 10;

    public void method(){

            class Inner{
                public void show(){
                    System.out.println("外部类中的num:" + num);
                }
            }
      
      //创建局部内部类对象
            Inner i = new Inner();
            i.show();
        }
        
    }

```

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {
        
        
    }
}
```



> ```java
> package com.demo02;
> 
> public class Test {
>     public static void main(String[] args) {
>         Outer o = new Outer();
>         o.method();
>     }
> }
> ```
>
> 





判断：静态的成员只能访问静态内容



> 对





查看下列代码

- 在主程序中调用静态内部类的show方法，

- 并用两种方法调用静态方法method

```java
package com.demo02;

public class Outer {
    static int num = 10;

    static class Inner{
        public void show(){
            System.out.println(num); //静态的成员只能访问静态内容
        }

        public static void method(){
            System.out.println("method方法执行了");
        }
    }
}


```

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {

    }
}
```



> ```java
> package com.demo02;
> 
> public class Test {
>     public static void main(String[] args) {
>         Outer.Inner oi = new Outer.Inner();
>         oi.show();
>         oi.show();
> 
>         Outer.Inner.method();
>         
>     }
> }
> ```





下面代码的实现方式如下：

1. 编写实现类(接口)
2. 重写抽象方法
3. 创建实现类对象
4. 将实现类对象作为方法的参数传递

用匿名内部类将前三步化成一步使其能实现下列代码的效果

```java
package com.demo02;

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        useAnimal(dog);

    } 

    public static void useAnimal(Animal a){
        a.eat();
    }
}

```

```java
package com.demo02;

public class Dog implements Animal{

    @Override
    public void eat() {
        System.out.println("狗吃肉。。。");
    }
}

```

```java
package com.demo2;

public interface Animal {
    public abstract void eat();
};

```



> ```java
> package com.demo02;
> 
> public class Test {
>     public static void main(String[] args) {
>         /*Dog dog = new Dog();
>         useAnimal(dog);*/
>         
>         useAnimal(new Animal() {
>             @Override
>             public void eat() {
>                 System.out.println("狗吃肉");
>             }
>         });
> 
>     }
> 
>     public static void useAnimal(Animal a){
>         a.eat();
>     }
> }
> 
> 
> ```
>
> ```java
> package com.demo2;
> 
> public interface Animal {
>     public abstract void eat();
> };
> 
> 
> ```
>
> 





### 异常

Java中大量的异常类都继承自一个类,如何导入这个类？



> java.lang.Throwable





查看Throwable类的继承体系



> ![image-20220314231137988](https://i0.hdslb.com/bfs/album/8cee43a99f5d4c3c987737b1f9400dc7c8c74a7b.png)





当下面代码的某段程序出现异常时，是否继续执行下面的代码

```java
package com.demo02;

public class ExceptionDemo01 {
    public static void main(String[] args) {
        int result = divide(6,0);
        System.out.println(result);
        System.out.println("看看我执行了吗？");
    }
    
    
    
    public static int divide(int x, int y){
        int result = x/y;
        return result;
    }
}
```



> 否





捕获异常的关键词是哪两个？



> try
>
> catch





补充下面代码，捕获算术异常，并提示“不能除0”，使可以程序继续运行。

```java
package com.demo02;

public class ExceptionDemo01 {
    public static void main(String[] args) {
        int result = divide(6,0); // new ArithmeticException
        System.out.println(result); 
        System.out.println("看看我执行了吗？");
    }
    
    
    
    public static int divide(int x, int y){
        int result = x/y;
        return result;
    }
}
```



> ```java
> package com.demo02;
> 
> public class ExceptionDemo01 {
>     public static void main(String[] args) {
> 
>         try {
>             int result = divide(6,0);
>             System.out.println(result);
>         }catch (ArithmeticException e){
>             System.out.println("不能除0");
> 
>         }
> 
>         System.out.println("看看我执行了吗？");
>     }
> 
> 
> 
>     public static int divide(int x, int y){
>         int result = x/y;
>         return result;
>     }
> }
> ```





Throwable类的三个常见方法效果如下，它们的方法名是什么？

- 返回异常的消息字符串
- 返回异常的简单信息描述
- 获取异常类名和异常信息，以及异常出现在程序中的位置，把信息输出到控制台

```java
package com.demo02;

public class ExceptionDemo01 {
    public static void main(String[] args) {

        try {
            int result = divide(6,0);
            System.out.println(result);
        }catch (ArithmeticException e){
            System.out.println("不能除0");

            //获取到异常的简单消息
//            System.out.println(e.getMessage());

            //获取到异常到类型和消息
//            System.out.println(e.toString());

            //一般用这个，还能显示错误位置
            e.printStackTrace();

        }

        System.out.println("看看我执行了吗？");
    }



    public static int divide(int x, int y){
        int result = x/y;
        return result;
    }
}
```





下面添加到代码实现了无论是否出现异常，代码都会执行

- 无论是否出现异常，代码都会执行的关键词是什么
- 如何让其不执行
- 修改代码让其不执行

```java
package com.demo02;

public class ExceptionDemo01 {
    public static void main(String[] args) {

        try {
            int result = divide(6,3);
            System.out.println(result);
          
          //正常结束java虚拟机
          
        }catch (ArithmeticException e){
            System.out.println("不能除0");

            //获取到异常的简单消息
//            System.out.println(e.getMessage());

            //获取到异常到类型和消息
//            System.out.println(e.toString());

            //一般用这个，还能显示错误位置
            e.printStackTrace();

        }finally {
            System.out.println("我是finally代码块中的内容");
        }

        System.out.println("看看我执行了吗？");
    }



    public static int divide(int x, int y){
        int result = x/y;
        return result;
    }
}
```



> finally 

> 结束JVM

> ```java
> package com.demo02;
> 
> public class ExceptionDemo01 {
>     public static void main(String[] args) {
> 
>         try {
>             int result = divide(6,3);
>             System.out.println(result);
> 
>             //正常结束java虚拟机
>             System.exit(0);
> 
> 
>         }catch (ArithmeticException e){
>             System.out.println("不能除0");
> 
>             //获取到异常的简单消息
> //            System.out.println(e.getMessage());
> 
>             //获取到异常到类型和 消息
> //            System.out.println(e.toString());
> 
>             //一般用这个，还能显示错误位置
>             e.printStackTrace();
> 
>         }finally {
>             System.out.println("我是finally代码块中的内容");
>         }
> 
>         System.out.println("看看我执行了吗？");
>     }
> 
> 
> 
>     public static int divide(int x, int y){
>         int result = x/y;
>         return result;
>     }
> }
> ```





ArithmeticException的父类运行时异常(uncheck异常）关键词是什么，运行时异常的父类编译时异常(check异常）又叫什么？



>RuntimeException ； Exception





 抛出异常的关键字是什么



> throws





修改下列代码

- 使得在运行程序前，告知方法的调用者可能出现的异常

- 用idea快捷键处理异常(divide设为0)



```java
package com.demo02;

public class ExceptionDemo01 {
    public static void main(String[] args) {
        int result = divide(6,3);
        System.out.println(result);
        System.out.println("看看我执行了吗？");
    }
    public static int divide(int x, int y) throws RuntimeException{
        int result = x/y;
        return result;
    }
}
```



> ```java
> package com.demo02;
> 
> public class ExceptionDemo01 {
>     public static void main(String[] args) {
>         int result = divide(6,3);
>         System.out.println(result);
>         System.out.println("看看我执行了吗？");
>     }
>     public static int divide(int x, int y) throws RuntimeException{
>         int result = x/y;
>         return result;
>     }
> }
> ```

> ```java
> package com.demo02;
> 
> public class ExceptionDemo01 {
>     public static void main(String[] args) {
>         int result = 0;
>         try {
>             result = divide(6,0);
>         } catch (Exception e) {
>             e.printStackTrace();
>         }
>         System.out.println(result);
>         System.out.println("看看我执行了吗？");
>     }
>     public static int divide(int x, int y) throws Exception{
>         int result = x/y;
>         return result;
>     }
> }
> ```





Exception类中，除了哪个类及其子类，Exception的其他子类都叫编译时异常



> RuntimeException





所有运行时异常的父类时那个类？



> RuntimeException





下面的索引越界异常，属于运行时异常，还是编译时异常

```java
int[] arr = new int[5];
System.out.println(arr[6]);
```



> 运行时异常





为下面代码自定义异常

- 在编译时，当y为0时，抛出一个定义DivideException异常类的对象，异常信息为“不能除0”。
- 修改代码，使得在运行时抛出异常 

```java
package com.dem03;

public class ExceptionDemo01 {
    public static void main(String[] args) {
        int result = divide(6,0);
        System.out.println(result);
        System.out.println("看看我执行了吗？");
    }
    public static int divide(int x, int y){
        int result = x/y;
        return result;
    }
}
```



> ```java
> 
> ```
>
> ```java
> 
> ```
>
> 

> ```java
> 
> ```
>
> ```java
> 
> ```
>
> 





案例：打印一个边长为5的正方形和半径为5的圆

- 创建父类yPrint类，包含show0）方法，用于输出图形的形状
- 创建子类MyPrintSquare类，重写show 0方法，用“*”打印出边长为5的正方形。*
- 创建子类MyPrintCircle类，重写show O方法，用“*”打印出半径为5的圆。
- 创建测试类，设计一个myshow（MyPrint a）方法，实现输出的功能：如果为MyPrintSquare，输出边长为5的正方形，如果为MyPrintCircle对象，输出半径为5的圆；主函数中创建
  MyPrintSquare、MyPrintCircle的对象，分别调用myshow，检查输出结果。



> ```java
> 
> ```
>
> ```java
> 
> ```
>
> ```java
> 
> ```
>
> ```java
> 
> ```
>
> 





案例：用抽象类的知识设计一个程序，可以根据输入计算不同图形的面积和周长。

- shape父类：获取getArea和getPerimeter两个抽象方法
- Cricle子类：用于计算圆的周长和面积
- Rectangle子类：计算矩形的周长和面积
- shaprCaulate类：用于打印周长或面积
- Test类：实现主程序的调用



> ```java
> 
> ```
>
> ```java
> 
> ```
>
> ```java
> 
> ```
>
> ```java
> 
> ```
>
> ```java
> 
> ```
>
> 





案例：设计一个研究生薪资管理系统

（l）定义两个接口，在StudentManageInterface接口中声明两个方法：getFee()和setFee()，用于设置和获取学生的学费；在TeacherManageInterface接口中声明两个方法：gePay（）和setPay()，用于设置和获取教师的工资。
（2）定义主类Graduate，分别实现StudentManageInterface和TeacherManageInterface接口。
（3）定义Graduate类的成员变量，和构造方法。
（4）给出四个接口方法的实现。
（5）给出一个计算是否需要贷款的方法，在里面统计年收入和学费，并输出是否需要贷款的信息。
（6）在main0方法中创建一个姓名为“zhangsan”的研究生，调用计算是否需要贷款的方法。



> ```java
> 
> ```
>
> ```java
> 
> ```
>
> ```java
> 
> ```
>
> ```java
> 
> 
> ```
>
> 



















## 集合

> 查看demo08包

写出导入所有集合包的代码

> java.util.*



查看下列集合类的继承关系，

- 所有单列集合的父类是谁

- 说明List和Set的区别
- Map接口的主要实现类是哪两个

![image-20220324001435270](https://i0.hdslb.com/bfs/album/fd9b5f3486242997666ec2d74f618f110e968153.png)



> Collection

> List元素有序、可重复。Set元素无序、不可重复

> HashMap，TreeMap





### 单列



Collection是单列集合类的根接口，List和Set是是它的两个子接口。

List下面主要有ArrayList和LinkedList两个实现类

接口不能创建对象，但能创建实现类对象



集合中通过什么来约束集合存储数据的类型

> 泛型



创建一个Collection接口的ArrayList实现类的对象c1，范型为String

```java
package com.demo07;
import java.util.*

public class StringDemo01 {
    public static void main(String[] args) {
      
    }
}
```

> ```java
> package com.demo08;
> 
> import java.util.ArrayList;
> import java.util.Collection;
> 
> public class StringDemo01 {
>     public static void main(String[] args) {
>         Collection<String> c1 = new ArrayList<>();
> 
>     }
> }
> 
> ```
>
> 



查看下列 collection类 的常用方法，并根据方法效果写出方法名

```java
package com.demo07;


import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Scanner;

public class StringDemo01 {
    public static void main(String[] args) {
        //添加元素
        Collection<String> c1 = new ArrayList<>();//String 泛型：约束集合可以存储数据的类型
        c1.add("aa");
        c1.add("bb");
        c1.add("cc");
        System.out.println(c1);

        //将指定集合中所有元素添加到当前集合
        Collection<String> c2 = new ArrayList<>();
        c2.add("dd");
        c2.add("ee");
        c1.addAll(c2);
        System.out.println(c1);

        //删除指定的元素
        System.out.println(c1.remove("aa"));
        System.out.println(c1);

        //删除全部元素
        System.out.println(c1.removeAll(c2));
        System.out.println(c1);

        //判断元素是否为空
        System.out.println(c1.isEmpty()); //False

        //判断集合是否包含指定的元素
        System.out.println(c1.contains("cc")); //True

        //判断集合中是否包含指定集合所有元素
        System.out.println(c1.containsAll(c2));

        //获取集合的长度
        System.out.println(c1.size());

        //清空集合
        c1.clear();
        System.out.println(c1);

    }
}
```

<img src="https://i0.hdslb.com/bfs/album/7224b5d0ee20f3722640e4fc486e35d3ea3df36b.png" alt="image-20220423154141123" style="zoom:50%;" />

> add
>
> addAll
>
> remove
>
> removeAll
>
> clear
>
> contains
>
> containsAll
>
> isEmpty
>
> size
>
> 



List是Collection集合的子接口，继承了Collection的全部方法

List特有的方法是根据元素索引进行操作



查看,并根据方法效果写出方法名

```java
package com.demo08;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class StringDemo02{
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("bb");
        list.add("cc");

        //向索引0位置添加元素"aa" 索引不可越界>1
        list.add(0,"aa");
        System.out.println(list);

        //将指定集合list2的元素添加到当前集合指定索引0位置
        List<String> list2 = new ArrayList<>();
        list2.add("dd");
        list2.add("ee");
        list.addAll(0,list2);
        System.out.println(list);

        //获取指定索引处的元素
        System.out.println(list.get(0));

        //删除指定索引处的元素，返回被删除的元素
        System.out.println(list.remove(0));
        System.out.println(list);

        //修改指定索引处的元素，返回被修改的元素
        System.out.println(list.set(0,"qq"));
        System.out.println(list);

        //查询指定元素第一次出现的索引位置
        System.out.println(list.indexOf("qq"));

        //查询指定元素最后一次出现的索引位置
        list.add("qq");
        System.out.println(list.lastIndexOf("qq"));

        //获取指定索引范围(前开后闭）（开始索引，结束索引+1(不包含+1）的集合元素，返回新的集合
        System.out.println(list);
        List<String> newList = list.subList(1, 3);
        System.out.println(newList);

    }

}
```

<img src="https://i0.hdslb.com/bfs/album/c8344194ba220a31dadafc0790630b1b7a9d6cb2.png" alt="image-20220424222031112" style="zoom:50%;" />

> add
>
> addAll
>
> remove
>
> set
>
> get
>
> subList
>
> indexOf
>
> lastIndexOf
>
> 



subList是左开右闭的



ArrayList是通过创建什么来保存数组

> 数组



ArrayList适用于经常大量的数据做查询的操作，数据看作一个长度可变的有索引的数组



ArrayList是List接口的一个实现类，具有List可重复和存储有序的特点，运行下列代码自行体会

```java
package com.demo08;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/*
ArrayList特点：
    底层是数组结构实现的，数组有索引、查询速度比较快，增删比较慢。
    使用场景：如果大量的数据经常做查询的操作、优先使用ArrayList
*/


public class StringDemo02{
    public static void main(String[] args) {
        ArrayList<String>list = new ArrayList<>();

        //可以存储重复数据
        list.add("张三");
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");

        //存取有序
        System.out.println(list);

        int size = list.size();
        System.out.println(size);

        String name = list.get(2);
        System.out.println(name);


    }

}
```



LinkedList是链表结构，具有数据的增删的优势，但不再具有查询的优势。这个链表结构是双向循环列表，元素1会记录元素2的内存地址，在增删时会改变元素引用间的内存的地址就行。

<img src="https://i0.hdslb.com/bfs/album/d4b55a595c178c60c85efb645d6c36113da4a298.png" alt="image-20220424223518755" style="zoom:50%;" />







查看下列LinkList的特有方法，并根据方法效果写出方法名

```java
package com.demo08;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

public class StringDemo02{
    public static void main(String[] args) {

        LinkedList<String> list = new LinkedList<>();

        list.add("张三");
        list.add("李四");
        list.add("王五");

        list.addFirst("赵六");
        System.out.println(list);

        list.addLast("周七");
        System.out.println(list);

        String first = list.getFirst();
        System.out.println(first);

        String last = list.getLast();
        System.out.println(last);

        System.out.println(list.removeFirst());
        System.out.println(list.removeLast());
        System.out.println(list);

    }

}
```

<img src="https://i0.hdslb.com/bfs/album/7d7a9edcf79d28d797d1612cbbbf4fca7f894225.png" alt="image-20220424224543234" style="zoom:50%;" />

> addFirst
>
> addLast
>
> removeFirst
>
> removeLast
>
> getFirst
>
> getLast



set集合没有索引，如何实现遍历，它的中文是什么

> Iterator接口
>
> 迭代器



根据下列效果写出迭代器成员方法名

- 判断是否还有元素的关键词是什么
- 获取当前元素
- 删除当前元素

> hasNext
>
> next
>
> remove



用迭代器的方法遍历下面的集合

```java
package com.demo08;

import java.util.ArrayList;

public class IteratorDemo05 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        
        //用常规方法遍历方式


    }

}
```

> ```java
> package com.demo08;
> 
> import java.util.ArrayList;
> 
> public class IteratorDemo05 {
>     public static void main(String[] args) {
>         ArrayList<String> list = new ArrayList<>();
>         list.add("张三");
>         list.add("李四");
>         list.add("王五");
> 
>         //用常规方法遍历方式
>         for (int i = 0; i < list.size(); i++) {
>             String s = list.get(i);
>             System.out.println(s);
>         }
> 
>     }
> 
> }
> ```



用迭代器的方法遍历下面的集合

```java
package com.demo08;

import java.util.ArrayList;

public class IteratorDemo05 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        
        //用迭代器通用遍历方式



    }

}
```

> ```java
> package com.demo08;
> 
> import java.util.ArrayList;
> import java.util.Iterator;
> 
> public class IteratorDemo05 {
>  public static void main(String[] args) {
>      ArrayList<String> list = new ArrayList<>();
>      list.add("张三");
>      list.add("李四");
>      list.add("王五");
> 
>      //用迭代器通用遍历方式
>      Iterator<String> it = list.iterator();
>      while (it.hasNext()){
>          String str = it.next();
>          System.out.println(str);
>      }
> 
> 
>  }
> 
> }
> ```



下列代码报一个 ConcurrentModificationException 这是什么异常

```java
package com.demo08;

import java.util.ArrayList;
import java.util.Iterator;

public class IteratorDemo05 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("张三");
        list.add("李四");
        list.add("王五");

        //用迭代器通用遍历方式
        Iterator<String> it = list.iterator();
        while (it.hasNext()){
            String str = it.next();
            if("张三".equals(str)){
                list.remove(str);
            }
        }
        System.out.println(list);
    }

}
```

> 并发修改异常



迭代器遍历时，删除List的首个元素，迭代器对象所记录的数据与集合本身的数据会对应不上，如何解决这个问题

```java
package com.demo08;

import java.util.ArrayList;
import java.util.Iterator;

public class IteratorDemo05 {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("张三");
        list.add("李四");
        list.add("王五");

        //用迭代器通用遍历方式
        Iterator<String> it = list.iterator();
        while (it.hasNext()){
            String str = it.next();
            if("张三".equals(str)){
                list.remove(str);
            }
        }
        System.out.println(list);
    }

}
```

> ```java
> package com.demo08;
> 
> import java.util.ArrayList;
> import java.util.Iterator;
> 
> public class IteratorDemo05 {
>     public static void main(String[] args) {
>         ArrayList<String> list = new ArrayList<>();
>         list.add("张三");
>         list.add("李四");
>         list.add("王五");
> 
>         //用迭代器通用遍历方式
>         Iterator<String> it = list.iterator();
>         while (it.hasNext()){
>             String str = it.next();
>             if("张三".equals(str)){
> //                list.remove(str);
>                 it.remove();
>             }
>         }
>         System.out.println(list);
>     }
> 
> }
> ```



为了简化遍历集合元素的书写，JDK5中提供的增强for循环是什么

> foreach循环



用增强for循环 ，遍历下面的单列集合list 和 数组arr

```java
package com.demo08;

import java.util.ArrayList;

public class ForeachDemo {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        
        int[] arr = {10, 20, 30};
        
        
        
    }
}
```

> ```java
> package com.demo08;
> 
> import java.util.ArrayList;
> 
> public class ForeachDemo {
>     public static void main(String[] args) {
>         ArrayList<String> list = new ArrayList<>();
>         list.add("张三");
>         list.add("李四");
>         list.add("王五");
> 
>         int[] arr = {10, 20, 30};
> 
>         for (String str : list) {
>             System.out.println(str);
>         }
> 
>         for (int num : arr) {
>             System.out.println(num);
>         }
> 
> 
>  }
>    }
> ```







HashSet是以什么存储，TreeSet是以什么存储元素

> 哈希值、二叉树



查看下列代码的运行结果，可以知道HashSet集合的有哪三个特性

```java
package com.demo08;

import java.util.HashSet;

public class HashSetDemo01 {
    public static void main(String[] args) {
        HashSet<String> hs = new HashSet<>();
        hs.add("张三");
        hs.add("张三");
        hs.add("李四");
        hs.add("王五");
        hs.add("赵六");

        for (String s : hs) {
            System.out.println(s);
        }

    }
}
```

> 没有索引、不能存储重复元素、元素存储无序



计算哈希值的方法名是什么

> hashCode



如果是自定义类型的对象，保存到HashSet集合，必须重写hashCode()和equals()方法



添加代码，下面自定义类型的Student对象，用快捷方法使元素存储依旧保持唯一性

```java
package com.demo08;

import java.util.HashSet;

public class HashSetDemo02 {
  //注意，如果是自定义类型的对象，保存到HashSet集合，必须重写hashCode()和equals()方法
    public static void main(String[] args) {
        HashSet<Student> hs = new HashSet<>();
        Student s1 = new Student("张三",23);
        Student s2 = new Student("张三",23);
        Student s3 = new Student("李四",24);
        Student s4 = new Student("王五",25  );

        hs.add(s1);
        hs.add(s2);
        hs.add(s3);
        hs.add(s4);

        for (Student student : hs) {
            System.out.println(student);
        }

    }

} 
```

```java
package com.demo08;

public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



> ```java
> package com.demo08;
> 
> public class Student {
>     private String name;
>     private int age;
> 
>     public Student() {
>     }
> 
>     public Student(String name, int age) {
>         this.name = name;
>         this.age = age;
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         this.age = age;
>     }
> 
>     @Override
>     public boolean equals(Object o) {
>         if (this == o) return true;
>         if (o == null || getClass() != o.getClass()) return false;
> 
>         Student student = (Student) o;
> 
>         if (age != student.age) return false;
>         return name != null ? name.equals(student.name) : student.name == null;
>     }
> 
>     @Override
>     public int hashCode() {
>         int result = name != null ? name.hashCode() : 0;
>         result = 31 * result + age;
>         return result;
>     }
> 
>     @Override
>     public String toString() {
>         return "Student{" +
>                 "name='" + name + '\'' +
>                 ", age=" + age +
>                 '}';
>     }
> }
> 
> ```
>
> 



修改下列代码，用HashSet的子类保证元素读取有序

```java
package com.demo08;

import java.util.HashSet;

public class HashSetDemo02 {
  //注意，如果想要保证元素读取顺序，可以使用LinkedHashSet集合
    public static void main(String[] args) {
        HashSet<Student> hs = new HashSet<>();
        Student s1 = new Student("张三",23);
        Student s2 = new Student("张三",23);
        Student s3 = new Student("李四",24);
        Student s4 = new Student("王五",25  );

        hs.add(s4);
        hs.add(s2);
        hs.add(s3);
        hs.add(s1);

        for (Student student : hs) {
            System.out.println(student);
        }


    }

}
```

```java
package com.demo08;

public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



> ```java
> package com.demo08;
> 
> import java.util.HashSet;
> import java.util.LinkedHashMap;
> import java.util.LinkedHashSet;
> import java.util.LinkedList;
> 
> public class HashSetDemo02 {
>     public static void main(String[] args) {
> 
>         LinkedHashSet<Student> hs = new LinkedHashSet<>();
>         Student s1 = new Student("张三",23);
>         Student s2 = new Student("张三",23);
>         Student s3 = new Student("李四",24);
>         Student s4 = new Student("王五",25);
> 
>         hs.add(s4);
>         hs.add(s2);
>         hs.add(s3);
>         hs.add(s1);
> 
>         for (Student student : hs) {
>             System.out.println(student);
>         }
> 
> 
>     }
> 
> }
> ```



HashSet无序所以不可排序，而TreeSet就是专门用来排序的



写出下面代码的运行结果

- 修改下main代码用比较器的方法实现倒叙排序

```java
package com.demo08;

import java.util.Comparator;
import java.util.TreeSet;

public class TreeSetDemo01 {
    public static void main(String[] args) {
        TreeSet<Integer> ts = new TreeSet<>() ; //int类型包装类
        ts.add(5);
        ts.add(3);
        ts.add(2);
        ts.add(4);
        ts.add(1);

        System.out.println(ts);
    }
}


```

> [1,2,3,4,5]

> ```java
> package com.demo08;
> 
> import java.util.Comparator;
> import java.util.TreeSet;
> //排序二：比较器排序，需要在TreeSet集合的构造方法中，传递比较器接口的实现类对象，再编写排序的条件
> public class TreeSetDemo01 {
>     public static void main(String[] args) {
>         TreeSet<Integer> ts = new TreeSet<>(new Comparator<Integer>() {
>             @Override
>             public int compare(Integer o1, Integer o2) {
>                 int result = o2 - o1;
>                 return result;
>             }
>         }) ; //int类型包装类
>         ts.add(5);
>         ts.add(3);
>         ts.add(2);
>         ts.add(4);
>         ts.add(1);
> 
>         System.out.println(ts);
>     }
> }
> ```





自然排序的接口叫什么？重写这个接口时，返回值为何值时

- 向左存
- 不存储
- 向右存

> Comparable
>
> 负数
>
> 0
>
> 正数



自然排序要求集合中元素的类必须要实现Comparable接口，重写compareTo编写比较条件



让下面的学生类实现自然排序的接口
- 排序规则1.按照年龄升序 2.次要条件：如果年龄相同，按照姓名排序

```java
package com.demo08;

import java.util.TreeSet;

public class TreeSetDemo02 {
    public static void main(String[] args) {
        TreeSet<Student> ts = new TreeSet<>();
        Student s1 = new Student("aa",25);
        Student s2 = new Student("aa",25);
        Student s3 = new Student("bb",23);
        Student s4 = new Student("ba",23);
        Student s5 = new Student("cc",24);

        ts.add(s1);
        ts.add(s2);
        ts.add(s3);
        ts.add(s4);
        ts.add(s5);

        for (Student student : ts) {
            System.out.println(student);
        }

    }

}

```

```java
package com.demo08;

public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Student student = (Student) o;

        if (age != student.age) return false;
        return name != null ? name.equals(student.name) : student.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```

> ```java
> package com.demo08;
> 
> public class Student implements Comparable<Student>{
>     private String name;
>     private int age;
> 
>     public Student() {
>     }
> 
>     public Student(String name, int age) {
>         this.name = name;
>         this.age = age;
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         this.age = age;
>     }
> 
>     @Override
>     public boolean equals(Object o) {
>         if (this == o) return true;
>         if (o == null || getClass() != o.getClass()) return false;
> 
>         Student student = (Student) o;
> 
>         if (age != student.age) return false;
>         return name != null ? name.equals(student.name) : student.name == null;
>     }
> 
>     @Override
>     public int hashCode() {
>         int result = name != null ? name.hashCode() : 0;
>         result = 31 * result + age;
>         return result;
>     }
> 
>     @Override
>     public String toString() {
>         return "Student{" +
>                 "name='" + name + '\'' +
>                 ", age=" + age +
>                 '}';
>     }
> 
> 
>     @Override
>     public int compareTo(Student o) {
>         int result = this.age - o.getAge();
>         if(result == 0){
>             result = this.name.compareTo(o.getName());
>         }
>         return result;
>     }
> }
> 
> ```





### 双列

# &



Map接口是所有双列集合的根接口

双列是指key和value的对应关系



根据下列Map接口的常用效果写出方法名

```java
package com.demo08;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapDem01 {
    public static void main(String[] args) {
        Map<String,String> map = new HashMap<>(); //Map是一个接口，HashMap是其中的一个实现类
        //添加一对数据
        map.put("s01","张三");
        map.put("s01","李四");// 只显示"李四"
        map.put("s02","王五");
        map.put("s03","赵六");
        System.out.println(map);

//        method01(map);//基础方法

        //遍历方式1：获取所有的键，保存到Set集合
        Set<String> keys = map.keySet();
        for (String key : keys) {
            String value = map.get(key);
            System.out.println(key + "," + value);

        }


        //遍历方式2：获取所有键值对对象，保存到Set集合
        Set<Map.Entry<String, String>> entries = map.entrySet();//Entry是Map的一个内部接口，保存键和值
        for (Map.Entry<String, String> entry: entries) {
            String key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key + "," + value);
        }
    }

    private static void method01(Map<String, String> map) {


        //根据键获取值
        String value = map.get("s02");
        System.out.println(value);

        //清空集合元素
//        map.clear();
//        System.out.println(map);

        //根据键删除一对数据、返回被删除的值
        String value2 = map.remove("s03");
        System.out.println(value2);
        System.out.println(map);

        //获取集合的长度
        System.out.println(map.size());

        //判断集合中是否包含类指定的键
        System.out.println(map.containsKey("s02"));
        System.out.println(map.containsKey("s05"));

        //判断集合中是否包含指定的值
        System.out.println(map.containsValue("王五"));
        System.out.println(map.containsValue("周七");

        //获取集合中所有的值，保存到单列集合中
        Collection<String> values = map.values();
        System.out.println(values);
    }
}

```

- 添加一对键值对
- 清空集合元素
- 根据键删除
- 获取长度
- 判断集合中是否包含类指定的键
- 判断集合中是否包含类指定的值
- 获取集合中所有的值，保存到单列集合中

> put
>
> clear
>
> remove
>
> size
>
> containsKey
>
> containsValue
>
> Values



用两种方式遍历键值对

```java
package com.demo08;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapDem01 {
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>(); //Map是一个接口，HashMap是其中的一个实现类
        //添加一对数据
        map.put("s01", "张三");
        map.put("s01", "李四");// 只显示"李四"
        map.put("s02", "王五");
        map.put("s03", "赵六");
        System.out.println(map);


        //遍历方式1：获取所有的键，保存到Set集合



        //遍历方式2：获取所有键值对对象，保存到Set集合

        
    }

}
```



> ```java
> package com.demo08;
> 
> import java.util.Collection;
> import java.util.HashMap;
> import java.util.Map;
> import java.util.Set;
> 
> public class MapDem01 {
>  public static void main(String[] args) {
>      Map<String, String> map = new HashMap<>(); //Map是一个接口，HashMap是其中的一个实现类
>      //添加一对数据
>      map.put("s01", "张三");
>      map.put("s01", "李四");// 只显示"李四"
>      map.put("s02", "王五");
>      map.put("s03", "赵六");
>      System.out.println(map);
> 
> 
>      //遍历方式1：获取所有的键，保存到Set集合
>      Set<String> keys = map.keySet();
>      for (String key : keys) {
>          String value = map.get(key);
>          System.out.println(key + "," + value);
> 
>      }
> 
> 
>      //遍历方式2：获取所有键值对对象，保存到Set集合
>      Set<Map.Entry<String, String>> entries = map.entrySet();//Entry是Map的一个内部接口，保存键和值
>      for (Map.Entry<String, String> entry : entries) {
>          String key = entry.getKey();
>          String value = entry.getValue();
>          System.out.println(key + "," + value);
>      }
>  }
> 
> }
> ```







用LinkedHashMap保证下面代码元素的存取顺序

```java
package com.demo08;

import java.util.HashMap;
import java.util.Set;

public class HashMapDemo02 {
    public static void main(String[] args) {
        HashMap<String, String> hm = new HashMap<>();
        hm.put("s01","张三");
        hm.put("s02","李四");
        hm.put("s03","王五");
        hm.put("s04","赵六");

        Set<String> keys = hm.keySet();
        for (String key : keys) {
            String value = hm.get(key);
            System.out.println(key + "," + value);
        }
    }
}
```



> ```java
> package com.demo08;
> 
> import java.util.HashMap;
> import java.util.LinkedHashMap;
> import java.util.Set;
> import java.util.concurrent.LinkedBlockingDeque;
> 
> public class HashMapDemo02 {
>     public static void main(String[] args) {
>         LinkedHashMap<String,String> hm = new LinkedHashMap<>();
> //        HashMap<String, String> hm = new HashMap<>();
>         hm.put("s01","张三");
>         hm.put("s02","李四");
>         hm.put("s03","王五");
>         hm.put("s04","赵六");
> 
>         Set<String> keys = hm.keySet();
>         for (String key : keys) {
>             String value = hm.get(key);
>             System.out.println(key + "," + value);
>         }
>     }
> }
> ```



TreeMap是按什么进行排序

> 键



将下列代码用比较器改为按键降序排序

```java
package com.demo08;

import java.util.TreeMap;

public class TreeMapDemo03 {
    public static void main(String[] args) {
        TreeMap<Integer, String> tm = new TreeMap<>();
        tm.put(3,"张三");
        tm.put(1,"李四");
        tm.put(2,"王五");

        System.out.println(tm);
    }
}
```



> ```java
> package com.demo08;
> 
> import java.util.Comparator;
> import java.util.TreeMap;
> 
> public class TreeMapDemo03 {
>  public static void main(String[] args) {
>      TreeMap<Integer, String> tm = new TreeMap<>(new Comparator<Integer>() {
>          @Override
>          public int compare(Integer o1, Integer o2) {
>              return o2 - o1;
>          }
>      });
>      tm.put(3,"张三");
>      tm.put(1,"李四");
>      tm.put(2,"王五");
> 
>      System.out.println(tm);
>  }
> }
> ```





判断：Integer键的类实现了comparable的接口，并重写了方法



> 对



Hashtable线程安全，但存取慢，目前基本上被HashMap取代，但他有一个子类至今很重要，它有一个方法可以自动加载配置文件里面的键值对数据，它是谁？



> Properties



查看下面Properties的基本使用

```java
package com.demo08;

import java.util.Properties;
import java.util.Set;

public class PropertiesDemo04 {
    public static void main(String[] args) {
        Properties prop = new Properties(); // 键值一般为字符串
        prop.put("usename","zhangsan");
        prop.put("password","123456");

        Set<Object> keys = prop.keySet();
        for (Object key : keys) {
            Object value = prop.get(key);
            System.out.println(key + "," + value);
        }

    }
}
```





判断：泛型里面只能接收引用数据类型，要使用基本数据就要使用对应的包装类



> 对





int的包装类是什么？



> Inteager





### 泛型

修改下列代码，用泛型让value的值 可以修改成整型 100

```java
package com.demo09;

public class Demo01 {
    public static void main(String[] args) {
        Box box1 = new Box();
        box1.setValue("hello");
//        box1.setValue(100); // 报错
        String value = box1.getValue();
        System.out.println(value);
    }
}
```

```java
package com.demo09;

public class Box {
    private String value;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
```



>```java
>package com.demo09;
>
>public class Demo01 {
>public static void main(String[] args) {
>   Box<Integer> box1 = new Box<>();
>   box1.setValue(100); // 报错
>   Integer value = box1.getValue();
>   System.out.println(value);
>}
>}
>```
>
>```java
>package com.demo09;
>
>public class Box<T> {
>private T value;
>
>public T getValue() {
>   return value;
>}
>
>public void setValue(T value) {
>   this.value = value;
>}
>}
>```







将下面泛型指定为字符串类型

```java
package com.demo09;

import java.util.ArrayList;

public class Demo01 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();

    }
}
```



> ```java
> package com.demo09;
> 
> import java.util.ArrayList;
> 
> public class Demo01 {
>     public static void main(String[] args) {
>         ArrayList<String > list = new ArrayList<>();
> 
>     }
> }
> ```





将下面的MyPrint变成泛型方法

```java
package com.demo09;

public class Demo {
    public static void main(String[] args) {
        MyPrint my = new MyPrint();
        my.print("hello");
        my.print(100);
        my.print("true");
    }
}
```

```java
package com.demo09;

public class MyPrint {
    //需求：接受一个参数，参数是什么，打印什么
    public void  print(String t){
        System.out.println(t);
    }
}
```



> ```java
> package com.demo09;
> 
> public class MyPrint {
>     //需求：接受一个参数，参数是什么，打印什么
>     public <T> void  print(T t){
>         System.out.println(t);
>     }
> }
> ```





将下面的接口Inter变为泛型，

- 实现类InterImpl1时，直接明确数据类型为String
- 实现类InterImpl2时，将实现类变成一个泛型的类

```java
package com.demo09;

public class Demo02 {
    InterImpl1 i1 = new InterImpl1();
    i1.show("hello");
    
    InterImpl2 i2 = new InterImpl2();
    i2.show(100);

}

interface Inter{
    public abstract void show();
}


class InterImpl1 implements Inter{

    @Override
    public void show() {
        System.out.println(s);
    }
}

class InterImpl2 implements Inter{

    @Override
    public void show() {
        System.out.println(s);
    }
}
```



> ```java
> package com.demo09;
> 
> public class Demo02 {
>     public static void main(String[] args) {
>         InterImpl1 i1 = new InterImpl1();
>         i1.show("hello");
> 
>         InterImpl2<Integer> i2 = new InterImpl2();
>         i2.show(100);
>     }
> 
> 
> }
> 
> interface Inter<T>{
>     public abstract void show(T t);
> }
> 
> 
> class InterImpl1 implements Inter<String> {
> 
> 
>     @Override
>     public void show(String s) {
>         System.out.println(s);
>     }
> }
> 
> class InterImpl2<T> implements Inter<T>{
> 
>     @Override
>     public void show(T t) {
>         System.out.println(t);
> 
>     }
> }
> ```







通配符可以匹配任意类型，如下，通配符的符号是什么

```java
package com.demo09;

import java.util.ArrayList;

public class Demo01 {
    public static void main(String[] args) {
        ArrayList<String > list1 = new ArrayList<>();
        list1.add("aa");
        list1.add("bb");

        ArrayList<Integer > list2 = new ArrayList<>();
        list2.add(10);
        list2.add(20);

        printList(list1);
        printList(list2);


    }

    public static void printList(ArrayList<?> list){
        System.out.println(list);
    }


}
```



> ？





判断：下列代码报错，因为通配符在接受泛型对象时，只能接收，不能修改

```java
package com.demo09;

import java.util.ArrayList;
import java.util.List;

public class Test {
    public static void main(String[] args) {
        List<?> list = new ArrayList<String>();
        list.add("张三");
    }
}
```



> 对





判断：上限限定是指只能是该类本身或者它的子类，而下限时本身和其父类



> 对





上限限定和下限限定的关键词分别是什么？



> extends
>
> super





补充代码，如何用类型通配符使方法method1只能上限限定数字类型（Float、Integer、Double、Byte）的元素

```java
public static void method1(ArrayList<? extends > list){}
```



> ```java
> public static void method1(ArrayList<? extends Number> list){}
> ```
>
> 





判断：类型通配符能解决以下集合不能协变问题（基础类型具备父子关系)



> 对





主程序method1的哪几行会报错，method2的哪几行会报错

```java
package com.demo09;

import java.util.ArrayList;

public class Demo01 {
    public static void main(String[] args) {
        ArrayList<String > list = new ArrayList<>();
        method1(new ArrayList<A>());
        method1(new ArrayList<B>());
        method1(new ArrayList<C>());
        method1(new ArrayList<D>());

        method2(new ArrayList<A>());
        method2(new ArrayList<B>());
        method2(new ArrayList<C>());
        method2(new ArrayList<D>());

    }

    public static void method1(ArrayList<? extends C> list){}

    public static void method2(ArrayList<? super C> list){}

}


class A{}

class B extends A{}

class C extends B{}

class D extends C{}
```



> 1，2
>
> 4





判断：Lambda表达式必须是接口，且接口中只能有一个抽象方法



> 对





jdk8的新特性lambda表达式的三个符号是什么



> () -> {}





用Lambda表达式来实现下面的效果

```java
package com.demo09;

import java.util.ArrayList;

public class Demo01 {
    public static void main(String[] args) {
        useInter(new Inter() {
            @Override
            public void show(String str) {
                System.out.println(str);
            }
        });

        System.out.println("------------");
        
        //Lambda方法
      
      

    }

    public static void useInter(Inter i){
        i.show("hello");
    }


interface Inter{
        public abstract void show(String str);
}

}
```



> ```java
> package com.demo09;
> 
> import java.util.ArrayList;
> 
> public class Demo01 {
>     public static void main(String[] args) {
>         useInter(new Inter() {
>             @Override
>             public void show(String str) {
>                 System.out.println(str);
>             }
>         });
> 
>         System.out.println("------------");
> 
>         //Lambda方法
>         useInter((String str) -> {System.out.println(str);});
> 
> 
>     }
> 
>     public static void useInter(Inter i){
>         i.show("hello");
>     }
> 
> 
>     interface Inter{
>         public abstract void show(String str);
>     }
> 
> }
> ```





用快捷键使用lambda实现下面的降序效果，再补充一遍完整格式

```java
package com.demo09;

import java.util.Comparator;
import java.util.TreeSet;

public class Demo03 {
    public static void main(String[] args) {
        TreeSet<Integer> ts = new TreeSet<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - 01;
            }
        });
        ts.add(5);
        ts.add(2);
        ts.add(3);
        ts.add(1);
        ts.add(4);

        System.out.println(ts);
    }


}
```



> ```java
> package com.demo09;
> 
> import java.util.Comparator;
> import java.util.TreeSet;
> 
> public class Demo03 {
>     public static void main(String[] args) {
> //        TreeSet<Integer> ts = new TreeSet<>((o1, o2) -> o2 - 01);
>         TreeSet<Integer> ts = new TreeSet<>((Integer o1, Integer o2) -> {return (o2 - 01);});
>         ts.add(5);
>         ts.add(2);
>         ts.add(3);
>         ts.add(1);
>         ts.add(4);
> 
>         System.out.println(ts);
>     }
> 
> 
> }
> ```



### 案例

库存管理系统











# reason



# 黑马-拟合

应试

1. continue是结束本次循环
2. 











# 黑马-源码

> 黑马



## java基础

### IEDA



- 快捷键

>  快速向下复制 ctrl(cmd)+D
>  快速格式化代码 ctrl+alt+L
>  多行注释 ctrl+shift+/
>  快速换行 shift+enter
>  选中当前行 cmd+option+v
>  抽取方法 cmd+option+m（ctrl+alt+m）
>  整体嵌套 cmd+option+t
>  创建方法 option+enter（alt+enter）
>  展示类中方法 继承语句处alt+enter
>
>  ![image-20220222230624812](https://i0.hdslb.com/bfs/album/4fd39a703885ef4a56bd17257ba0162a7ec84ed3.png)





- 快捷操作

>  enter拆分字符串
>  生成空参数的构造方法：右击+Generate+Constructor
>  	选择参数，生成带有参数的构造方法
>  生成get和set方法：右击+Generate+Getter and Setter+选择参数





- 快捷代码

> psvm：main
> sout
> 数组名.fori：遍历数组









### 基本



1. java中语句分两种有何区别？

> 功能执行语句要加；结构定义语句不用







2. 下面的字符串如何从“我的”处后换行？

```java
System.out.println("这是我的第一个语言");
```



> ```java
> System.out.println("这是我的"+
>                    "第一个语言");





3. 单行、多行、文档注释符分别是什么?



> ```java
> int c = 10;      // 定义一个整型变量
> 
> 
> /*  int c = 10; 
> 	int x = 5; */
> 
> 
> /**
>   name = “黑马程序员”；
>  */





4. 标识符一般可以给哪5个内容命名，一般的命名规则又是什么？命名时不能出现哪两种情况？开头可以出现哪四种特殊符号？



>（1）包名：cn.itcast.test（所有字母一律小写）
>（2）类名(接口名)：ArrayList、Iterator（每个单词的首字母都要大写）
>（3）常量名：DAY_OF_MONTH（所有字母都大写，单词之间用下划线连接）
>（4）变量名和方法名：lineNumber、getLineNumber（第一个单词首字母小写，从第二个单词开始每个单词首字母大写）
>   (5)  参数名：x,y
>
>#：名称：使用userName定义用户名，password定义密码（在程序中，应该尽量使用有意义的英文单词定义标识符，使得程序便于阅读）

> 以数字开头
> 是Java中的关键字

>字母、数字、下画线（_）、美元符号（$）





5. java中常用哪些关键字？有哪两个保留关键字？有哪些不是关键字但也不能用作标识符的？main是否是关键字



><img src="https://i0.hdslb.com/bfs/album/5a7659df3e82689a724f2d56ca222070f2d20103.png" alt="image-20220223000408854"  />

> const、goto

> true、false、null

> 不是，mian代表程序的入口点





6. 常量（Constant）是什么？一般包括哪4种分别举例？



> 程序运行中不会发生变化的量

> 整型常量
>
> - 二进制：0b01101100、0B1011010(不是0是O)
> - 八进制：0342
> - 十进制：198
> - 十六进制：0x25AF、0X25AF
>
> - #：终端输出依旧是19进制
>
> 浮点数常量
>
> - 单精度（float）：5
> - 双精度（double）：5.5
> - #：默认双精度
>
> 字符常量（一个）
>
> - 'a'  、'1'  、'&'  、'\r' 、'\u0000' 
>
> 字符串常量（多个）
>
> - "HelloWorld"   、"123"   、"Welcome \n XXX" 
>
> 布尔常量
>
> - true、false
>
> null常量
>
> - Null





7. 用2种方式“123”让输出语句换行？

>```java
>System.out.print("123\r\n");
>
>System.out.println("123");
>```





8. 数据类型如何分类？分别又有哪些？

> 基本数据类型和引用数据类型

> 基本数据类型：整型（byte、short、int（默认） 、long）、浮点型（flaot、double(默认））、字符型（char）、布尔型（boolean）
> 引用数据类型：类（class）、接口（interface）、数组、枚举（enum）、注释（annotation）

> #：<img src="https://i0.hdslb.com/bfs/album/f22b8364c26025dc6c78c18d99b6f47196192fa5.png" alt="image-20220223134615271" style="zoom:50%;" /><img src="https://i0.hdslb.com/bfs/album/cb116b910885dbe85a2bea48b1657d68cce7b4fa.png" alt="image-20220223135346281" style="zoom:50%;" />





9. 下列这段程序的运行结果是什么？

```java
        long num = 40L;
        System.out.print("num");
```

> 40

> #:int的范围是4294967296.一共10位首位是4<img src="https://i0.hdslb.com/bfs/album/ecb1fe688758b342c1f0cf47d5f97fb0e69dd6b5.png" alt="image-20220223134806658" style="zoom:50%;" />
>
> 在为double类型的变量赋值时，后面可以加字母D或d，也可以不添加





10. 下列这段程序的运行结果是什么？

```java
        double num = 40;
        System.out.print(num);
```



> 40.0

> #:<img src="https://i0.hdslb.com/bfs/album/e8697fb2f2719a687e831edbe9beb148476898b8.png" alt="image-20220223135810845" style="zoom:50%;" />





11. java使用的包括ascII码字符码系统是什么，它会为每个字符制定了一个唯一的数值

> Unicode



12. char a = 'c';还可以写成什么

> char a = 97;

> #:<img src="https://i0.hdslb.com/bfs/album/da85c3be1c978e745fdbaadb49217268309687de.png" alt="image-20220223140420050" style="zoom:50%;" />





13. 下列这段程序的运行结果是什么？

```java
        boolean b1 = true;
        boolean b2 = false;
        System.out.println(b1);
        System.out.println(b2);
```

> true
> false





14. 判断：java通过一行代码可以来定义多个变量，但不能一行完成赋值

> 正确

> #：![image-20220223141050334](https://i0.hdslb.com/bfs/album/a1f8302a9c74b118896b7b86d8995700543cc472.png)
>
> 一般一行只定义一个变量





15. 查看看下列自动类型转换

><img src="https://i0.hdslb.com/bfs/album/15095996a7190226414f7bcb57907c80e7efc0ee.png" alt="image-20220223163829916" style="zoom:50%;" />





16. 如何强制转换下裂程序,强制转换后的运行结果是什么？

```java
int num = 298;
byte b = num;
```




> ```java
  int num = 298;
  byte b = (byte)num;
  ```

>  <img src="https://i0.hdslb.com/bfs/album/d85cc710b67aeee7f5a0b5d3c0c80a7f3c93a62f.png" alt="image-20220223164433047" style="zoom:50%;" />42





17. 下列代码的b3是什么类型？修改错误的语句

    ```java
    public class Example03 {
    	public static void main(String[] args) {
    		byte b1 = 3; // 定义一个byte类型的变量
    		byte b2 = 4;
    		// 两个byte类型变量相加，赋值给一个byte类型变量
    		byte b3 = b1 + b2; 		
    		System.out.println("b3=" + b3);
    	}
    }
    
    ```



> int

> byte b3 = (byte)(b1 + b2);

> #:1. Byte short char 三种类型在运算时，都会提升为int类型 
>
> 2. java中有常量优化机制：
>    		在赋值时，编译器会检查数据是否超过了此类型的取值范围
>       		如果没有超出：正常赋值
>       		如果超出：编译报错





18. 下列这段程序的运行结果是什么？

    ```java
    
    public class HelloWorld {
        public static void main(String[] args) {
            int x = 12;
    
            {
                int y = 20;
                System.out.println(x);
                System.out.println(y);
    
    
            }
        }
    }
    ```

    

> 12
> 20

> #:变量的作用域为：从定义处开始，到变量所在代码块结束的位置





19. 如何使5/2输出为2.5

> ```java
> System.out.println(5.0/2); //有一方必须是小数类型
> ```
>
> 



20. 下列代码中最后num1的数据类型是什么？

    ```java
    byte num1 = 5;
    int num2 = 0;
    num1 += num2
    ```

> Byte





21. 表示与、或、非、异或的逻辑运算符分别是什么

> &、|、！、^





22. 说明短路与和与的区别，同理短路或

> &&:左边为false，右边不执行
>
> ｜｜:左边为true，右边不执行









23. 查看下列运算符的优先级

> <img src="https://i0.hdslb.com/bfs/album/78ad73403477a32e883d045c2da6bf2d6d6b7074.png" alt="image-20220225074034228" style="zoom:50%;" />





24. 下列代码是对一个学生的考试成绩进行等级划分，如果分数大于80分，则等级为优；如果分数大于70分，则等级为良；如果分数大于60分，则等级为中；如果分数小于60分，则等级为差。画出代码的流程图

```java
public class HelloWorld {
    public static void main(String[] args) {
        int score = 65;
        if(score > 80){
            System.out.println("优秀");
        }else if(score >70){
            System.out.println("良好");
        }else if(score > 60){
            System.out.println("及格");
        }else{
            System.out.println("一般");
        }
    }
}
```



> <img src="https://i0.hdslb.com/bfs/album/9ab25969799abef3178d22c8505867f89276cd2e.png" alt="image-20220227200254740" style="zoom:50%;" />





25. 将下列程序写成三元运算符的形式
    <img src="https://i0.hdslb.com/bfs/album/98949a57f84cc0a1de3a2c7e26c63a0d6901433b.png" alt="image-20220227200512171" style="zoom:50%;" />



> <img src="https://i0.hdslb.com/bfs/album/0c9e4f2368ff481ac5618671b933abb44642f956.png" alt="image-20220227200529321" style="zoom:50%;" />
>
> #:![image-20220227200742379](https://i0.hdslb.com/bfs/album/551c0c94fa4388a01e573a14b4a73b93b0f30ce0.png)



26. 用switch条件语句编写下列代码,再添加一个default
    <img src="https://i0.hdslb.com/bfs/album/db5c7eaf573c0820eed1758838894bcf2e20a476.png" alt="image-20220227201042997" style="zoom:50%;" />



> ```java
> package com.demo01;
> 
> public class HelloWorld {
>     public static void main(String[] args) {
>         int week = 5;
>         switch(week){
>             case 1:
>                 System.out.println("星期一");
>                 break;
>             case 2:
>                 System.out.println("星期二");
>                 break;
>             case 3:
>                 System.out.println("星期三");
>                 break;
>             case 4:
>                 System.out.println("星期四");
>                 break;
>             case 5:
>                 System.out.println("星期五");
>                 break;
>             case 6:
>                 System.out.println("星期六");
>                 break;
>             case 7:
>                 System.out.println("星期天");
>                 break;
>             default:
>                 System.out.println("星期天数字有误");
>                 break;
>         }
> 
>     }
> }
> ```
>
> 



27. 编写代码，1～5为工作日，6～7位休息日

```java
package com.demo01;

public class HelloWorld {
    public static void main(String[] args) {
        int week = 5;
        switch(week){
            case 1:
            case 2:
            case 3:
            case 4:
            case 5:
                System.out.println("工作日");
                break;
            case 6:
            case 7:
                System.out.println("休息日");
                break;
            default:
                System.out.println("星期天数字有误");
                break;
        }

    }
}
```





28. 写出下面代码运行的结果

```java
public class HelloWorld {
    public static void main(String[] args) {
      
        int x = 5;
        do{
            x++;
        }while(x <= 4);
        
        System.out.println("x = " +x);
      
    }
}
```



> 6





29. 编写for循环，实现1～4的累加,并说出for循环的执行顺序。并说出x最后的值



> ```java
> public class HelloWorld {
>  public static void main(String[] args) {
> 
>    	int sum = 0;
> 				for(int x = 1;x <= 4;x++){
> 			sum += x;
> 				}
> 
>  }
> }
> 
> 
> ```
>
> - x=1 #初始化表达值
> - x <= 4 #循环条件
> - sum += x #循环体
> - x++ #操作表达式
> - x <= 4 #循环体哦啊见
> - ……
> - x++

> x=5，但x无法跳出for使用





30. 编写打印n行，每行对应n个*,n设为9



```java

public class HelloWorld {
    public static void main(String[] args) {
      
				int n = 9;
        w:for(int i = 1; i <= n;i++){
            for(int j = 1; j <= i;j++){
                System.out.print("*");
            }
            System.out.println();
        }

    }
}
```





31. 改写上面代码，当i>4时结束最外层循环



```java
package com.demo01;

public class HelloWorld {
    public static void main(String[] args) {

        w:for(int i = 1; i <= 9;i++){
            for(int j = 1; j <= i;j++){
                if(i > 4){
                    break w;
                }
                System.out.print("*");
            }
            System.out.println();
        }

    }
}
```





32. 编写程序求1～100之间的奇数数字和



> ```java
public class HelloWorld {
    public static void main(String[] args) {
        int sum = 0;
        for(int i = 1; i <= 100; i++){
            if(i % 2 == 0){
                continue;
            }
            sum += i;
        }
        System.out.println(sum);
       }
     }



33. - 编写方法printRectangle，使其能打印任意行、任意列的矩型*号。并将height设为3，width设为5调用。
    - 编写方法getArea返回矩形的面积，传参值设为3和5，并打印返回值



> ```java
> public class HelloWorld {
>     public static void main(String[] args) {
>         printRectangle(3, 5);
>         int area = getArea(3,5);
>         System.out.println(area);
>     }
> 
> 
>     public static void printRectangle(int height,int width){
>         for(int i = 0; i < height; i++){
>             for(int j = 0; j < width; j++){
>                 System.out.print("*");
>             }
>             System.out.println();
>         } 
>     }
> 
>     public static int getArea(int x,int y){
>         int area = x * y;
>         return area;
>     }
> 
> }





34. 用重载方法定义三个add方法，第一个获取2个整数和的方法，第二个获取3个整数和的方法，第三个获取2个小数和的方法。并赋值10，20调用



> ```java
> public class HelloWorld {
>     public static void main(String[] args) {
>         int sum1 = add(10,20);
>         System.out.println(sum1);
>     }
> 
>     public static int add(int x,int y){
>         return x + y;
>     }
> 
>     public static int add(int x,int y,int z){
>         return x + y + z;
>     }
> 
>     public static double add(double x, double y){
>         return x + y;
>     }
> }
> ```
>
> 



35. - 创建一个名为arr，int类型的数组，设置长度为3，并打印arr。
    - 说出arr的打印值“[I@75b84c92”的含义
    - 如何查看数组的长度
    - 创建一个名为arr1的int数组，静态初始化，保存一些数字：10，20，30。并查看索引为0的值
    - 将arr清空：空指针

    

    > ```java
    > public class HelloWorld {
    >     public static void main(String[] args) {
    >         int[] arr = new int[3];
    >         System.out.println(arr);
    >         int[] arr1 = {10,20,30,40};
    >         System.out.println(arr1[0]);
    >         arr = null;
    >     }
    > }
    > ```

    > 数组 int类型 @是拼接赋 16位的地址码





36. 写出下列数组类型的默认初始化值

    - 整数类型
    - 小数类型
    - 字符类型
    - 布尔类型
    - 引用类型

    

> - 0
> - 0.0
> - 空白字符
> - false
> - null





37. - 对数组 arr = {20,10,30,,40} 取最大值
    - 用冒泡排序法排序
      - 比较了多少轮
      - 每轮比较了多少次



> ```java
> public class HelloWorld {
>     public static void main(String[] args) {
>         int[] arr = {20,10,30,40};
>         int max =arr[0];
>         for(int i = 0; i < arr.length; i++){
>             if(arr[i] > max){
>                 max = arr[i];
>             }
>         }
>         System.out.println(max);
>     }
> }
> ```

> ```java
> public class HelloWorld {
>     public static void main(String[] args) {
>         int[] arr = {20,10,30,40};
>         for (int i = 0; i < arr.length-1; i++) {
>             for (int j = 0; j < arr.length-1-i; j++) {
>                 if(arr[j] > arr[j+1]){
>                     int temp = arr[j];
>                     arr[j] = arr[j+1];
>                     arr[j+1] = temp;
>                 }
>             }
>         }
>         for (int i = 0; i < arr.length; i++) {
>             System.out.print(arr[i] + " ");
>         }
>         System.out.println();
> 
>     }
> }
> ```

> 数组长度-1
>
> 比上一轮少一次





38. 用三种方式创建一个长度为2的二维数组，每个一维数组可以保存2个元素，赋值 {10,20}  {30,40}  并打印值10.



> ```java
> public class HelloWorld {
>     public static void main(String[] args) {
>         method01();
>         method02();
>         method03();
>     }
> 
>     private static void method03() {
>         int[][] arr = {{10,20},{30,40}};
>         System.out.println(arr[0][0]);
>     }
> 
>     private static void method02() {
>         int[][] arr = new int[2][];
>         int[] arr1 = {10, 20};
>         int[] arr2 = {30, 40};
>         arr[0] = arr1;
>         arr[1] = arr2;
>         System.out.println(arr[0][0]);
>     }
> 
>     private static void method01() {
>         int[][] arr = new int[2][2];
>         int[] arr1 = {10, 20};
>         int[] arr2 = {30, 40};
>         arr[0] = arr1;
>         arr[1] = arr2;
>         System.out.println(arr[0][0]);
>     }
> 
> 
> }
> ```
>



39. 如何给变量a接受一个整型变量的输入



> ```java
> Scanner sc = new Scanner(System.in);
> a = sc.nextInt();
> ```





40. 编写程序，当flag是“Y”时，继续循环，当输入“N”时，结束循环



> ```java
> Scanner sc = new Scanner(System.in);
> String flag = "Y";
> while("Y".equals(flag)){
>   	flag = sc.next()
> }
> ```
>
> 





41. 编写程序，使整型变量num，随机生成1～3的数字



> ```java
> Random r = new Random();
> int num = r.nextInt(3) + 1；
> ```
>
> 



42. 设计一个查看登录注册退出系统

> ```java
> package com.demo01;
> 
> 
> import java.util.Scanner;
> 
> import static sun.security.jgss.GSSUtil.login;
> 
> public class HelloWorld{
>     static  String[] arr1 = new String[3];
>     static  String[] arr2 = new String[3];
>     static Scanner sc = new Scanner(System.in);
>     public static void main(String[] args) {
>         arr1[0] = "张三";
>         arr2[0] = "123";
> 
>         while (true) {
>             System.out.println("--------------系统---------------");
>             System.out.println("1、查看功能");
>             System.out.println("2、登录功能");
>             System.out.println("3、注册功能");
>             System.out.println("4、退出系统");
>             int id = sc.nextInt();
>             switch (id){
>                 case 1:
>                     show();
>                     break;
>                 case 2:
>                     login();
>                     break;
>                 case 3:
>                     regist();
>                     break;
>                 case 4:
>                     System.out.println("感谢您的使用");
>                     System.exit(0);
>                     break;
>                 default:
>                     System.out.println("您输入的有误");
>                     break;
>             }
>         }
> 
>     }
> 
>     private static void regist() {
>         String username = null;
>         while (true) {
>             System.out.println("请输入用户名：");
>             username = sc.next();
> 
>             boolean flag = false;
>             for (int i = 0; i < arr1.length; i++) {
>                  if(arr1[i] != null){
>                      if(arr1[i].equals(username)){
>                          flag = true;
>                          break;
>                      }
>                  }
>             }
>             if(flag == true){
>                 System.out.println("用户名已存在，请重新输入：");
>             }else{
>                 break;
>             }
>         }
>         System.out.println("请输入密码：");
>         String password = sc.next();
> 
>         //判断：当前数组是否装满了
>         boolean flag = true;
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] == null){
>                 flag = false;
>                 break;
>             }
>         }
> 
>         if(flag == false){
>             //没有装满
>             for (int i = 0; i < arr1.length; i++) {
>                 if(arr1[i] == null){
>                     arr1[i] = username;
>                     arr2[i] = password;
>                     break;
>                 }
>             }
>         }else{
>             String[] newArr1 = new String[arr1.length + 3];
>             String[] newArr2 = new String[arr2.length + 3];
>             System.arraycopy(arr1,0,newArr1,0,arr1.length);
>             System.arraycopy(arr2,0,newArr2,0,arr2.length);
>             arr1 = newArr1;
>             arr2 = newArr2;
> 
>             for (int i = 0; i < arr1.length; i++) {
>                 if(arr1[i] == null){
>                     arr1[i] = username;
>                     arr2[i] = password;
>                     break;
>                 }
>             }
>         }
>         System.out.println("注册成功");
>     }
> 
>     private static void login() {
>         System.out.println("请输入用户名：");
>         String username = sc.next();
>         System.out.println("请输入密码：");
>         String password = sc.next();
> 
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 if(arr1[i].equals(username) && arr2[i].equals(password)){
>                     System.out.println("登录成功");
>                     return;
>                 }
>             }
>         }
>         System.out.println("登录失败");
>     }
> 
>     private static void show() {
>         for (int i = 0; i < arr1.length; i++) {
>             if(arr1[i] != null){
>                 System.out.println("用户名：" + arr1[i] + ",密码" + arr2[i]);
>             }
>         }
>     }
> 
> }
> ```
>
> 







43. 下列关于方法的描述中，正确的是（ ）
    A、方法是对功能代码块的封装
    B、当方法没有返回值时，返回值类型可以不写
    C、当方法没有返回值时，不能有return语句
    D、方法是不可以没有参数的

> A
> #:方法可以没有返回值。return 0（也可以直接写成returen）表示终止方法，不是返回值



44. 判断
    - 选择语句分为if条件语句和switch条件语句
    - 循环语句有：while语句、do-while语句和for语句
    - 条件语句有：if语句、if-else 语句和if-else if-else 语句



> 对，对，对



45. 写出下列程序的值

```java
public class HelloWorld {
    public static void main(String[] args) {
        int a = 0;
        int b = 0;
        for (int i = 1; i <= 5; i++) {
            a = i % 2;
            while (a-- >= 0) {
                b++;
            }
        }
        System.out.println("a=" + a + ",b=" + b);
    }
}
```



> a=-2,b=8





46. 关于continue语句的使用范围，下列说法正确的是（）

    A、continue语句可以在选择语句中使用

    B、continue语句可以在条件语句中使用

    C、continue语句可以在循环语句中使用

    D、不输出任何内容



> C



47. 下列关于方法重载的说法中，正确的是（ ）
    A.形式参数的个数不同。
    B.形式参数的个数不同，数据类型不同。
    C.形式参数的个数相同，数据类型不同。
    D.形式参数的个数相同，数据类型顺序不同。



> ABCD





















## 面向对象



1. 面向对象的三大特性是什么？



> 封装，继承，多态



2. 编写一个学生类(姓名，年龄，性别）并调用2次



> ```java
> public class Student {
>     String name;
>     int age;
>     String sex;
> 
>     public void read() {
>         System.out.println("姓名是：" + name);
>         System.out.println("年龄是：" + age);
>         System.out.println("性别是：" + sex);
>         System.out.println("好好学习");
>     }
> }
> ```
>
> ```java
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student stu = new Student();
> //        System.out.println(stu);
>         stu.name = "张三";
>         stu.age = 23;
>         stu.sex = "男";
>         System.out.println(stu.name);
>         stu.read(); 
> 
>         Student stu2 = new Student();
>         stu2.name = "李四";
>         stu2.age = 24;
>         stu2.sex = "女";
>         stu2.read();
>     }
> }
> ```
>
> 





3. java中三类内存的作用分别是什么？并描述创建上述学生类和调用学生类对象在内存中的变化过程。



> 栈内存:执行方法
>
> 堆内存:保存对象
>
> 方法区:保存类编译后产生的自解码文件

> ![image-20220302054238658](https://i0.hdslb.com/bfs/album/01fae40ddbd6cd5988a65789ce8b63fd8cd0000e.png)
>
> - 方法区编译StudentDemo01
> - 运行主程序main()
> - main方法首先会加载到栈内存中
> - 方法区加载student.class
> - Student stu= 会在栈内存中产生学生类对象
> - new Student() 会对应的堆中会创建出学生对象
> - 堆中加载成员变量 #1.成员方法不会进入到堆内存中的对象空间 2.成员变量会有默认初始化值，Java 没有内置的字符串类型，只提供一个类string来操作字符串，所以string是引用类型
> - 但堆中会有成员方法的引用：在方法区对应方法的内存地址
> - 堆中的学生对象会有自己独立的内存地址002，并赋值给栈中的stu，使stu完成访问
> - 栈中进行对象变量name的赋值，根据stu对象名的地址002 找内存空间，修改堆中的成员变量name的值
> - 栈中成员方法read()的调用，会进入栈中执行，read()执行完后，会立即在栈内存中消失，重新回到栈main()中。最后main()执行完后也会在栈内存中消失  
> - #：一个类可以创建多个对象，每个对象间都是相互独立，互不影响的





4. 如何将上述学生类的对象stu2引用传递给新对象stu3？并解释为什么两个对象是一样的？



> ```java
> Student stu2 = stu3
> ```

> 内存地址一样
>
> #：引用数据类型在相互赋值时，赋值的是该对象的内存地址值![image-20220302164130643](https://i0.hdslb.com/bfs/album/b1cdfab2b6585d31e84dd4c63821e8650b14731b.png)





5. 访问控制又称为什么？四种访问控制权限的特点分别是什么?



> 权限修饰符

> private：当前类访问级别 
>
> default（可不写）：当前包内访问级别
>
> protected：本包或不同包的子类访问
>
> public：所有包

> #:![image-20220302170608448](https://i0.hdslb.com/bfs/album/70c04bc88e8ba786846d103fa0ee5ffab2e99591.png)



6. 为什么要封装



> 防止本类的代码和数据被外界程序随意访问

> #：间接访问变量age设置-7存在安全隐患





7. 封装上述学生类的成员变量，并为姓名和年龄分别创建一个间接访问和修改方法getName和getAge。并在主程序实现修改和调用，确保年龄在0到120之间



> ```java
> package com.demo01;
> 
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student stu = new Student();
>         stu.setAge(20);
>         stu.read();
>         String name = stu.getName();
>         System.out.println(name);
>     }
> }
> ```
>
> ```java
> package com.demo01;
> 
> public class Student {
>     private String name;
>     private int age;
> 
>     public String getName() {
>         return name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public void setAge(int age) {
>         if(age >= 0 && age <= 120)
>         this.age = age;
>     }
> 
>     public void read() {
>         System.out.println("姓名是：" + name);
>         System.out.println("年龄是：" + age);
>         System.out.println("好好学习");
>     }
> }
> 
> ```
>
> 



8. 如何为上述学生类创建带name和age参数的构造方法。并在主程序完成调用



> ```java
>     public Student(String name,int age){
>         this.name = name;
>         this.age = age;
> ```
>
> ```java
>         Student stu = new Student("张三",13);
> ```
>
> #:如果一个类中没有写任何的构造方法，系统会提供一个默认的无参构造方法。目的：为了创造对象



9. 同上，重载一个只有一个name参数的构造方法和一个无参构造方法，再重新调用。



> ```java
> package com.demo01;
> 
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student stu = new Student("张三",13);
>         stu.read();
>         Student stu1 = new Student();
>         stu1.read();
>         Student stu2 = new Student("李四");
>         stu2.read();
> 
>     }
> }
> ```
>
> ```java
> package com.demo01;
> 
> public class Student {
>     private String name;
>     private int age;
> 
>     public Student(){
> 
>     }
> 
>     public Student(String name,int age){
>         this.name = name;
>         this.age = age;
> 
>     }
> 
>     public Student(String name){
>         this.name = name;
> 
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public void setAge(int age) {
>         if(age >= 0 && age <= 120)
>         this.age = age;
>     }
> 
>     public void read() {
>         System.out.println("姓名是：" + name);
>         System.out.println("年龄是：" + age);
>         System.out.println("好好学习");
>     }
> }
> 
> ```
>
> #:一般类会定义两个构造方法，一个无参，一个有参



10. this关键字的三个作用是什么？分别要注意什么？



> 1. 可以调用本类的成员变量
>    - 用来区分调用的是成员变量的
> 2. 可以调用本类的成员方法
>    - 如果调用的是本类中其他的成员变量，this可以省略
> 3. 调用构造方法
>    - 调用空参构造方法要写成this()
>    - this调用其他构造方法，必须放在第一行有效代码上



11. “{}"四类代码块是什么？作用是什么？



> 普通块：方法里面写一个{}
>
> - 限定变量的生命周期，当大括号执行后，里面的变量也会消失，提高内存的利用率
>
> 构造块：类中，方法外
>
> - 在构造方法之前执行
>
> 静态代码块：类中，方法外，{前加一个static
>
> - 当这个类一被加载到内存时，静态代码块就
> - 
> - 
> - 会执行，而且只会执行一次
>
> 同步代码块



12. - 将上述学生类的name和方法read分别设置为静态属性和方法，并在主程序中用类名称完成调用。并在学生类中创建新的方法show，调用read
    - 并说明非静态和静态的区别



> ```java
> package com.demo01;
> 
> public class StudentDemo01 {
>     public static void main(String[] args) {
>         Student.name = "张三";
> 
>         Student stu = new Student();
>         Student.read();
>         Student stu1 = new Student();
>         stu1.read();
>         Student stu2 = new Student("李四");
>         stu2.read();
> 
>     }
> }
> 
> ```
>
> ```java
> package com.demo01;
> 
> public class Student {
>     static String name;
>     private int age;
> 
>     public Student() {
> 
>     }
> 
>     public Student(String name, int age) {
>         this.name = name;
>         this.age = age;
> 
>     }
> 
>     public Student(String name) {
>         this.name = name;
> 
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public void setAge(int age) {
>         if (age >= 0 && age <= 120)
>             this.age = age;
>     }
> 
>     public static void show() {
>         read();
>     }
>     
>     
>     public static void read() {
>         System.out.println("姓名是：" + name);
>         System.out.println("好好学习");
>     }
> }
> 
> ```

> 非静态创建对象之后存在的
> 静态是随着类的加载存在的





13. 设计一个学生投票系统



> ```java
> package com.demo01;
> 
> public class Test {
>     public static void main(String[] args) {
>         Voter v1 = new Voter("tom");
>         Voter v2 = new Voter("jack");
>         Voter v3 = new Voter("mike");
> 
>         v1.voterFor("是");
>         v1.voterFor("否");
>         v2.voterFor("是");
>         v3.voterFor("否");
> 
>         v1.printResult();
>         v2.printResult();
>         v3.printResult();
>     }
> }
> 
> ```
>
> ```java
> package com.demo01;
> 
> import java.util.HashSet;
> 
> public class Voter {
>     public static final  int Max_COUNT = 100; //不可更改
>     public static int count;
>     public static HashSet<Voter>  voters = new HashSet<>();
>     public String name;
>     public String answer;
> 
>     public Voter(String name) {
>         this.name = name;
>     }
> 
>     //投票的方法
> 
>     public void voterFor(String answer){
>         if(count == Max_COUNT){
>             System.out.println("投票数量已到达上线");
>             return;
>         }
> 
>         if(voters.contains(this)){
>             System.out.println(name+"请勿重复投票");
>         }else{
>             this.answer = answer;
>             count++;
>             voters.add(this);
>             System.out.println(name + "感谢您的投票");
>         }
> 
>     }
> 
>     //打印投票信息的方法
> 
>     public void printResult(){
>         System.out.println("参与投票的数量:"+count+"个");
>         System.out.println("参与投票的结果如下：");
>         for(Voter voter:voters){
>             System.out.println(voter.name + " 意见 " + voter.answer);
>         }
>     }
> }
> 
> ```





dog子类如何继承父类animal



> ```java
> public class Dag extends Animal{
>   
> }
> ```
>
> 



15. 继承间要注意那两点



> 1. java只支持单继承
> 2. 但可以多层继承



16. dog子类重写下面父类animal的eat方法，用注解检测是否是正确的重写格式

```java
package com.demo01;

public class Animal {
    public void eat(){
        System.out.println("动物吃饭");
    }
}
```



> ```java
> package com.demo01;
> 
> public class Dog extends Animal{
>     @Override
>     public void eat(){
>         System.out.println("狗吃肉");
>     }
> }
> ```
>
> 





17. 方法的重写要注意哪一点



> 访问权限只能大于等于父类方法的访问



18. - 下列代码那里有错误
    - Animal中构造方法的super()访问的父类是谁

```java
package com.demo01;

public class Animal {
    private String name;
    private int age;

    public  Animal(){
    }

    public  Animal(String name, int age) {
        this.name = name;
        this.age = age;
    }

        
}
```

```java
package com.demo01;

public class Dog extends Animal{
    public  Dog(){
        super();//系统默认编写
        this("is",10);
    }

    public  Dog(String name, int age){
        super(name,age);

    }
}
```



> 在构造方法里面，this和super不能同时访问构造方法

> Object类
>
> #：Object类是java中最顶层的一个类，如果一个类没有写继承的关系，这个类默认继承Object类。
>
> ```java
> public class Animal extends Object{
>     private String name;
>     private int age;
> 
>     public  Animal(){
>       super();
>     }
> 
>         
> }
> ```
>
> 



19. final关键字有什么用？



> 修饰类：类不能被继承
> 修饰方法：方法不能被重写(但可以直接继承)
> 修饰变量： 变量变成常量，其值不能发生改变
> 修饰引用数据类型：内存地址不能发生改变。但是内部属性值是可以修改的
>
> #：
>
> ```java
> final class Fu extends Object{
>   final int num = 10; 
>   public final void show(){
>     sout("sw1")
>   }
> }
> ```
>
> ```java
> final Fu f = new Fu();//001
> f = new Fu();//002
> ```
>
> 



20. 自定义常量和字面值常量有什么区别



> 自定义常量：单词全部大写，如果多个单词，单词之间使用下划线分割





21. - 什么时候会用到抽象类？
    - 查看下列代码，抽象类应该注意哪三点？

```java
package com.demo01;

public abstract class Animal {
    public abstract void eat();
    
}
```

```java
package com.demo01;

public class Dog extends Animal{

    @Override
    public void eat() {
        System.out.println("狗吃肉");
    }
}
}
```



> 类中无法抽象出方法的实现逻辑

> 1. 抽象类不能直接创建对象，因为抽象类中可能会有抽象方法。
> 2. abstract不能被private修饰，因为继承一个抽象类，必须重写所有的抽象方法
> 3. 有抽象方法的类也必须是抽象类





创建接口InterA和InterB,类InterImpl继承object类和Inter A和InterB接口
要求：

- InterA创建常量NUM、抽象方法method、静态方法show、默认方法fun
- InterB继承InterA
- 主程序创建对象ii，打印NUM、show、fun





> ```java
> public class Test {
>  public static void main(String[] args) {
>      InterImpl ii = new InterImpl();
>      System.out.println(ii.NUM);
>      ii.method();
>      ii.fun();
>      InterA.show();
>  }
> }
> 
> interface InterA{
>  public static final int NUM = 10;
>  public abstract  void  method();
>  public static void show(){
>      System.out.println("show");
>  }
>  public default void fun(){
>      System.out.println("fun");
>  }
> }
> 
> interface InterB extends  InterA{
> 
> }
> 
> class InterImpl extends Object implements InterA,InterB{
>  @Override
>  public void method() {
>      System.out.println("重写后的method");
>  }
> }
> ```
>
> 





- 描述下面代码的作用

- 修改下列代码，用多态的方法，创建一个useAnimal方法，该方法使用父类Animal(或父接口)作为形参，在调用该方法时，可以传递任意的子类对象,实现同样的效果
- 注释在代码上：说明当useAnimal方法接受到形参Dog时，如何发生父类的引用指向子类对象，向上转型（子类变父类）

```java
package com.dem02;

public class Test1 {
    public static void main(String[] args) {
        Dog d = new Dog();
        useDog(d);

        Cat c = new Cat();
        useCat(c);
    }

    public static void useDog(Dog dog){
        dog.shout();
    }
    
    public static void useCat(Cat cat){
        cat.shout();
    }
}

abstract class Animal{
    public abstract void shout();
}

class Dog extends Animal{
    @Override
    public void shout() {
        System.out.println("汪汪叫...");
    }
}

class Cat extends Animal{
    @Override
    public void shout() {
        System.out.println("喵喵叫...");
    }
}
```





> ```java
> 在主程序创建2个动物叫的方法，2个方法分别继承2个不同的类，调用对象实现不同的叫法
> ```
>
> 

> ```java
> package com.dem02;
> 
> public class Test1 {
>     public static void main(String[] args) {
>         Dog d = new Dog();
>         useAnimal(d);
> 
>         Cat c = new Cat();
>         useAnimal(c);
>     }
> 
>     public static void useAnimal(Animal a){// Animal a = new Cat();
>         a.shout();
>     }
> }
> 
> abstract class Animal{
>     public abstract void shout();
> }
> 
> class Dog extends Animal{
>     @Override
>     public void shout() {
>         System.out.println("汪汪叫...");
>     }
> }
> 
> class Cat extends Animal{
>     @Override
>     public void shout() {
>         System.out.println("喵喵叫...");
>     }
> }
> ```
>
> 



查看下列代码，Dog子类中有特有的成员：方法show()，编写代码使其在useAnimal方法中可以调用show方法，并用判断类解决报错。

```java
package com.dem02;

public class Test1 {
    public static void main(String[] args) {
        Dog d = new Dog();
        useAnimal(d);

        Cat c = new Cat();
        useAnimal(c);
    }

    public static void useAnimal(Animal a){// Animal a = new Cat();
        a.shout();
        a.show();
    }
}

abstract class Animal{
    public abstract void shout();
}

class Dog extends Animal{
    @Override
    public void shout() {
        System.out.println("汪汪叫...");
    }
    
    public void show(){
        System.out.println("dog_show");
    }
}

class Cat extends Animal{
    @Override
    public void shout() {
        System.out.println("喵喵叫...");
    }
}
```



> ```java
> package com.dem02;
> 
> public class Test1 {
>     public static void main(String[] args) {
>         Dog d = new Dog();
>         useAnimal(d);
> 
>         Cat c = new Cat();
>         useAnimal(c);
>     }
> 
>     public static void useAnimal(Animal a){// Animal a = new Cat();
>         a.shout();
>         if(a instanceof Dog){
>             Dog dog = (Dog)a; // 子类 对象名 = （子类）父类对象
>             dog.show();
>         }
>     }
> }
> 
> abstract class Animal{
>     public abstract void shout();
> }
> 
> class Dog extends Animal{
>     @Override
>     public void shout() {
>         System.out.println("汪汪叫...");
>     }
> 
>     public void show(){
>         System.out.println("dog_show");
>     }
> }
> 
> class Cat extends Animal{
>     @Override
>     public void shout() {
>         System.out.println("喵喵叫...");
>     }
> }
> ```
>
> 





- 判断：Object类被称为超类，它是所有类的父类

- Object类提供了三个常用的方法

  - toString():打印对象的内存地址
  - equals():比较两个对象的内存地址是否相等
  - hashCode():打印对象内存的哈希码值

  查看下列学生类，用idea快捷方式重写上面的三个个方法，使其完成以下效果

  - toString():打印对象的属性值
  - equals():比较两个对象是否相等
  - hashCode():打印对象哈希码值

```java
package com.dem02;

public class StudentDemo01{
    public static void main(String[] args) {
        Student s1 = new Student("张三",23);
        Student s2 = new Student("张三",23);

        System.out.println(s1.toString());
        System.out.println(s1.equals(s2));
        System.out.println(s1.hashCode());
        System.out.println(s1.hashCode());
    }
}
```

```java
package com.dem02;

public class Student {
    static int age;
    private String name;

    public  Student(){
    }

    public Student(String name,int age){
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;

    }
}
```





> ```java
> package com.dem02;
> 
> public class Student {
>     static int age;
>     private String name;
> 
>     public  Student(){
>     }
> 
>     public Student(String name,int age){
>         this.name = name;
>         this.age = age;
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         this.age = age;
>     }
> 
>     @Override
>     public String toString() {
>         return "Student{" +
>                 "name='" + name + '\'' +
>                 '}';
>     }
> 
>     @Override
>     public boolean equals(Object o) {
>         if (this == o) return true;
>         if (o == null || getClass() != o.getClass()) return false;
> 
>         Student student = (Student) o;
> 
>         return name != null ? name.equals(student.name) : student.name == null;
>     }
> 
>     @Override
>     public int hashCode() {
>         return name != null ? name.hashCode() : 0;
>     }
> }
> ```
>
> 



查看下列代码，如何在主程序中调用run方法

```java
package com.dem02;

public class Car {
    String brand = "奔驰";
    class Engine{
        public void run(){
            System.out.println(brand + "发动机启动了");
        }
    }
}
```



> ```java
> package com.dem02;
> 
> public class CarDemo1 {
>     public static void main(String[] args) {
>         Car.Engine ce = new Car().new Engine();
>         ce.run();
>     }
> }
> 
> ```
>
> 





局部内部类只能在当前类下创建局部内部类对象，查看下列代码，在主程序中调用show方法

```java
package com.dem02;

public class Outer {
    int num = 10;

    public void method(){

            class Inner{
                public void show(){
                    System.out.println("外部类中的num:" + num);
                }
            }
            Inner i = new Inner();
            i.show();
        }
        
    }

```



> ```java
> package com.dem02;
> 
> public class TestDemo {
>     public static void main(String[] args) {
>         Outer o = new Outer();
>         o.method();
>     }
> }
> 
> ```
>
> 





查看下列代码，在主程序中调用静态内部类的show方法，并用两种方法调用静态方法method

```java
package com.dem02;

public class Outer {
    static int num = 10;

    static class Inner{
        public void show(){
            System.out.println(num); //静态的成员只能访问静态内容
        }

        public static void method(){
            System.out.println("method方法执行了");
        }
    }
}

```



> ```java
> package com.dem02;
> 
> public class TestDemo {
>     public static void main(String[] args) {
>         Outer.Inner oi = new Outer.Inner();
>         oi.show();
>         oi.method();
>         Outer.Inner.method();
>     }
> }
> ```



下面代码的实现方式如下：

1. 编写实现类
2. 重写抽象方法
3. 创建实现类对象
4. 将实现类对象作为方法的参数传递

用匿名内部类将前三步化成一步使其能实现下列代码的效果

```java
package com.dem03;

public class Test {
    public static void main(String[] args) {
        Dog dog = new Dog();
        useAnimal(dog);

    } 

    public static void useAnimal(Animal a){
        a.eat();
    }
}

```

```java
package com.dem03;

public class Dog implements Animal{

    @Override
    public void eat() {
        System.out.println("狗吃肉。。。");
    }
}

```

```java
package com.dem03;

public interface Animal {
    public abstract void eat();
};

```



> ```java
> package com.dem03;
> 
> public class Test {
>     public static void main(String[] args) {
>         /*Dog dog = new Dog();
>         useAnimal(dog);*/
>         useAnimal(new Animal() {//new 类名或接口名(){抽象方法}
>             @Override
>             public void eat() {
>                 System.out.println("狗吃肉。。");
>             }
>         });
> 
>     }
> 
>     public static void useAnimal(Animal a){
>         a.eat();
>     }
> }
> 
> ```
>
> ```java
> package com.dem03;
> 
> public interface Animal {
>     public abstract void eat();
> };
> 
> ```
>
> 





Java中大量的异常类都继承自哪个类？



> java.lang.Throwable





查看Throwable类的继承体系



> ![image-20220314231137988](https://i0.hdslb.com/bfs/album/8cee43a99f5d4c3c987737b1f9400dc7c8c74a7b.png)





Throwable类的三个常见方法是什么？



> ![image-20220314231349196](https://i0.hdslb.com/bfs/album/0e8e684e5652f5e03405d4afcf59f5cd52af5aca.png)





修改下列代码，捕获异常。

- 在catch内打印文字提醒"不能除0"，并分别调用Throwable的三个常用方法并注释效果
- 在try-catch下用finally创建一个无论是否异常都会执行的打印值“finally代码块中“，并设法让其不执行

```java
package com.dem03;

public class ExceptionDemo01 {
    public static void main(String[] args) {
        int result = divide(6,0);
        System.out.println(result);
        System.out.println("看看我执行了吗？");
    }
    public static int divide(int x, int y){
        int result = x/y;
        return result;
    }
}

```



> ```java
> package com.dem03;
> 
> public class ExceptionDemo01 {
>     public static void main(String[] args) {
>         try{
>             //有可能出现异常的代码
>             int result = divide(6,0);
>             System.out.println(result);
>             //结束JVM
>             System.exit(0);
>         }catch(ArithmeticException e){
>             System.out.println("不能除0");
> //            System.out.println(e.getMessage()); //获取到异常的简短消息
> //            System.out.println(e.toString());   //获取到异常的类型和消息
>             e.printStackTrace(); //获取异常的类型、消息、位置
>         }finally{
>             //无论是否出现异常，此处的代码都会执行
>             System.out.println("finally代码块中");
> 
>         }
> 
>         System.out.println("看看我执行了吗？");
>     }
>     public static int divide(int x, int y){
>         int result = x/y;
>         return result;
>     }
> }
> 
> ```
>
> 





- 对divide方法抛出算数运算异常，使其能正常运行
- 对divide方法抛出编译时异常，并用idea快捷键创建try-catch，使其能正常运行

```java
package com.dem03;

public class ExceptionDemo01 {
    public static void main(String[] args) {
        int result = divide(6,0);
        System.out.println(result);
        System.out.println("看看我执行了吗？");
    }
    public static int divide(int x, int y){
        int result = x/y;
        return result;
    }
}
```



> ```java
> package com.dem03;
> 
> public class ExceptionDemo01 {
>     public static void main(String[] args) {
>         int result = 0;
>         try {
>             result = divide(6,0);
>         } catch (Exception e) {
>             e.printStackTrace();
>         }
>         System.out.println(result);
>         System.out.println("看看我执行了吗？");
>     }
>     public static int divide(int x, int y) throws Exception{
>         int result = x/y;
>         return result;
>     }
> }
> ```
>
> 

> ```java
> package com.dem03;
> 
> public class ExceptionDemo01 {
>     public static void main(String[] args) {
>         int result = divide(6,0);
>         System.out.println(result);
>         System.out.println("看看我执行了吗？");
>     }
>     public static int divide(int x, int y) throws ArithmeticException{
>         int result = x/y;
>         return result;
>     }
> }
> ```
>
> 



Exception是所有编译时异常的父类，除了哪个类



> RuntimeException



所有运行时异常的父类时那个类？



> RuntimeException



- 修改下列代码，使得在编译时，当y为0时，抛出一个定义DivideException异常类的对象，异常信息为“不能除0”。
- 修改代码，使得在运行时抛出异常 

```java
package com.dem03;

public class ExceptionDemo01 {
    public static void main(String[] args) {
        int result = divide(6,0);
        System.out.println(result);
        System.out.println("看看我执行了吗？");
    }
    public static int divide(int x, int y){
        int result = x/y;
        return result;
    }
}
```



> ```java
> package com.dem03;
> 
> public class ExceptionDemo01 {
>     public static void main(String[] args) {
>         int result = 0;
>         try {
>             result = divide(6,0);
>         } catch (DivideException e) {
>             e.printStackTrace();
>         }
>         System.out.println(result);
>         System.out.println("看看我执行了吗？");
>     }
>     public static int divide(int x, int y) throws DivideException{
>         if(y == 0){
>             throw new DivideException("不能除0");
>         }
>         int result = x/y;
>         return result;
>     }
> }
> ```
>
> ```java
> package com.dem03;
> 
> public class DivideException extends Exception{
>     public DivideException() {
>     }
> 
>     public DivideException(String message) {
>         super(message);
>     }
> }
> ```
>
> 

> ```java
> package com.dem03;
> 
> public class ExceptionDemo01 {
>     public static void main(String[] args) {
>         int result = divide(6,0);;
>         System.out.println(result);
>         System.out.println("看看我执行了吗？");
>     }
>     public static int divide(int x, int y) /*throws DivideException*/{
>         if(y == 0){
>             throw new DivideException("不能除0");
>         }
>         int result = x/y;
>         return result;
>     }
> }
> ```
>
> ```java
> package com.dem03;
> 
> public class DivideException extends RuntimeException{
>     public DivideException() {
>     }
> 
>     public DivideException(String message) {
>         super(message);
>     }
> }
> #:会报错
> ```
>
> 





案例：打印一个边长为5的正方形和半径为5的圆

- 创建父类yPrint类，包含show0）方法，用于输出图形的形状
- 创建子类MyPrintSquare类，重写show 0方法，用“*”打印出边长为5的正方形。*
- 创建子类MyPrintCircle类，重写show O方法，用“*”打印出半径为5的圆。
- 创建测试类，设计一个myshow（MyPrint a）方法，实现输出的功能：如果为MyPrintSquare，输出边长为5的正方形，如果为MyPrintCircle对象，输出半径为5的圆；主函数中创建
  MyPrintSquare、MyPrintCircle的对象，分别调用myshow，检查输出结果。



> ```java
> package com.demo04;
> 
> public abstract class MyPrint {
>     public abstract void show();
> }
> 
> ```
>
> ```java
> package com.demo04;
> 
> public class MyPrintSquare extends MyPrint{
> 
>     @Override
>     public void show() {
>         for (int i = 0; i < 5; i++) {
>             for (int j = 0; j < 5; j++) {
>                 if(j == 0 || i == 4){
>                     System.out.println("*");
>                 }else if(i == 0 || i == 4){
>                     System.out.println("*");
>                 }else{
>                     System.out.println(" ");
>                 }
>             }
>             System.out.println();
>         }
>     }
> }
> 
> ```
>
> ```java
> package com.demo04;
> 
> public class MyPrintCricle extends MyPrint{
> 
> 
>     @Override
>     public void show() {
>         for(int y = 0; y <= 10; y += 2){
>             int x = (int)Math.round(5 - Math.sqrt(10 * y - y * y));
>             int len = 2 * (5 -x);
>             for(int i = 0; i <= x; i++){
>                 System.out.println(" ");
>             }
>             System.out.println("*");
>             for(int j = 0; j <= len; j++){
>                 System.out.println(" ");
>             }
>             System.out.println("*");
>         }
>     }
> }
> 
> ```
>
> ```java
> package com.demo04;
> 
> public class Test {
>     public static void main(String[] args) {
>         useMyPrint(new MyPrintSquare());
>         useMyPrint(new MyPrintCricle());
>     }
>     public static void useMyPrint(MyPrint my){
>         my.show();
>     }
> }
> 
> ```
>
> 





案例：用抽象类的知识设计一个程序，可以根据输入计算不同图形的面积和周长。

- shape父类：获取getArea和getPerimeter两个抽象方法
- Cricle子类：用于计算圆的周长和面积
- Rectangle子类：计算矩形的周长和面积
- shaprCaulate类：用于打印周长或面积
- Test类：实现主程序的调用



> ```java
> package com.demo05;
> 
> public abstract class Shape {
>     public abstract double getArea();
>     public abstract double getPerimeter();
> 
> }
> 
> ```
>
> ```java
> package com.demo05;
> 
> public class Cricle extends Shape{
>     private double radius;
>     private final double PI = 3.14;
> 
>     public Cricle(double radius) {
>         this.radius = radius;
>     }
> 
>     @Override
>     public double getArea() {
>         return radius * radius * PI;
>     }
> 
>     @Override
>     public double getPerimeter() {
>         return 2 * radius * PI;
>     }
> }
> 
> ```
>
> ```java
> package com.demo05;
> 
> public class Rectangle extends Shape{
>     private double length;
>     private double width;
> 
>     public Rectangle(double length, double width) {
>         this.length = length;
>         this.width = width;
>     }
> 
>     @Override
>     public double getArea() {
>         return length * width;
>     }
> 
>     @Override
>     public double getPerimeter() {
>         return (length + width) * 2;
>     }
> }
> 
> ```
>
> ```java
> package com.demo05;
> 
> public class ShapeCaculate {
>     public void calArea(Shape shape){
>         System.out.println(shape.getArea());
>     }
> 
>     public void calPerimeter(Shape shape){
>         System.out.println(shape.getPerimeter());
>     }
> }
> 
> ```
>
> ```java
> package com.demo05;
> 
> public class Test {
>     public static void main(String[] args) {
>         ShapeCaculate sc = new ShapeCaculate();
> 
>         Cricle cricle = new Cricle(4);
>         System.out.println("圆形的面积：");
>         sc.calArea(cricle);
>         System.out.println("圆形的周长：");
>         sc.calPerimeter(cricle);
> 
>         Rectangle rectangle = new Rectangle(4,5);
>         System.out.println("长方形的面积：");
>         sc.calArea(rectangle);
>         System.out.println("长方形的周长：");
>         sc.calPerimeter(rectangle);
> 
>     }
> }
> 
> ```
>
> 





案例：设计一个研究生薪资管理系统

（l）定义两个接口，在StudentManageInterface接口中声明两个方法：getFee()和setFee()，用于设置和获取学生的学费；在TeacherManageInterface接口中声明两个方法：gePay（）和setPay()，用于设置和获取教师的工资。
（2）定义主类Graduate，分别实现StudentManageInterface和TeacherManageInterface接口。
（3）定义Graduate类的成员变量，和构造方法。
（4）给出四个接口方法的实现。
（5）给出一个计算是否需要贷款的方法，在里面统计年收入和学费，并输出是否需要贷款的信息。
（6）在main0方法中创建一个姓名为“zhangsan”的研究生，调用计算是否需要贷款的方法。



> ```java
> package com.demo06;
> 
> public interface StudentManageInterface {
>     public abstract void setFee(double fee);
>     public abstract double getFee();
> }
> ```
>
> ```java
> package com.demo06;
> 
> public interface TeacherManageInterface {
>     public abstract void setPay(double pay);
>     public abstract double getPay();
> }
> 
> ```
>
> ```java
> package com.demo06;
> 
> public class Graduate implements StudentManageInterface,TeacherManageInterface{
>     private String name;
>     private int age;
>     private String sex;
>     private double pay;
>     private double fee;
> 
>     public Graduate(String name, int age, String sex, double pay, double fee) {
>         this.name = name;
>         this.age = age;
>         this.sex = sex;
>         this.pay = pay;
>         this.fee = fee;
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         this.age = age;
>     }
> 
>     public String getSex() {
>         return sex;
>     }
> 
>     public void setSex(String sex) {
>         this.sex = sex;
>     }
> 
>     @Override
>     public double getPay() {
>         return pay;
>     }
> 
>     @Override
>     public void setPay(double pay) {
>         this.pay = pay;
>     }
> 
>     @Override
>     public double getFee() {
>         return fee;
>     }
> 
>     @Override
>     public void setFee(double fee) {
>         this.fee = fee;
>     }
> }
> 
> ```
>
> ```java
> package com.demo06;
> 
> public class Test {
>     public static void main(String[] args) {
>         Graduate g = new Graduate("张三",23,"男",8000,3000);
>         if(g.getPay()*12 - g.getFee()*12 < 2000){
>             System.out.println("需要贷款");
>         }else{
>             System.out.println("不需要贷款");
>         }
> 
>     }
> }
> 
> ```
>
> 

















## API

下面是String的5种初始化方式，写出运行结果

```java
package com.demo07;

public class StringDemo01 {
    public static void main(String[] args) {
        String s1 = new String();
        System.out.println();

        String s2 = new String("abc");
        System.out.println(s2);

        char[] cArr = {'H','e','l','l','o'};
        String s3 = new String(cArr);
        System.out.println(s3);

        byte[] bArr = {97, 98, 99, 100};
        String s4 = new String(bArr);
        System.out.println(s4);

        String s = "abc";
        System.out.println(s);

    }
}
```



>```java
>
>abc
>hello
>abcd
>abc
>```
>
>



下面是String类常见的方法：判断功能，写出下列程序的运行结果

```java
public class StringDemo01 {
    public static void main(String[] args) {
        String str = "HelloWorld";
        System.out.println(str.equals("HelloWorld"));
        System.out.println(str.equalsIgnoreCase("helloworld"));
        System.out.println(str.startsWith("H"));
        System.out.println(str.endsWith("ld"));
        System.out.println(str.contains("ll"));
        
    }
}
```



> true
>
> true
>
> true
>
> ture





- 下面是String类常见的方法：获取功能，写出下列程序的运行结果

- 如果indexOf获取不到索引位置，会返回什么

```java
package com.demo07;

public class StringDemo01 {
    public static void main(String[] args) {
        String str = "HelloWorld";

        int length = str.length();
        System.out.println(length);

        char c = str.charAt(1);
        System.out.println(c);

        int index1 = str.indexOf("l");
        System.out.println(index1);

        int index2 = str.lastIndexOf("l");
        System.out.println(index2);

        String s1 = str.substring(5);
        System.out.println(s1);

        String s2 = str.substring(2, 5);
        System.out.println(s2);
    }
}

```



> 10
>
> e
>
> 2
>
> 8
>
> World
>
> llo

> -1





下面是String类常见的方法：转换功能，写出下列程序的运行结果

```java
package com.demo07;

public class StringDemo01 {
    public static void main(String[] args) {
        String str = "HelloWorld";

        char[] cArr = str.toCharArray();
        for (int i = 0; i < cArr.length; i++) {
            System.out.print(cArr[i]);
        }
        System.out.println();

        byte[] bArr = str.getBytes();
        for (int i = 0; i < bArr.length; i++) {
            System.out.print(bArr[i]+" ");
        }
        System.out.println();

        String s1 = str.replace("o","A");
        System.out.println(s1);

        String s2 = str.toUpperCase();
        System.out.println(s2);

        String s3 = str.toLowerCase();
        System.out.println(s3);

        String s4 = String.valueOf(10); // 转换类型
        System.out.println(s4);

    }
}

```



> HelloWorld
> 72 101 108 108 111 87 111 114 108 100 
> HellAWArld
> HELLOWORLD
> helloworld
> 10



下面是String类的两个常见方法，写出下列程序的运行结果

```java
package com.demo07;

public class StringDemo01 {
    public static void main(String[] args) {
        String str = "张三,23,男";

        String[] arr = str.split(",");
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }

        System.out.println("   Hello  World   ".trim());
    }
}

```



> 张三
> 23
> 男
> Hello  World



下面是SringButter类的一些方法，写出运行结果

```java
package com.demo07;

public class StringDemo01 {
    public static void main(String[] args) {
        StringBuffer sb = new StringBuffer();

        sb.append("a");
        sb.append("b");
        sb.append("c");
        System.out.println(sb);

        sb.insert(0,"d");
        System.out.println(sb);

        sb.deleteCharAt(0);
        System.out.println(sb);

        sb.delete(0,1);
        System.out.println(sb);

        sb.replace(0,2,"pp");
        System.out.println(sb);

        sb.setCharAt(0,'o');
        System.out.println(sb);

        sb.reverse();
        System.out.println(sb);

        String str = sb.toString();
        System.out.println(str);


    }
}
```



>abc
>dabc
>abc
>bc
>pp
>op
>po
>po



- StringBuilder类和StringButter类的最大不同点是什么

- 相同点又是什么



> 线程不同步

> 内容可变的字符串缓冲区，提高操作数据的效率



查看下列代码，问为什么string类拼接字符那么慢

```java
package com.demo07;

public class StringDemo01 {
    public static void main(String[] args) {
        testString(); //127ms
        testStringBuffer(); //7ms,安全
        testStringBuilder(); //1ms
    }

    private static void testStringBuilder() {
        long start = System.currentTimeMillis();

        StringBuilder sb = new StringBuilder();
        for (int i = 0; i <= 10000; i++) {
            sb.append(i);
        }
        System.out.println(sb);

        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }

    private static void testStringBuffer() {
        long start = System.currentTimeMillis();

        StringBuffer sb = new StringBuffer();
        for (int i = 0; i <= 10000; i++) {
            sb.append(i);
        }
        System.out.println(sb);

        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }

    private static void testString() {
        long start = System.currentTimeMillis();

        String str = "";
        for (int i = 0; i <= 10000; i++) {
            str += i;
        }
        System.out.println(str);

        long end = System.currentTimeMillis();
        System.out.println(end - start);
    }
}
```



> 字符串是常量，创建后数据值就不能发生改变
>
> #：![image-20220319115901077](https://i0.hdslb.com/bfs/album/58aeca694ba91b5ec68a0e729800731c31f2bdbd.png)





查看下面System类的方法



```java
package com.demo07;

import java.util.Properties;

public class StringDemo01 {
    public static void main(String[] args) {
//        long time = System.currentTimeMillis(); // 获取当前系统时间（单位毫秒）
//        System.out.println(time);

//        System.exit(0); //退出JVM，非0表示异常终止
//        System.out.println("看看我执行了吗");

//        Person p1 = new Person();
//        Person p2 = new Person();
//        p1 = null;
//        p2 = null;
//        System.gc();// java会自动回收内存垃圾,所以用不到

        Properties prop = System.getProperties(); // 获取当前的系统属性，返回值是双类集合：属性名和属性值
        System.out.println(prop);

    }
}

class Person{
    public void finalize(){
        System.out.println("对象被回收了……");
    }
}

```





查看下面runtime类的常用方法

```java
package com.demo07;

import java.util.Properties;

public class StringDemo01 {
    public static void main(String[] args) {
        Runtime rt = Runtime.getRuntime();
//        rt.exec("notepad.exe"); //执行系统dos命令

//        long l = rt.freeMemory();// 获取虚拟机空闲内存
//        System.out.println(l);

//        long l1 = rt.maxMemory();// 获取虚拟机最大可用内存
//        System.out.println(l1);

//        long l = rt.totalMemory();// 获取虚拟机总内存
//        System.out.println(l);
        
        int i = rt.availableProcessors(); //获取虚拟机处理器个数
        System.out.println(i);


    }
}


```



查看下面Math类的常用方法

```java
package com.demo07;

import java.util.Properties;

public class StringDemo01 {
    public static void main(String[] args) {
        System.out.println(Math.abs(-10));
        System.out.println(Math.ceil(8.6)); //向上取整
        System.out.println(Math.floor(8.6)); //向下取整
        System.out.println(Math.round(8.6)); //四舍五入
        System.out.println(Math.max(8,9));
        System.out.println(Math.min(8,9));
        System.out.println(Math.sqrt(9));
        System.out.println(Math.pow(9,2)); //9的2次方
        System.out.println(Math.random()); //获取0.0～1.0之间的小数（不包含1.0)
    }
}

```





查看下面的random类的常用方法

```java
package com.demo07;

import java.util.Properties;
import java.util.Random;

public class StringDemo01 {
    public static void main(String[] args) {
        Random r = new Random(5); //根据系统时间随机生成，加上5就是固定的随记数种子
        int num = r.nextInt(10) + 1;//1～10之间
        System.out.println(num);
        double num2 = r.nextDouble(); //类似于Math.random
        System.out.println(num2);
        
    }
}
```





查看下面日期时间类：Instant类、LocalDate类（年月日）、LocalTime类（时分秒）、LocalDateTime(年月日时分秒,优先）、Duration类（时间间隔）、Period类（日期间隔）的常用方法,时间元年是哪天

```java
package com.demo07;

import java.time.Instant;

public class StringDemo01 {
    public static void main(String[] args) {
        Instant instant1 = Instant.now(); //根据当前系统时间获取对象
        System.out.println(instant1); //北半球+8小时 T：分隔符 Z:世界标准时间

        Instant instant2 = Instant.ofEpochSecond(60); //指定从时间元年开始过了60s
        System.out.println(instant2);

        Instant instant3 = Instant.ofEpochMilli(1000 * 60); // 指定从时间元年开始过了 1000 * 60s
        System.out.println(instant3);

        Instant instant4 = Instant.parse("1970-01-01T00:00:01.1Z"); // 根据输入的字符串时间获取对象
        System.out.println(instant4);// .1Z是十分之一秒

        Instant instant5 = Instant.from(instant4); // 根据指定时间获取对象
        System.out.println(instant5);

        long second = instant5.getEpochSecond(); // 获取秒数
        System.out.println(second);

        int nano = instant5.getNano(); // 抛开整秒数不算，获取纳秒
        System.out.println(nano);


    }
}


```



```java
package com.demo07;

import java.time.Instant;
import java.time.LocalDate;
import java.time.format.DateTimeFormatter;

public class StringDemo01 {
    public static void main(String[] args) {
//        method01();
//        method02();
//        method03();
//        method04();
//        method05();

        method06();


    }

    private static void method06() {
        //        6.直接修改日期
        LocalDate ld = LocalDate.of(2088, 8, 8);
        System.out.println(ld.withYear(2099)); //修改成2099年
        System.out.println(ld.withMonth(10));
        System.out.println(ld.withDayOfMonth(10));
    }

    private static void method05() {
        //        5.增加或减少日期
        LocalDate ld = LocalDate.of(2088, 8, 8);
        System.out.println(ld.minusYears(1)); // 减少或增加年（与plus相反 正数减，负数家
        System.out.println(ld.minusMonths(2)); //
        System.out.println(ld.minusDays(3)); //
    }

    private static void method04() {
        //        4.增加或减少日期
        LocalDate ld = LocalDate.of(2088, 8, 8);
        LocalDate ld2 = ld.plusYears(1); // 增加1年（正数向后加，负数向前减)
        System.out.println(ld2 );

        LocalDate ld3 = ld.plusMonths(2); //增加2个月
        System.out.println(ld3);

        LocalDate ld4 = ld.plusDays(-4); // 减少4天
        System.out.println(ld4);
    }

    private static void method03() {
        //        3.判断相关
        LocalDate ld1 = LocalDate.of(2088, 8, 8);
        LocalDate ld2 = LocalDate.of(2089, 9, 9);
        System.out.println(ld1.isBefore(ld2)); // 判断是否在指定日期之前

        System.out.println(ld1.isAfter(ld2)); // 判断是否在指定日期之前

        System.out.println(ld1.isEqual((ld2))); // 是否相等

        System.out.println(ld1.isLeapYear()); // 判断是否是闰年
    }

    private static void method02() {
        // 2、获取日期字段
        LocalDate ld = LocalDate.of(2088, 8, 8);
        int year = ld.getYear(); // 获取年份
        System.out.println(year);

        System.out.println(ld.getMonthValue()); //获取月份

        System.out.println(ld.getDayOfMonth()); // 获取日期
    }

    private static void method01() {
        // 1、获取日期对象
        LocalDate ld1 = LocalDate.now(); // 根据当前系统时间获取日期对象年月日
        System.out.println(ld1);

        LocalDate ld2 = LocalDate.parse("2088-08-08"); //根据指定字符串获取对象
        System.out.println(ld2);

        LocalDate ld3 = LocalDate.of(2088, 8, 8); //根据指定年月日获取日期对象
        System.out.println(ld3);

        DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy年MM月dd日"); //指定日期格式 yMd字母是固定的
        String format = ld3.format(pattern);
        System.out.println(format);
    }
}
```



```java
package com.demo07;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

public class StringDemo01 {
    public static void main(String[] args) {
        LocalTime time1 = LocalTime.now();
        System.out.println(time1);

        LocalTime time2 = LocalTime.of(10, 10, 10);
        System.out.println(time2);

        DateTimeFormatter pattern = DateTimeFormatter.ofPattern("HH时mm分钟ss秒");
        String format = time2.format(pattern);
        System.out.println(format);

        System.out.println(time2.getHour());

        System.out.println(time2.plusMinutes(1));




    }
}
```





```java
package com.demo07;

import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.LocalTime;
import java.time.format.DateTimeFormatter;

public class StringDemo01 {
    public static void main(String[] args) {
        LocalDateTime ldt1 = LocalDateTime.now();
        System.out.println(ldt1);

        LocalDateTime ldt2 = LocalDateTime.of(2088, 8, 8, 10, 10, 10, 10);
        System.out.println(ldt2);

        DateTimeFormatter pattern = DateTimeFormatter.ofPattern("yyyy年MM月dd日 HH:mm:ss");
        String format = ldt2.format(pattern);
        System.out.println(format);

        System.out.println(ldt2.getDayOfMonth());

        LocalDate ld = ldt2.toLocalDate();
        System.out.println(ld);

        LocalTime lt = ldt2.toLocalTime();
        System.out.println(lt);


    }
}
```



```java
package com.demo07;

import java.time.Duration;
import java.time.LocalDateTime;
import java.time.LocalTime;

public class StringDemo01 {
    public static void main(String[] args) {
        LocalTime time1 = LocalTime.of(9,9,9);
        LocalTime time2 = LocalTime.of(9,9,9);
        Duration duration = Duration.between(time1, time2);

        System.out.println(duration.toHours()); //间隔小时
        System.out.println(duration.toMinutes());
        System.out.println(duration.toSeconds());
        System.out.println(duration.toMillis()); //毫秒
        System.out.println(duration.toNanos()); //纳秒

    }
}
```



```java
package com.demo07;

import java.time.LocalDate;
import java.time.Period;

public class StringDemo01 {
    public static void main(String[] args) {
        LocalDate d1 = LocalDate.of(2088,8,8);
        LocalDate d2 = LocalDate.of(2089,9,9);

        Period period = Period.between(d1, d2);

        System.out.println(period.getYears()); // 间隔年数
        System.out.println(period.getMonths());
        System.out.println(period.getDays());

    }
}
```





> 1970年1月1号 0点0分0秒





写出int类、char类和double类对应的包装类？



> Interger、Character、Double



查看下列包装类的常用方法

```java
package com.demo07;

public class StringDemo01 {
    public static void main(String[] args) {
        // 字符转int
        Integer i1 = Integer.valueOf("20");// 字符串只能是数字，不能是字母
        System.out.println(i1);

        // Integer转int
        int num = i1.intValue();
        System.out.println(num);

        // 每个包装类都有的parse方法
        int num2 = Integer.parseInt("100"); //转int
        System.out.println(num2);

        double num3 = Double.parseDouble("5.5");
        System.out.println(num3);
    }

```





查看下列元字符的功能

![image-20220321220130179](https://i0.hdslb.com/bfs/album/2c2f7e01b5c16c78a298d921d4f11e35bb839a7e.png)

![image-20220321220238716](https://i0.hdslb.com/bfs/album/954fbfd29d349f0f3919e889382e2b5de2f9cebc.png)





使用正则的patten类完成下列要求

- 对手机号 186888899 进行匹配。要求：第一个字母必须是1开头，整体长度11。
- 对字符串 “我的名字是张三 我的手机号是10010  我的性别是男”按至少一个空格的规则进行分割。



> ```java
> package com.demo07;
> 
> 
> import java.util.regex.Pattern;
> 
> public class StringDemo01 {
>     public static void main(String[] args) {
>         boolean b = Pattern.matches("[1][\\d]{10}", "18688889999");
>         System.out.println(b);
> 
>         Pattern patten = Pattern.compile(" +");
>         String[] arr = patten.split("我的名字是张三 我的手机号是10010  我的性别是男");
>         for (int i = 0; i < arr.length; i++) {
>             System.out.println(arr[i]);
> 
>         }
> 
> 
>     }
> }
> ```





查看下列正则的matcher类的常用方法

```java
package com.demo07;

import java.util.regex.Matcher;
import java.util.regex.Pattern;

public class StringDemo01 {
    public static void main(String[] args) {
        Pattern p = Pattern.compile("\\d+");
        Matcher m1 = p.matcher("a10010a");

        System.out.println(m1.matches()); // 字符串是否完全匹配
        System.out.println(m1.lookingAt()); // 开头是否匹配
        System.out.println(m1.find()); // 是否有任意满足
        System.out.println(m1.start()); // 满足要求第一次出现的索引位置
        System.out.println(m1.end()); // 最后一次出现索引的下一个索引编号
        System.out.println(m1.group()); // 满足要求的部分字符串
        
    }
}
```



查看下列String类对正则支持的方法

```java
package com.demo07;


public class StringDemo01 {
    public static void main(String[] args) {
        String tel = "18688889999";
        boolean b = tel.matches("[1][\\d]{10}");
        System.out.println(b);

        String s1 = "我1叫2张3三";
        String s2 = s1.replaceAll("\\d+", "");//去掉数字
        System.out.println(s2);
        
        String s3 = "我叫张三   我的年龄是32  我的手机号是10010";
        String[] arr = s3.split(" +");
        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);

        }
    }
}
```





反转字符串 name = "itheima";



> ```java
> package com.demo07;
> 
> 
> public class StringDemo01 {
>     public static void main(String[] args) {
>         String name = "itheima";
>         String str = "";
>         for(int i = name.length()-1; i >= 0; i--){
>             str += name.charAt(i);
>         }
>         System.out.println(str);
>     }
> }
> ```







将键盘录入的字符串转换成二进制

- 转换时用长度为4的二维数组遍历表示
- char转int：-48
- int转二进制：ch / Math.pow(2, 3-j) % 2



>```java
>package com.demo07;
>
>
>import java.util.Scanner;
>
>public class StringDemo01 {
>    public static void main(String[] args) {
>        Scanner sc = new Scanner(System.in);
>        System.out.println("请输入字符串");
>        String str = sc.nextLine();
>
>        int[][] arr = new int[str.length()][4];
>
>        for(int i = 0; i < str.length(); i++){
>            int ch = str.charAt(i)- 48;
>            for (int j = 0; j < 4; j++) {
>                arr[i][j] = (int)(ch / Math.pow(2, 3-j) % 2);
>            }
>        }
>
>        System.out.println("二进制结果为");
>        for (int i = 0; i < arr.length; i++){
>            for (int j = 0; j < arr[i].length; j++) {
>                System.out.print(arr[i][j]);
>            }
>        }
>
>    }
>}
>```
>
>







输入年数，用时间日期类判断二月有28天还是29天（29为闰年，4年一次）



> ```java
> package com.demo07;
> 
> 
> import java.time.LocalDate;
> import java.util.Scanner;
> 
> public class StringDemo01 {
>     public static void main(String[] args) {
>         Scanner sc = new Scanner(System.in);
>         System.out.println("请输入要查询的年份：");
>         int year = sc.nextInt();
> 
>         LocalDate ld = LocalDate.of(year,3,1);
>         LocalDate ld2 = ld.plusDays(-1);
> 
>         System.out.println(year + "年的2月份有：" + ld2.getDayOfMonth() + "天");
>     }
> }
> ```



## 集合

查看下列集合类的继承关系，说明List和Set的区别

![image-20220324001435270](https://i0.hdslb.com/bfs/album/fd9b5f3486242997666ec2d74f618f110e968153.png)



> List元素有序、可重复。Set元素无序、不可重复



查看下列 collection类 的常用方法

```java
package com.demo07;


import java.time.LocalDate;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Scanner;

public class StringDemo01 {
    public static void main(String[] args) {
        //添加元素
        Collection<String> c1 = new ArrayList<>();//String 泛型：约束集合可以存储数据的类型
        c1.add("aa");
        c1.add("bb");
        c1.add("cc");
        System.out.println(c1);

        //将指定集合中所有元素添加到当前集合
        Collection<String> c2 = new ArrayList<>();
        c2.add("dd");
        c2.add("ee");
        c1.addAll(c2);
        System.out.println(c1);

        //删除指定的元素
        System.out.println(c1.remove("aa"));
        System.out.println(c1);

        //删除全部元素
        System.out.println(c1.removeAll(c2));
        System.out.println(c1);

        //判断元素是否为空
        System.out.println(c1.isEmpty()); //False

        //判断集合是否包含指定的元素
        System.out.println(c1.contains("cc")); //True

        //判断集合中是否包含指定集合所有元素
        System.out.println(c1.containsAll(c2));

        //获取集合的长度
        System.out.println(c1.size());

        //清空集合
        c1.clear();
        System.out.println(c1);

    }
}
```





List是Collection集合的子接口，继承了Collection的全部方法，查看下面list特有的根据元素索引操作结合的方法

```java
package com.demo08;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

public class StringDemo02{
    public static void main(String[] args) {
        List<String> list = new ArrayList<>();
        list.add("bb");
        list.add("cc");

        //向索引0位置添加元素"aa" 索引不可越界>1
        list.add(0,"aa");
        System.out.println(list);

        //将指定集合list2到元素添加到当前集合指定索引0位置
        List<String> list2 = new ArrayList<>();
        list2.add("dd");
        list2.add("ee");
        list.addAll(0,list2);
        System.out.println(list);

        //获取指定索引处到元素
        System.out.println(list.get(0));

        //删除指定索引处到元素，返回被删除到元素
        System.out.println(list.remove(0));
        System.out.println(list);

        //修改指定索引处到元素，返回被修改到元素
        System.out.println(list.set(0,"qq"));
        System.out.println(list);

        //查询指定元素第一次出现到索引位置
        System.out.println(list.indexOf("qq"));

        //查询指定元素最后一次出现到索引位置
        list.add("qq");
        System.out.println(list.lastIndexOf("qq"));

        //获取指定索引范围（开始索引，结束索引+1(不包含+1）到集合元素，返回新的集合
        System.out.println(list);
        List<String> newList = list.subList(1, 3);
        System.out.println(newList);


    }

}
```





ArrayList是List接口的一个实现类，可以看作一个长度可变的数组，查看下面它的特点

```java
package com.demo08;

import java.util.ArrayList;
import java.util.List;
import java.util.Scanner;

/*
ArrayList特点：
    底层是数组结构实现的，数组有索引、查询速度比较快，增删比较慢。
    使用场景：如果大量的数据经常做查询的操作、优先使用ArrayList
*/


public class StringDemo02{
    public static void main(String[] args) {
        ArrayList<String>list = new ArrayList<>();

        //可以存储重复数据
        list.add("张三");
        list.add("张三");
        list.add("李四");
        list.add("王五");
        list.add("赵六");

        //存取有序
        System.out.println(list);

        int size = list.size();
        System.out.println(size);

        String name = list.get(2);
        System.out.println(name);


    }

}
```



LinkedList是链表结构，相对于数组增删更具效率，查看下列LinkList的特有方法

```java
package com.demo08;

import java.util.ArrayList;
import java.util.LinkedList;
import java.util.List;
import java.util.Scanner;

/*
ArrayList特点：
    底层是数组结构实现的，数组有索引、查询速度比较快，增删比较慢。
    使用场景：如果大量的数据经常做查询的操作、优先使用ArrayList
*/


public class StringDemo02{
    public static void main(String[] args) {

        LinkedList<String> list = new LinkedList<>();

        list.add("张三");
        list.add("李四");
        list.add("王五");

        list.addFirst("赵六");
        System.out.println(list);

        list.addLast("周七");
        System.out.println(list);

        String first = list.getFirst();
        System.out.println(first);

        String last = list.getLast();
        System.out.println(last);

        System.out.println(list.removeFirst());
        System.out.println(list.removeLast());
        System.out.println(list);



    }

}
```





- set集合没有索引，如何实现遍历

- 查看下列Iterator接口 迭代器通用的遍历方式



> 迭代器

> ```java
> package com.demo08;
> 
> import java.util.ArrayList;
> import java.util.Iterator;
> 
> public class IteratorDemo05 {
>     public static void main(String[] args) {
>         ArrayList<String> list = new ArrayList<>();
>         list.add("张三");
>         list.add("李四");
>         list.add("王五");
> 
>         Iterator<String> it2 = list.iterator();
>         while(it2.hasNext()){
>             String str = it2.next();
>             if("张三".equals(str)){
>                 //list.remove(str); // ConcurrentModificationException 并发修改异常
>                 it2.remove();
>             }
>         }
> 
> 
>         //用迭代器通用遍历方式
>         Iterator<String> it = list.iterator();
>         while(it.hasNext()){ //判断是否还有元素
>             String str = it.next();
>             System.out.println(str);
>         }
> 
> 
>         //list常规遍历
>         for (int i = 0; i < list.size(); i++) {
>             String s = list.get(i);
>             System.out.println(s);
>         }
> 
>     }
> 
> }
> ```





- 用增强for循环 foreach循环，遍历下面的单列集合list 和 数组arr

```java
package com.demo08;

import java.util.ArrayList;

public class ForeachDemo {
    public static void main(String[] args) {
        ArrayList<String> list = new ArrayList<>();
        list.add("张三");
        list.add("李四");
        list.add("王五");
        
        int[] arr = {10, 20, 30};
        
        
        
    }
}
```



> ```java
> package com.demo08;
> 
> import java.util.ArrayList;
> 
> public class ForeachDemo {
>     public static void main(String[] args) {
>         ArrayList<String> list = new ArrayList<>();
>         list.add("张三");
>         list.add("李四");
>         list.add("王五");
> 
>         int[] arr = {10, 20, 30};
> 
>         for (String str : list) {
>             System.out.println(str);
>             str = "qq"; // 第三方变量不影响原数组
>         }
>         System.out.println(list);
> 
> 
>         for (int num : arr) {
>             System.out.println(num);
>           
>           
>         }
>     }
> }
> ```





- HashSet是以什么存储，TreeSet是以什么存储



> 哈希值、二叉树





- 查看下列代码的运行结果，可以知道HashSet集合的有哪三个特性

```java
package com.demo08;

import java.util.HashSet;

public class HashSetDemo01 {
    public static void main(String[] args) {
        HashSet<String> hs = new HashSet<>();
        hs.add("张三");
        hs.add("张三");
        hs.add("李四");
        hs.add("王五");
        hs.add("赵六");

        for (String s : hs) {
            System.out.println(s);
        }

    }
}
```



> 没有索引、不能存储重复元素、元素存储无序





- 修改下列代码，重写 hashCode()和equals() 方法在Student类中使自定义类型的对象保存到HashSet集合中，不重复。

```java
package com.demo08;

import java.util.HashSet;

public class HashSetDemo02 {
  //注意，如果是自定义类型的对象，保存到HashSet集合，必须重写hashCode()和equals()方法
    public static void main(String[] args) {
        HashSet<Student> hs = new HashSet<>();
        Student s1 = new Student("张三",23);
        Student s2 = new Student("张三",23);
        Student s3 = new Student("李四",24);
        Student s4 = new Student("王五",25  );

        hs.add(s1);
        hs.add(s2);
        hs.add(s3);
        hs.add(s4);

        for (Student student : hs) {
            System.out.println(student);
        }


    }

}
```

```java
package com.demo08;

public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



> ```java
> package com.demo08;
> 
> public class Student {
>     private String name;
>     private int age;
> 
>     public Student() {
>     }
> 
>     public Student(String name, int age) {
>         this.name = name;
>         this.age = age;
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         this.age = age;
>     }
> 
>     @Override
>     public boolean equals(Object o) {
>         if (this == o) return true;
>         if (o == null || getClass() != o.getClass()) return false;
> 
>         Student student = (Student) o;
> 
>         if (age != student.age) return false;
>         return name != null ? name.equals(student.name) : student.name == null;
>     }
> 
>     @Override
>     public int hashCode() {
>         int result = name != null ? name.hashCode() : 0;
>         result = 31 * result + age;
>         return result;
>     }
> 
>     @Override
>     public String toString() {
>         return "Student{" +
>                 "name='" + name + '\'' +
>                 ", age=" + age +
>                 '}';
>     }
> }
> 
> ```
>
> 





- 修改下列代码，用HashSet的子类保证元素读取有序

```java
package com.demo08;

import java.util.HashSet;

public class HashSetDemo02 {
  //注意，如果想要保证元素读取顺序，可以使用LinkedHashSet集合
    public static void main(String[] args) {
        HashSet<Student> hs = new HashSet<>();
        Student s1 = new Student("张三",23);
        Student s2 = new Student("张三",23);
        Student s3 = new Student("李四",24);
        Student s4 = new Student("王五",25  );

        hs.add(s4);
        hs.add(s2);
        hs.add(s3);
        hs.add(s1);

        for (Student student : hs) {
            System.out.println(student);
        }


    }

}
```

```java
package com.demo08;

public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



> ```java
> package com.demo08;
> 
> import java.util.HashSet;
> import java.util.LinkedHashMap;
> import java.util.LinkedHashSet;
> import java.util.LinkedList;
> 
> public class HashSetDemo02 {
>     public static void main(String[] args) {
> 
>         LinkedHashSet<Student> hs = new LinkedHashSet<>();
>         Student s1 = new Student("张三",23);
>         Student s2 = new Student("张三",23);
>         Student s3 = new Student("李四",24);
>         Student s4 = new Student("王五",25);
> 
>         hs.add(s4);
>         hs.add(s2);
>         hs.add(s3);
>         hs.add(s1);
> 
>         for (Student student : hs) {
>             System.out.println(student);
>         }
> 
> 
>     }
> 
> }
> ```





- 写出下面代码的运行结果
- 修改下main代码用比较器的方法实现倒叙排序

```java
package com.demo08;

import java.util.Comparator;
import java.util.TreeSet;

public class TreeSetDemo01 {
    public static void main(String[] args) {
        TreeSet<Integer> ts = new TreeSet<>() ; //int类型包装类
        ts.add(5);
        ts.add(3);
        ts.add(2);
        ts.add(4);
        ts.add(1);

        System.out.println(ts);
    }
}


```



> [1,2,3,4,5]

> ```java
> package com.demo08;
> 
> import java.util.Comparator;
> import java.util.TreeSet;
> //排序二：比较器排序，需要在TreeSet集合的构造方法中，传递比较器接口的实现类对象，再编写排序的条件
> public class TreeSetDemo01 {
>     public static void main(String[] args) {
>         TreeSet<Integer> ts = new TreeSet<>(new Comparator<Integer>() {
>             @Override
>             public int compare(Integer o1, Integer o2) {
>                 int result = o2 - o1;
>                 return result;
>             }
>         }) ; //int类型包装类
>         ts.add(5);
>         ts.add(3);
>         ts.add(2);
>         ts.add(4);
>         ts.add(1);
> 
>         System.out.println(ts);
>     }
> }
> ```





- 让下面的学生类实现自然排序的接口
  - 排序规则1.按照年龄升序 2.次要条件：如果年龄相同，按照姓名排序

```java
package com.demo08;

import java.util.TreeSet;

public class TreeSetDemo02 {
    public static void main(String[] args) {
        TreeSet<Student> ts = new TreeSet<>();
        Student s1 = new Student("aa",25);
        Student s2 = new Student("aa",25);
        Student s3 = new Student("bb",23);
        Student s4 = new Student("ba",23);
        Student s5 = new Student("cc",24);

        ts.add(s1);
        ts.add(s2);
        ts.add(s3);
        ts.add(s4);
        ts.add(s5);

        for (Student student : ts) {
            System.out.println(student);
        }

    }

}

```

```java
package com.demo08;

public class Student {
    private String name;
    private int age;

    public Student() {
    }

    public Student(String name, int age) {
        this.name = name;
        this.age = age;
    }

    public String getName() {
        return name;
    }

    public void setName(String name) {
        this.name = name;
    }

    public int getAge() {
        return age;
    }

    public void setAge(int age) {
        this.age = age;
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;

        Student student = (Student) o;

        if (age != student.age) return false;
        return name != null ? name.equals(student.name) : student.name == null;
    }

    @Override
    public int hashCode() {
        int result = name != null ? name.hashCode() : 0;
        result = 31 * result + age;
        return result;
    }

    @Override
    public String toString() {
        return "Student{" +
                "name='" + name + '\'' +
                ", age=" + age +
                '}';
    }
}
```



> ```java
> package com.demo08;
> 
> public class Student implements Comparable<Student>{
>     private String name;
>     private int age;
> 
>     public Student() {
>     }
> 
>     public Student(String name, int age) {
>         this.name = name;
>         this.age = age;
>     }
> 
>     public String getName() {
>         return name;
>     }
> 
>     public void setName(String name) {
>         this.name = name;
>     }
> 
>     public int getAge() {
>         return age;
>     }
> 
>     public void setAge(int age) {
>         this.age = age;
>     }
> 
>     @Override
>     public boolean equals(Object o) {
>         if (this == o) return true;
>         if (o == null || getClass() != o.getClass()) return false;
> 
>         Student student = (Student) o;
> 
>         if (age != student.age) return false;
>         return name != null ? name.equals(student.name) : student.name == null;
>     }
> 
>     @Override
>     public int hashCode() {
>         int result = name != null ? name.hashCode() : 0;
>         result = 31 * result + age;
>         return result;
>     }
> 
>     @Override
>     public String toString() {
>         return "Student{" +
>                 "name='" + name + '\'' +
>                 ", age=" + age +
>                 '}';
>     }
> 
>     @Override
> 
>     /*
>         编写排序规则
>             返回值特点
>                 1.返回的是负数、向左存
>                 2.返回的是0、不存储
>                 3.返回的是正数，向右存
>      */
>     public int compareTo(Student o) {
>         // 排序规则：按照年龄升序
>         int result = this.age - o.getAge(); //this 在前面为升序
> 
>         if(result == 0){
>             result = this.name.compareTo(o.getName());
>         }
> 
> 
>         return result;
>     }
> }
> ```





- 查看下列Map接口的常用方法

```java
package com.demo08;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapDem01 {
    public static void main(String[] args) {
        Map<String,String> map = new HashMap<>(); //Map是一个接口，HashMap是其中的一个实现类
        //添加一对数据
        map.put("s01","张三");
        map.put("s01","李四");// 只显示"李四"
        map.put("s02","王五");
        map.put("s03","赵六");
        System.out.println(map);

//        method01(map);//基础方法

        //遍历方式1：获取所有的键，保存到Set集合
        Set<String> keys = map.keySet();
        for (String key : keys) {
            String value = map.get(key);
            System.out.println(key + "," + value);

        }


        //遍历方式2：获取所有键值对对象，保存到Set集合
        Set<Map.Entry<String, String>> entries = map.entrySet();//Entry是Map的一个内部接口，保存键和值
        for (Map.Entry<String, String> entry: entries) {
            String key = entry.getKey();
            String value = entry.getValue();
            System.out.println(key + "," + value);
        }
    }

    private static void method01(Map<String, String> map) {


        //根据键获取值
        String value = map.get("s02");
        System.out.println(value);

        //清空集合元素
//        map.clear();
//        System.out.println(map);

        //根据键除一对数据、返回被删除的值
        String value2 = map.remove("s03");
        System.out.println(value2);
        System.out.println(map);

        //获取集合的长度
        System.out.println(map.size());

        //判断集合中是否包含类指定的键
        System.out.println(map.containsKey("s02"));
        System.out.println(map.containsKey("s05"));

        //判断集合中是否包含指定的值
        System.out.println("王五");
        System.out.println("周七");

        //获取集合中所有的值，保存到单列集合中
        Collection<String> values = map.values();
        System.out.println(values);
    }
}

```





- 用两种方式遍历键值对

```java
package com.demo08;

import java.util.Collection;
import java.util.HashMap;
import java.util.Map;
import java.util.Set;

public class MapDem01 {
    public static void main(String[] args) {
        Map<String, String> map = new HashMap<>(); //Map是一个接口，HashMap是其中的一个实现类
        //添加一对数据
        map.put("s01", "张三");
        map.put("s01", "李四");// 只显示"李四"
        map.put("s02", "王五");
        map.put("s03", "赵六");
        System.out.println(map);


        //遍历方式1：获取所有的键，保存到Set集合



        //遍历方式2：获取所有键值对对象，保存到Set集合

        
    }

}
```



> ```java
> package com.demo08;
> 
> import java.util.Collection;
> import java.util.HashMap;
> import java.util.Map;
> import java.util.Set;
> 
> public class MapDem01 {
>     public static void main(String[] args) {
>         Map<String, String> map = new HashMap<>(); //Map是一个接口，HashMap是其中的一个实现类
>         //添加一对数据
>         map.put("s01", "张三");
>         map.put("s01", "李四");// 只显示"李四"
>         map.put("s02", "王五");
>         map.put("s03", "赵六");
>         System.out.println(map);
> 
> 
>         //遍历方式1：获取所有的键，保存到Set集合
>         Set<String> keys = map.keySet();
>         for (String key : keys) {
>             String value = map.get(key);
>             System.out.println(key + "," + value);
> 
>         }
> 
> 
>         //遍历方式2：获取所有键值对对象，保存到Set集合
>         Set<Map.Entry<String, String>> entries = map.entrySet();//Entry是Map的一个内部接口，保存键和值
>         for (Map.Entry<String, String> entry : entries) {
>             String key = entry.getKey();
>             String value = entry.getValue();
>             System.out.println(key + "," + value);
>         }
>     }
> 
> }
> ```



用LinkedHashMap保证下面代码元素的存取顺序

```java
package com.demo08;

import java.util.HashMap;
import java.util.Set;

public class HashMapDemo02 {
    public static void main(String[] args) {
        HashMap<String, String> hm = new HashMap<>();
        hm.put("s01","张三");
        hm.put("s02","李四");
        hm.put("s03","王五");
        hm.put("s04","赵六");

        Set<String> keys = hm.keySet();
        for (String key : keys) {
            String value = hm.get(key);
            System.out.println(key + "," + value);
        }
    }
}
```



> ```java
> package com.demo08;
> 
> import java.util.HashMap;
> import java.util.LinkedHashMap;
> import java.util.Set;
> import java.util.concurrent.LinkedBlockingDeque;
> 
> public class HashMapDemo02 {
>     public static void main(String[] args) {
>         LinkedHashMap<String,String> hm = new LinkedHashMap<>();
> //        HashMap<String, String> hm = new HashMap<>();
>         hm.put("s01","张三");
>         hm.put("s02","李四");
>         hm.put("s03","王五");
>         hm.put("s04","赵六");
> 
>         Set<String> keys = hm.keySet();
>         for (String key : keys) {
>             String value = hm.get(key);
>             System.out.println(key + "," + value);
>         }
>     }
> }
> ```



TreeMap是按什么进行排序



> 键





将下列代码用比较器改为按键降序排序

```java
package com.demo08;

import java.util.TreeMap;

public class TreeMapDemo03 {
    public static void main(String[] args) {
        TreeMap<Integer, String> tm = new TreeMap<>();
        tm.put(3,"张三");
        tm.put(1,"李四");
        tm.put(2,"王五");

        System.out.println(tm);
    }
}
```



> ```java
> package com.demo08;
> 
> import java.util.Comparator;
> import java.util.TreeMap;
> 
> public class TreeMapDemo03 {
>     public static void main(String[] args) {
>         TreeMap<Integer, String> tm = new TreeMap<>(new Comparator<Integer>() {
>             @Override
>             public int compare(Integer o1, Integer o2) {
>                 return o2 - o1;
>             }
>         });
>         tm.put(3,"张三");
>         tm.put(1,"李四");
>         tm.put(2,"王五");
> 
>         System.out.println(tm);
>     }
> }
> ```





判断：Integer键的类实现了comparable的接口，并重写了方法



> 对



Hashtable线程安全，但存取慢，目前基本上被HashMap取代，但他有一个子类至今很重要，它有一个方法可以自动加载配置文件里面的键值对数据，它是谁？



> Properties



查看下面Properties的基本使用

```java
package com.demo08;

import java.util.Properties;
import java.util.Set;

public class PropertiesDemo04 {
    public static void main(String[] args) {
        Properties prop = new Properties(); // 键值一般为字符串
        prop.put("usename","zhangsan");
        prop.put("password","123456");

        Set<Object> keys = prop.keySet();
        for (Object key : keys) {
            Object value = prop.get(key);
            System.out.println(key + "," + value);
        }

    }
}
```





判断：泛型里面只能接收引用数据类型，要使用基本数据就要使用对应的包装类



> 对





int的包装类是什么？



> Inteager





修改下列代码，用泛型让value的值 可以修改成整型 100

```java
package com.demo09;

public class Demo01 {
    public static void main(String[] args) {
        Box box1 = new Box();
        box1.setValue("hello");
//        box1.setValue(100); // 报错
        String value = box1.getValue();
        System.out.println(value);
    }
}
```

```java
package com.demo09;

public class Box {
    private String value;

    public String getValue() {
        return value;
    }

    public void setValue(String value) {
        this.value = value;
    }
}
```



>```java
>package com.demo09;
>
>public class Demo01 {
>    public static void main(String[] args) {
>        Box<Integer> box1 = new Box<>();
>        box1.setValue(100); // 报错
>        Integer value = box1.getValue();
>        System.out.println(value);
>    }
>}
>```
>
>```java
>package com.demo09;
>
>public class Box<T> {
>    private T value;
>
>    public T getValue() {
>        return value;
>    }
>
>    public void setValue(T value) {
>        this.value = value;
>    }
>}
>```





将下面泛型指定为字符串类型

```java
package com.demo09;

import java.util.ArrayList;

public class Demo01 {
    public static void main(String[] args) {
        ArrayList list = new ArrayList();

    }
}
```



> ```java
> package com.demo09;
> 
> import java.util.ArrayList;
> 
> public class Demo01 {
>     public static void main(String[] args) {
>         ArrayList<String > list = new ArrayList<>();
> 
>     }
> }
> ```





将下面的MyPrint变成泛型方法

```java
package com.demo09;

public class Demo {
    public static void main(String[] args) {
        MyPrint my = new MyPrint();
        my.print("hello");
        my.print(100);
        my.print("true");
    }
}
```

```java
package com.demo09;

public class MyPrint {
    //需求：接受一个参数，参数是什么，打印什么
    public void  print(String t){
        System.out.println(t);
    }
}
```



> ```java
> package com.demo09;
> 
> public class MyPrint {
>     //需求：接受一个参数，参数是什么，打印什么
>     public <T> void  print(T t){
>         System.out.println(t);
>     }
> }
> ```





将下面的接口Inter变为泛型，

- 实现类InterImpl1时，直接明确数据类型为String
- 实现类InterImpl2时，将实现类变成一个泛型的类

```java
package com.demo09;

public class Demo02 {
    InterImpl1 i1 = new InterImpl1();
    i1.show("hello");
    
    InterImpl2 i2 = new InterImpl2();
    i2.show(100);

}

interface Inter{
    public abstract void show();
}


class InterImpl1 implements Inter{

    @Override
    public void show() {
        System.out.println(s);
    }
}

class InterImpl2 implements Inter{

    @Override
    public void show() {
        System.out.println(s);
    }
}
```



> ```java
> package com.demo09;
> 
> public class Demo02 {
>     public static void main(String[] args) {
>         InterImpl1 i1 = new InterImpl1();
>         i1.show("hello");
> 
>         InterImpl2<Integer> i2 = new InterImpl2();
>         i2.show(100);
>     }
> 
> 
> }
> 
> interface Inter<T>{
>     public abstract void show(T t);
> }
> 
> 
> class InterImpl1 implements Inter<String> {
> 
> 
>     @Override
>     public void show(String s) {
>         System.out.println(s);
>     }
> }
> 
> class InterImpl2<T> implements Inter<T>{
> 
>     @Override
>     public void show(T t) {
>         System.out.println(t);
> 
>     }
> }
> ```





类型通配符解决是以下的问题，他的符号是什么

```java
package com.demo09;

import java.util.ArrayList;

public class Demo01 {
    public static void main(String[] args) {
        ArrayList<String > list1 = new ArrayList<>();
        list1.add("aa");
        list1.add("bb");

        ArrayList<Integer > list2 = new ArrayList<>();
        list2.add(10);
        list2.add(20);

        printList(list1);
        printList(list2);


    }

    public static void printList(ArrayList<?> list){
        System.out.println(list);
    }


}
```



> ?





判断：上限限定是指只能是该类本身或者它的子类



> 对



上限限定和下限限定的关键词分别是什么？



> extend





主程序method1的哪几行会报错，method2的哪几行会报错

```java
package com.demo09;

import java.util.ArrayList;

public class Demo01 {
    public static void main(String[] args) {
        ArrayList<String > list = new ArrayList<>();
        method1(new ArrayList<A>());
        method1(new ArrayList<B>());
        method1(new ArrayList<C>());
        method1(new ArrayList<D>());

        method2(new ArrayList<A>());
        method2(new ArrayList<B>());
        method2(new ArrayList<C>());
        method2(new ArrayList<D>());

    }

    public static void method1(ArrayList<? extends C> list){}

    public static void method2(ArrayList<? super C> list){}

}


class A{}

class B extends A{}

class C extends B{}

class D extends C{}
```



> 1,2;4





判断：Lambda表达式必须是接口，且接口中只能有一个抽象方法



> 对





用Lambda表达式来实现下面的效果

```java
package com.demo09;

import java.util.ArrayList;

public class Demo01 {
    public static void main(String[] args) {
        useInter(new Inter() {
            @Override
            public void show(String str) {
                System.out.println(str);
            }
        });

        System.out.println("------------");
        
        //Lambda方法




    }

    public static void useInter(Inter i){
        i.show("hello");
    }


interface Inter{
        public abstract void show(String str);
}

}
```



> ```java
> package com.demo09;
> 
> import java.util.ArrayList;
> 
> public class Demo01 {
>     public static void main(String[] args) {
>         useInter(new Inter() {
>             @Override
>             public void show(String str) {
>                 System.out.println(str);
>             }
>         });
> 
>         System.out.println("------------");
> 
>         //Lambda方法
>         useInter( (String str) -> {
>             System.out.println(str);
>         });
> 
> 
> 
> 
>     }
> 
>     public static void useInter(Inter i){
>         i.show("hello");
>     }
> 
> 
> interface Inter{
>         public abstract void show(String str);
> }
> 
> }
> ```





快捷键用lambda实现下面的降序效果，再补充一遍完整格式

```java
package com.demo09;

import java.util.Comparator;
import java.util.TreeSet;

public class Demo03 {
    public static void main(String[] args) {
        TreeSet<Integer> ts = new TreeSet<>(new Comparator<Integer>() {
            @Override
            public int compare(Integer o1, Integer o2) {
                return o2 - 01;
            }
        });
        ts.add(5);
        ts.add(2);
        ts.add(3);
        ts.add(1);
        ts.add(4);

        System.out.println(ts);
    }


}
```



> ```java
> package com.demo09;
> 
> import java.util.Comparator;
> import java.util.TreeSet;
> 
> public class Demo03 {
>     public static void main(String[] args) {
> //        TreeSet<Integer> ts = new TreeSet<>((o1, o2) -> o2 - 01);
>         TreeSet<Integer> ts = new TreeSet<>((Integer o1, Integer o2) -> {return o2 - 01;});
>         ts.add(5);
>         ts.add(2);
>         ts.add(3);
>         ts.add(1);
>         ts.add(4);
> 
>         System.out.println(ts);
>     }
> 
> }
> ```



### 案例



库存管理系统

![image-20220417201917088](https://i0.hdslb.com/bfs/album/7fc09290af18b2e554fad2b549d57fe4ffcfce51.png)

![image-20220417202217459](https://i0.hdslb.com/bfs/album/d72c1cb080f7f92b461de92d158c804f7d9b3199.png)



>```java
>package com.demo09;
>
>import java.util.ArrayList;
>import java.util.Scanner;
>
>public class Test {
>    static ArrayList<Phone> list = new ArrayList<>();
>    static Scanner sc = new Scanner(System.in);
>    public static void main(String[] args) {
>        list.add(new Phone("小米手机","黑色",1999,20));
>        list.add(new Phone("华为手机","黑色",1999,20));
>
>        System.out.println("欢迎来到商品库存管理系统，请输入您的选择：");
>
>
>
>        while(true){
>            System.out.println("欢迎来到商品库存管理系统，请输入您的选择：");
>            System.out.println("1. 商品入库");
>            System.out.println("2. 商品显示");
>            System.out.println("3. 删除商品");
>            System.out.println("4. 退出系统");
>            int choice = sc.nextInt();
>            if(choice == 1){
>                //商品入库
>                add();
>                show();
>            }else if(choice == 2){
>                //商品显示
>                show();
>            }else if(choice == 3){
>                //删除商品
>                delect();
>            }else if(choice == 4){
>                //退出系统
>                break;
>            }else {
>                System.out.println("您的输入有误");
>            }
>
>
>        }
>
>    }
>
>    private static void delect() {
>        System.out.println("请输入要删除第几个商品：");
>        int i = sc.nextInt();
>        list.remove((i-1));
>        System.out.println("删除成功");
>    }
>
>    private static void show() {
>        if(list.size() == 0){
>            System.out.println("目前暂时没有商品可以查看");
>        }else{
>            System.out.println("目前现有的商品为：");
>            for (Phone phone : list) {
>                System.out.println(phone);
>
>            }
>        }
>    }
>
>    private static void add() {
>        System.out.println("确认要录入数据吗？");
>        String choice = sc.next();
>        if("yes".equals(choice)){
>            System.out.println("请输入商品名称");
>            String name = sc.next();
>            System.out.println("请输入商品颜色");
>            String color = sc.next();
>            System.out.println("请输入商品价格");
>            int price = sc.nextInt();
>            System.out.println("请输入商品数量");
>            int num = sc.nextInt();
>
>            Phone p = new Phone(name, color, price, num);
>            list.add(p);
>        }else{
>            return;
>        }
>
>    }
>}
>
>```
>
>





学生管理系统

![image-20220417202130681](https://i0.hdslb.com/bfs/album/572446c567607d093e7a5218feb10901c1e00e30.png)

![image-20220417202255165](https://i0.hdslb.com/bfs/album/21656e334b9d07573abd1c56437aa8f6abe93692.png)



> 





模拟用户注册

![image-20220417202540541](https://i0.hdslb.com/bfs/album/4559f8fdf040679562e96bc0e263c8c746e62533.png)

![image-20220417202603167](https://i0.hdslb.com/bfs/album/a44a6ab728ccc7aa620746be093f99051b7be742.png)



> 





斗地主洗牌

![image-20220417202625753](https://i0.hdslb.com/bfs/album/a3763f9739abd3757f0420b2227ded249dbc8512.png)

![image-20220417202636961](https://i0.hdslb.com/bfs/album/7fe5db9ade0a4fe262a50434edab84ea6d62d757.png)



> 





模拟百度翻译

![image-20220417202707964](https://i0.hdslb.com/bfs/album/1a59123c8a675007bc80534f773077a0906dfd8e.png)

![image-20220417202748091](https://i0.hdslb.com/bfs/album/4a060c001f26778a8c3c6f95c84e7e9a0ba77d80.png)



> 









## IO

导入IO所有包的代码是什么？

> import java.io.*



File类可以实现对磁盘文件的创建、删除和重命名；判断是否存在。查询是否存在



想要创建对象就需要先有构造方法

文件不存在也可以创建File对象

路径分隔符可以是 / 也可以是 \\\



创建一个File对象，路径/Users/jarrycf/Documents/Idea/a.txt

```java
package com.demo10;

import java.io.*;

public class Test {

    public static void main(String[] args) {
        //创建一个File对象
        File f = new File("/Users/jarrycf/Documents/Idea/a.txt");
        
    }
}

```









读取文件是输出，写入文件是输入

每一个进程至少有一个线程

java首先会开启一个进程，再开启一个线程



# &







## 多线程

什么是进程？什么是线程



多进程和多线程有什么区别

> 多进程更稳定，但开销大



两种线程的实现方式是什么

>  继承包
>
> 





## 网络编程



## JDBC

什么事JDBC

> 链接数据库



JDBC连接必须使用的包是那个

> Drive



加载JDBC驱动，创建与数据库的连接(第一次握手)的API是什么

> DriverManger



他有哪两个方法



处理特定的数据库连接的API是什么，他的三个方法是什么

Connection



执行步骤（增删改查，静态操作）是有过什么接口实现的

> Statement



Statement接口中的方法

- 查询成功或失败
- insert、update、delect
- 结果集



执行预编辑的SQL语句

> PreparedStatement



PreparedStatement是Statement的子接口，可以使用占位符？，用setter为其赋值



PreparedStatement的特有方法

- 参数设置为int

- 参数设置为string

  

parameter

setString



保持结果集的API是什么



ReasultSet接口





ReasultSet接口的方法

- 通过索引获得对应的值
- 通过字段获得对应的值



getin是从1开始





……





连接数据库的操作



连接数据库

通过

关闭数据库











## GUI



## 反射



## 图书管理系统



# 作业

***\*随堂测验编程：\*******\*学生专业成绩\*******\*系统\****

 

编写学生类Student

包含属性:sno学号 name姓名 gender性别 major专业 totalScore总成绩

 

编写专业类Major

包含属性:totalScore总成绩 englishScore英文成绩 midScore期中成绩 finalScore期末成绩

 

编写三个不同的子专业类继承专业类Major,以下为各个专业与它们独有的专业课:

1)计算机系:ComputerMajor 编程课成绩(专业课):programmingScore

2)中文系:ChineseMajor 写作课成绩(专业课):writingScore

3)数学系:MathematicsMajor 数学理论成绩(专业课):mathScore

4)提供计算最终成绩的getScore():

成绩计算逻辑:总成绩=专业课成绩40%+英文课成绩10%+期中成绩15%+期末成绩35%

 

4.在测试类中定义一个可以容纳3个学生的学生数组

 

输入学生的各项信息,学号按输入顺序,第1个学生学号为1

使用随机数给学生随机分配专业

输入学生的各项分数,计算得出学生的总成绩

利用将以上所有信息创建对应的学生对象,存入数组中

输出学生的信息,格式:

学号:1, 姓名:‘李四’, 性别:女, 专业:数学专业{数学理论课成绩:98.0,英文课成绩:88.0,期中成绩:79.0,期末成绩:90.0}, 总成绩:91.35 



```java
```













