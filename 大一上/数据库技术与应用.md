 

# 随记















































# test

## 0.期末复习

```python
##将文件拖入navicat，并删除数据库exam和本地用户testuser


#5.	查看系统中所有库


#7.	重新建库并选择exam


#8.	建表，部门表dept（d_id, d_name, manager, address）


#9.	建表，员工表emp(e_id自增, e_name, sex, age, enroll_date, d_id) 外键 2.创建表无：且每段要加，


#10.	复制表，dept_1


#11.	删除表dept_1


#12.	修改表dept，修改manager为d_manager


#13.	修改表dept，在d_name后增加列testcol int not null


#14.	修改表dept，删除testcol列


#15.	查看dept的表结构


#16.	查看dept的建表语句


#17.	查看数据库中所有的表


#18.	Dept数据插入
/*
100,'财务部','张三', '北京'
200,'销售部','丽丽', '上海'
300,'人力部','李四', '南京'
400,'市场部','李二', '南宁'
*/


#19.	Emp数据插入
/*
'Alex','男',30,2015-01-01,100
'Emy','女',26,2014-08-02,100
'王二','男',31,2012-01-01,200
'小明','男',24,2017-11-01,300
'王三','男',30,2014-01-01,200
'陈一','女',26,2015-08-22,100
'王六','男',39,2010-01-01,200
'赵五','女',22,2019-08-01,400
'赵五','女',25,2013-05-01,400
'赵五','女',28,2015-06-01,400
'赵六','女',22,2019-08-01,400
*/


#20.	更新dept表，市场部经理更名张小五


#21.	删除emp表中赵六的记录


#22.	查看dept表的所有数据


#24.	查看去重后的员工姓名


#25.	查看女员工的姓名和入职月数


#26.	查看人力部的员工姓名和年龄


#27.	查看地址以“南”开头的部门的部门名，员工人数


#28.	查看每个部门的员工的平均年龄和最早入职时间


#29(超纲.分组之后内部的排序）分别查看男女员工中的最年轻员工的姓名，年龄，入职时间，按入职倒序排序


#29	分别查看女员工中的最年轻员工的姓名，年龄，入职时间


#30.	查看每个部门中2014年以后入职的员工的人数，最小年龄，显示大于2人的部门信息，按人数倒序排序。


#31.	查看最年长的三个男员工信息


#32.	显示所有的经理名和员工名


#33.	创建男员工员工号，姓名，年龄，部门名的视图view1


#34.	创建丽丽管理的员工信息的视图view2


#35.	查询丽丽理的员工信息的视图的定义语句


#36.	删除丽丽管理的员工信息的视图


#37.	在dept的d_id上创建唯一性索引，倒排


#38.	在emp的入职日期上创建普通索引


#39.	查看所有的索引


#40.	删除在emp的入职日期上的索引


#41.	删除dept的主键


#42.	以root登录，创建用户testuser，密码xxx


#43.	修改testuser，密码为123456


#44.	查看系统中所有的用户


#45.	为testuser赋权，exam库的emp表，select和update权限


#46.	撤销testuser的exam库的emp表的select权限




```











## 1.樊晓唯终章

1. 画E-R图
   实体：部门，属性有部门号，部门名，部门经理，地址；员工，属性有员工号，姓名，性别，年龄，入职日期，部门号。一个部门包含多个员工，员工只能在一个部门工作。

   上述ER图转换关系模型

   

   
   
   某企业集团有若干工厂，每个工厂生产多种产品，且每一种产品可以在多个工厂生产，每个工厂按照固定的计划数量生产产品，计划数量不低于300;每个工厂聘用多名职工，且每名职工只能在一个工厂工作，工厂聘用职工有聘期和工资。工厂的属性有工厂编号、厂名、地址，产品的属性有产品编号、产品名、规格,职工的属性有职工号、姓名、技术等级。
   
   请画出对应的E-R图
   
   
   
   
   
2. 索引有哪些作用？分类？
   
3. truncate 和 delect from的区别和共同点分别是什么
   
5. 视图和基表有什么区别：
   
6. 为什么需要存储过程：
   
   

6. 用户可以授权哪几种表

   

7. 视图很多时候无法更新,说3种情况
   



```mysql
##将文件拖入navicat，并删除数据库exam、本地用户testuser、p_01到p_05的存储过程


##一、存储引擎
#1.查看当前mysql支持的数据存储引擎

#2.查看默认的存储引擎（innoDB）

#3.或（文字）

#4.查看系统支持的字符集

#5.或

#6.查看和latin（拉丁）相关的校验规则

#7.查看服务器级别和数据库的字符集和校验规则（还有表和字段的）

#8.查看所有数据库的配置信息，变量和值

#9.用校验方式创建字符集为gbk的数据库scf_1

#10.查看scf_1的建库语句

#11.修改scf_1字符集编码为utf8

#12.校验方式删除scf_1



##二、表的修改
#13.	查看系统中所有库

#14.	重新建库并选择exam

#15.	建表，部门表dept（d_id, d_name, manager, address）,为部门名和地址入职日期上创建多列全文索引，并指定地址字长30和降序

#16.	建表，员工表emp(e_id(自增,非空,唯一,备注为编号) e_name, sex(男或女，), age, enroll_date, d_id) 外键 

#17.	复制表，dept_1

#18.	同上，用不会拷贝key的信息的复制 dept_3

#19.	修改dept_1表名为dept_2

#20.	删除表dept_1,dept_2、dept_3

#21.	修改表dept，修改manager为d_manager

#22.	修改表dept，在d_name后增加列testcol ,在最前添加testcol1 char，用添加列方式在最后添加testcol2 char

#23.	为testcol1添新约束 time not null unique 

#24.	修改表dept，删除testcol、testcol1、testcol2列

#25.	查看dept的表结构

#26.	查看dept的建表语句

#27.	查看数据库中所有的表



##三、数据的增删改
#28.	Dept数据插入
/*
100,'财务部','张三', '北京'
200,'销售部','丽丽', '上海'
300,'人力部','李四', '南京'
400,'市场部','李二', '南宁'
*/


#29.	Emp数据插入
/*
'Alex',男,30,2015-01-01,100
'Emy',女,26,2014-08-02,100
'王二',男,31,2012-01-01,200
'小明',男,24,2017-11-01,300
'王三',男,30,2014-01-01,200
'陈一',女,26,2015-08-22,100
'王六',男,39,2010-01-01,200
'赵五',女,22,2019-08-01,400
'赵五',女,25,2013-05-01,400
'赵五',女,28,2015-06-01,400
'赵六',女,22,2019-08-01,400
*/



#30.  删除emp所有记录，并回滚


#31.	删除所有记录，不可回滚

#32.  换方法对emp数据插入（也可将null换成1，2，3……）


#32.	更新dept表，市场部经理更名张小五


#33.	删除emp表中赵六的记录



##四.单表
#34.	查看dept表的所有数据

#35.	查看去重后的员工姓名


#36.	查看女员工的姓名和入职月数


#37.  查询年龄在(25，30]范围的员工姓名


#38.  查询年龄为25或30或31的员工姓名

#39.  或

#40.  查询入职为空的员工信息，再查询不为空

#41.  查询日期不是以2015开头，倒数第4位为6的员工信息

#42.  查询表中第2列到第4列

#43.  按年龄降序，入职升序排序(升是asc)

#44  按照年龄和性别分组，查询行数及最小年龄，按分组排序，显示前4行

#45.  按性别分组，展现最大年龄，最早入职，只展现平均年龄在22到30(都包含between)的员工信息

#46.  按照年龄不为空的记录，按照性别和入职分组，展示平均年龄(2位)，只展现组内最大年龄<30的员工信息，按平均年龄降序排序。



##五、多表
#47.	查看人力部的员工姓名和年龄

#48.	查看地址以“南”开头的部门的部门名，员工人数

#49.	查看每个部门的员工的平均年龄和最早入职时间

#50.	(超纲.分组之后内部的排序）分别查看男女员工中的最年轻员工的姓名，年龄，入职时间，按入职倒序排序

#51.	分别查看女员工中的最年轻员工的姓名，年龄，入职时间

#52.	查看每个部门中2014年以后入职的员工的人数，最小年龄，显示大于2人的部门信息，按人数倒序排序。

#53.	查看最年长的三个男员工信息

#54.	显示所有的经理名和员工名

#55.	同上去重

#56.	去看终章-多表1



##六.索引
#37.	在dept的d_id上创建唯一性索引，倒排

#38.	在emp的入职日期上创建普通索引

#39.	查看所有的索引

#或

#40.	删除在emp的入职日期上的索引

#用修改表删除dept的d_id索引



##七.视图
#33.	创建男员工员工号，姓名，年龄，部门名，并指定新的字段名id, name, age ,dname到视图view1

#34.	创建丽丽管理的员工信息的视图view2

#35.	查询丽丽理的员工信息的视图的定义语句和视图结构

#修改view2，添加查询d_name, 查询条件年龄>24,并查询所有内容

#查看当前数据库的所有视图

#或

#将view2的陈一的性别修改成男

#将emp的陈一的性别修改成女

#模仿视图view2创建view2_check，使其在更新数据不满足where时，报错。试图修改视图陈一年龄为22

#36.	同时删除丽丽管理的员工信息的视图和view1



##八.存储过程
#自定义变量pi=3.1415926 并查询(以下都查询)

#创建变量max_age,为emp表中年龄的最大值

#查询所有的用户的自定义的变量名(会话变量只在当前会话中有效)

#将 select * from emp 封装为存储过程(函数)，命名为p_01并调用

#根据姓名查询所有员工信息，封装为p_02，输入'陈一'查询结果

#根据年龄查询emp表的姓名纪律，创建名为p_03的存储过程。入参年龄，出参为姓名

#调用存储过程，参数值age为31，输出OUT变量命名为ename, 查询结果

#将传入的变量grade提示百分之10，封装成存储过程p_04，输出变量命名为magrade 赋值80并查询

#查看存储过程p_01的定义

#删除p_01

# 从emp表对年进行判断，小于25岁年轻，其余为老手，为结果设置别名年龄水平

#对成绩分组，元老：40-35，老手30-35，成长25-30，年轻20-25，(后的都包含）20以下不达标 为结果设置别名 年龄水平

#41.	删除dept的主键

#添加dept复合主键d_id和d_name

#删除外键，用修改表的方式创建相同外键

#删父表



##九.用户权限
#42.	以root登录，创建用户testuser1，密码xxx

#43.	修改testuser，密码为123456

#修改testuser1用户名为testuser

#44.	查看系统中所有的用户和全局授权情况

#查看数据库级别、数据表级别、数据列级别授权情况

#44.	查看系统中所有用户的ip地址和用户名

#45.	为testuser赋权，exam库的emp表，select和update权限

#赋给testuser所有权限

#46.	撤销testuser的exam库的emp表的select权限

#撤销testuser所有权限



```







## 2.终章-多表1

```mysql
-- 第六章 多表查询
-- 【0】准备工作
-- 使用schoolinfo数据库
use schoolinfo;

delete from sc;
delete from course;
delete from student;
delete from specialty;

-- 创建几张表，并插入数据
-- 【0.1】专业表
-- 【0.1】创建专业表：specialty
DROP TABLE IF EXISTS specialty;
CREATE TABLE specialty (
  zno VARCHAR(4) NOT NULL PRIMARY KEY ,
  z_name VARCHAR(50) NOT NULL
);

-- 【0.2】创建课程表：course
DROP TABLE IF EXISTS course;
CREATE TABLE course (
  cno VARCHAR(8) NOT NULL PRIMARY KEY,
  c_name VARCHAR(50) NOT NULL ,
	c_credit int not null,
	c_teacher VARCHAR(20) not null,
	c_dept VARCHAR(20) not null
);
select*from course;

-- 1.[0.3]学生表student,增加外键，对已有的字段名zno引用自专业表（zno）（注：student表结构延续至单表)
-- 要先删除student表的记录
delete from student;
alter table student add constraint stu_fk foreign key(zno) references specialty(zno);

-- 【0.4】创建选修表：sc
DROP TABLE IF EXISTS sc;
CREATE TABLE sc (
	sno VARCHAR(10) NOT NULL,
	cno VARCHAR(8) NOT NULL,
	grade FLOAT(4) not null,
	PRIMARY KEY(sno, cno),
	CONSTRAINT sc_stu_FK FOREIGN KEY(sno) REFERENCES student(sno),
	CONSTRAINT sc_c_FK FOREIGN KEY(cno) REFERENCES course(cno)
);
show tables;

-- 【0.5】创建选修表：student
create table student(
	sno VARCHAR(10) NOT NULL primary key COMMENT '学号',
	s_name VARCHAR(20) NOT NULL COMMENT '姓名',
	s_sex enum('男','女') not null COMMENT '性别',
	s_age TINYINT UNSIGNED COMMENT '年龄',
	s_birthday date COMMENT '生日',
	s_class VARCHAR(10) COMMENT '班级',
	s_address varchar(50) comment '地址',
	s_score decimal(3,1) COMMENT '平均成绩',
	zno VARCHAR(4) COMMENT '专业号'
);



-- 【以上建表结束】---------------------
-- 插入数据-- 专业表
insert into specialty values
	('ZN', '人工智能'),
	('YD', '移动应用开发'),
	('RJ', '软件工程');
-- 插入数据-- 课程表
insert into course values
	('1001', '数据库技术',3,'李雷','计算机学院'),
	('1002', 'Java程序设计',3,'韩梅梅','计算机学院'),
	('1003', '高等数学',4,'王小明','公共基础学院'),
	('1004', '线性代数',3,'张老师','公共基础学院'),
	('1005', 'C语言',3,'葛优','计算机学院');
-- 插入数据-- 学生表
insert into student values
	('21020301','张一','男',19,'2001-03-01','智能2111','北京',89.5,'ZN'),
	('21020302','李四','男',17,'2001-03-02','智能2111','北海',80,'ZN'),
	('21020303','王五','女',21,'2001-03-03','智能2111','南京',82,'ZN'),
	('21020304','赵六','女',22,'2001-03-04','智能2121','南京',84,'ZN'),
	('21020305','张一一','女',18,'2001-03-05','移动2113','南通',85,'YD'),
	('21020306','张一二','女',18,'2001-03-05','移动2113','南昌',85,'YD'),
	('21020307','李五','男',30,'2001-02-07','移动2112','海口',90,'YD'),
	('21020308','李六','女',30,'2001-02-08','智能2121','上海',72,'ZN'),
	('21020309','冯小刚','男',16,'2001-02-09','智能2121','广州',73.5,'ZN'),
	('21020310','陈凯歌','男',30,'2001-02-10','移动2113','广西',67,'YD'),
	('21020311','葛优','男',30,'2001-02-11','移动2112','苏州',92,'YD'),
	('21020312','徐峥','男',30,'2001-05-12','移动2112','无锡',91.5,'YD'),
	('21020313','黄渤','男',30,'2001-05-13','智能2131','镇江',89.5,'ZN'),
	('21020314','李诞诞','男',30,'2001-05-14','智能2131','常州',80,'ZN'),
	('21020315','李诞','男',30,'2001-05-14','智能2111','常州',80,'ZN'),
	('21020316','李诞','男',30,null,null,null,83,'YD');

-- 插入数据-- 选课表
insert into sc values
	('21020301','1001',89.5),
	('21020302','1001',78),
	('21020303','1001',58),
	('21020304','1001',80),
	('21020305','1001',70),
	('21020306','1001',56),
	('21020307','1001',84),
	('21020301','1002',90),
	('21020302','1002',89),
	('21020303','1003',74),
	('21020304','1003',95),
	('21020305','1002',70),
	('21020306','1002',83),
	('21020307','1003',82);

select*from specialty;
select*from student;
select*from sc;
-- ********************************
-- 以上建表结束


# 查询选修了含Java字眼课程的同学学号，姓名，课程名和成绩
select c.sno, s_name, c_name, grade
from course a join sc b on a.cno = b.cno
		join student c on b.sno = c.sno
where c_name like '%java%'

-- [1.2]自然连接 学生表、选修表、课程表(自动去重）

select*
from sc 
	natural join course 
	natural join student

#显示student和sc的所有数据,以student的行数为准
-- 显示左表course中的全部记录及右表sc复合连接条件的记录，行数不对等，以左表为主
select* 
from student a   
	left join sc b on a.sno = b.sno

-- 查询所有学生的学号，姓名和可选修的课程号和课程成绩，同时显示未选修课程的学生信息
select a.sno, s_name, cno, grade
from student a
	left join sc b on a.sno=b.sno
			
-- 仅查询曾经修过课程的学生信息
select distinct a.*
from student 
	 join sc b on a.sno=b.sno
		 
# 或（此方法可被select完全替代，所以现在不用了）
select *
from student 
where sno in(select distinct sno 
					from sc)
					
					
# 用子查询所有选修过1002课程的学生信息
select *
from student 
where sno in(select sno 
							from sc
							where cno = '1002')
							

-- 用any子查询比任意 移动班学生年龄小的智能班学生信息
select *
from student 
where s_age < any(select s_age
							from student
							where zno = 'YD')
		and zno = 'ZN'									
		
-- 用all子查询比所有移动班学生年龄小的智能班学生信息
select *
from student 
where s_age < all(select s_age
							from student
							where zno = 'YD')
		and zno = 'ZN'
						
-- 综合练习：
-- 查询计算机学院开设的所有课程的选修平均分，按均分倒排
-- 课程号，课程名，授课教师，平均分（保留两位）
select a.cno , c_name, c_teacher, round(avg(grade),2)
from course a join sc b on a.cno = b.cno
where c_dept = '计算机学院'
group by  cno, c_name, c_teacher 
order by round(avg(grade),2) desc


-- 查询计算机学院开设的所有课程的选修平均分，仅显示平均分大于80的，按均分倒排
-- 显示：课程号，课程名，授课教师，平均分（保留两位）
select a.cno , c_name, c_teacher, round(avg(grade),2)
from course a join sc b on a.cno = b.cno
where c_dept = '计算机学院'
group by  cno, c_name, c_teacher 
	having round(avg(grade),2) > 80
order by round(avg(grade),2) desc

```







## 3.终章-多表2



```mysql
create database staffinfo;
-- 使用员工数据库
USE STAFFINFO;

-- 创建地区表：LOCATIONS
DROP TABLE IF EXISTS LOCATIONS;
CREATE TABLE LOCATIONS (
  LOCATION_ID DECIMAL(4,0) NOT NULL PRIMARY KEY ,
  STREET_ADDRESS VARCHAR(40) DEFAULT NULL  ,
  POSTAL_CODE VARCHAR(12) DEFAULT NULL ,
  CITY VARCHAR(30) NOT NULL ,
  STATE_PROVINCE VARCHAR(25) DEFAULT NULL ,
  COUNTRY_ID CHAR(2) DEFAULT NULL
);

-- 创建部门表：DEPARTMENTS
DROP TABLE IF EXISTS DEPARTMENTS;
CREATE TABLE DEPARTMENTS (
  DEPARTMENT_ID DECIMAL(4,0) NOT NULL PRIMARY KEY,
  DEPARTMENT_NAME VARCHAR(30) NOT NULL ,
  MANAGER_ID DECIMAL(6,0) DEFAULT NULL ,
  LOCATION_ID DECIMAL(4,0) DEFAULT NULL ,
  CONSTRAINT DEP_LO_FK FOREIGN KEY (LOCATION_ID) REFERENCES LOCATIONS (LOCATION_ID)
);

-- 创建员工表：EMPLOYEES
DROP TABLE IF EXISTS EMPLOYEES;
CREATE TABLE EMPLOYEES (
  EMPLOYEE_ID DECIMAL(6,0) NOT NULL PRIMARY KEY ,
  FIRST_NAME VARCHAR(20) DEFAULT NULL ,
  LAST_NAME VARCHAR(25) NOT NULL,
  EMAIL VARCHAR(25) NOT NULL ,
  PHONE_NUMBER VARCHAR(20) DEFAULT NULL ,
  HIRE_DATE DATETIME NOT NULL ,
  JOB_ID VARCHAR(10) NOT NULL,
  SALARY DECIMAL(8,2) DEFAULT NULL ,
  COMMISSION_PCT DECIMAL(2,2) DEFAULT NULL ,
  MANAGER_ID DECIMAL(6,0) DEFAULT NULL ,
  DEPARTMENT_ID DECIMAL(4,0) DEFAULT NULL ,
  CONSTRAINT EMP_DEP_FK FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPARTMENTS (DEPARTMENT_ID)
);
select*from LOCATIONS;
select*from departments;

-- 观看实验七第三大题设计性试验
insert into student(
	901,'张军','男',1985,'计算机系','北京市海淀区'
	902,'张超','男',1986,'中文系','北京市昌平区'
	903,'张美','女',1990,'中文系','湖南省永州市'
	904,'李五一','男',1990,'英语系','辽宁省阜新市'
	905,'王芳','女',1991,'英语系','福建省厦门市'
	906,'王桂','男',1988,'计算机系','湖南省衡阳市'
);

insert into student(
901,'计算机',98
901,'英语',80
902,'计算机',65
902,'中文',88
903,'中文',95
904,'计算机',70
904,'英语',92
905,'英语',94
906,'计算机',90
906,'英语',85
);


-- （1）查询李五一的考试科目（c_name）和考试成绩（grade）
Select a.c_name,a.grade
From score a join student b on a.stu_id=b.num
Where b.name='李五一';

-- （2）用连接查询的方式查询所有学生的信息和考试信息
Select *
From score a left join score b on a.stu_id=b.num;


-- （3）计算每个学生的总成绩（需显示学生姓名）
Select b.num,b.name,sum(a.grade)
From score a join score b on a.stu_id=b.num
Group by b.num,b.name;


-- （4）计算每个考试科目的平均成绩
Select a.c_name avg(a.grade)
From score a join score b on a.stu_id=b.num
Group by a.c_name;


-- （5）查询计算机成绩低于95的学生的信息
Select a.*
From score a join score b on a.stu_id=b.num
Where a.c_name='计算机' and a.grade<95;


-- （6）查询同时参加计算机和英语考试的学生的信息
Select*
From student
Where num in (select syu_id from score
							where c_name='计算机'
										and stu_id in (select stu_id
																	from score where c_name='英语'));


-- （7）从student表和score表中查询出学生的学号，然后合并查询结果
Select num fron student
Union 
select stu_id from score;


-- （8）查询姓张或者姓王的同学的姓名、院系、考试科目和成绩
Select b.name,b,bumen,a.c_name,a.grade
From score a join score b on a.stu_id=b.num
Where name like '张%' or name like '王%';


-- （9）查询都是湖南的同学的姓名、年龄、院系、考试科目和成绩
Select b.name,year(current_date)-a.birthday,b.num,a.c_name,a.grade
From score a right join score b on a.stu_id=b.num
Where b.address like'%湖南%';


```





## 4.终章-附件

```mysql
-- 【二、函数】
-- 【条件函数】
-- if函数 [if(表达式,为真的值,为假的值)]
-- 小于60分不及格，其余为及格
select*,
			if(grade<60,'不及格','及格') as '是否及格'
from sc;

-- 对成绩分组，优秀：100-90，良好90-80，中等80-70，及格70-60，60以下不及格【case】
select*,
			if(grade<60,'不及格','及格') as '是否及格',
			case
				when grade >=90 then '优秀'
				when grade < 90 and grade >=80 then '良好'
				when grade < 80 and grade >=70 then '中等'
				when grade < 70 and grade >=60 then '及格'
					else '不及格'
			end as '等第'
from sc;
-- *******************************************
-- 部分常用函数****************************************
-- 【数学函数】
-- 四舍五入(3.14567,2)取两位
SELECT ROUND(3.14567,2);
-- ABS取绝对值
SELECT ABS(-12);
-- PI得到圆周率
SELECT PI(); 
-- sqrt(); 求一个数的平方根
SELECT sqrt(144) ;
-- bin十进制转二进制
SELECT bin(10);
-- mod(x,y)  x除数，y被除数。结束是余数。
SELECT mod(10,3);
-- rand() 是用来生成随机数用的
SELECT RAND();


-- 【日期函数】
-- 返回现在时间
SELECT NOW();
-- 返回一年的值：   
SELECT YEAR(NOW());
-- 得到月份： 
SELECT MONTH(NOW());
-- 得到日： 
SELECT DAY(NOW());
-- 返回小时值：
SELECT HOUR(NOW());
-- 返回分钟值：
SELECT MINUTE(NOW());
-- 返回秒数：
SELECT SECOND(NOW());
-- 得到星期几： 
SELECT WEEKDAY(NOW());
-- 计算两个日期之间相隔的天数：
SELECT DATEDIFF(CURRENT_DATE(),‘2000-1-1’);


-- 【字符串函数】
-- 将字符串参数值转换为全小写字母后返回：	
select lower('SQL Course'); 
-- 将字符串参数值转换为全大写字母后返回：	
select upper('Use MYsql');
-- 将多个字符串参数首尾相连后返回： 	
select concat('My','S','QL');
-- 如果参数是数字，则自动转换为字符串：	
select concat(14.3,'mysql');
-- 将多个字符串参数以给定的分隔符separator首尾相连后返回
select concat_ws(‘;’ , ’First name’, 'Second name’, 'Last name’);
-- 删除首尾空格：
select trim('  bar  ');  
-- 字符串替换（大小写敏感）：    
select replace('www.mysql.com','w','X');
-- 返回最左边的len长度的子串：   
select left('chinaitsoft',5);
-- 返回最右边的len长度的子串：   
select right('chinaitsoft',5);     	


-- 【系统函数】
-- VERSION() 返回数据库的版本号
SELECT VERSION() ;
-- CONNECTION_ID() 返回服务器的连接数
SELECT CONNECTION_ID(); 
-- DATABASE()返回当前数据库名
SELECT DATABASE();
-- USER()、SYSTEM_USER()、SESSION_USER()、CURRENT_USER()、CURRENT_USER 返回当前用户
SELECT USER(); 
-- CHARSET(str) 返回字符串str的字符集
SELECT CHARSET('abc'); -- utf8
-- COLLATION(str) 返回字符串str的字符排列方式
SELECT COLLATION('abc'); -- utf8_general_ci
```

























# reason

## 0.期末复习

```mysql
##将文件拖入navicat，并删除数据库exam和本地用户testuser
drop database exam
drop user 'testuser'@'localhost'
#=> 创建和删除是相对的

#5.	查看系统中所有库
show databases

#7.	重新建库并选择exam
create database exam
use exam

#8.	建表，部门表dept（d_id, d_name, manager, address）
create table dept(
	d_id varchar(20) primary key,
	d_name varchar(20),
	manager varchar(20),
	address varchar(20) 
)

#9.	建表，员工表emp(e_id自增, e_name, sex, age, enroll_date, d_id) 外键 2.创建表无：且每段要加，
create table emp(
	e_id int(20) primary key auto_increment,
	e_name varchar(20),
	sex varchar(20),
	age varchar(20),
	enroll_data date,
	d_id varchar(20),
	constraint fk_did foreign key (d_id) references dept(d_id)
)
#=> 插入类型应根据插入类型修正，entroll_data是登记日期的意思 2.创建外键的首句是constraint，是约束的意思， 建表逻辑是约束 外键名 外键（要约束的本表字段） 参考 其他表（字段） 3.自增长是auto_increment,写在主键后面 4.日期类型是te 5.自增长和外键字段都得是主键，自增长还得是数值类型 6.外键还得在约束前先创建相同字段和字长

#10.	复制表，dept_1
create table dept_1 like dept
#=>赋值表的首句是create

#11.	删除表dept_1
drop table dept_1

#12.	修改表dept，修改manager为d_manager
alter table dept change manager d_manager varchar(20)
#=>修改表的首局是alter 关键词change 2.新字段要加字段类型 3.新字段名写在change后面

#13.	修改表dept，在d_name后增加列testcol int not null
alter table dept add testcol int not null after d_name
#=>也可以用列column

#14.	修改表dept，删除testcol列
alter table dept drop testcol

#15.	查看dept的表结构
desc dept
#desc是专用于表的，所以不需要加table

#16.	查看dept的建表语句
show create table dept

#17.	查看数据库中所有的表
show tables

#18.	Dept数据插入
/*
100,'财务部','张三', '北京'
200,'销售部','丽丽', '上海'
300,'人力部','李四', '南京'
400,'市场部','李二', '南宁'
*/
insert into dept values
('100','财务部','张三', '北京'),
('200','销售部','丽丽', '上海'),
('300','人力部','李四', '南京'),
('400','市场部','李二', '南宁')
#=>insert into 后面加表名 值

#19.	Emp数据插入
/*
'Alex','男',30,2015-01-01,100
'Emy','女',26,2014-08-02,100
'王二','男',31,2012-01-01,200
'小明','男',24,2017-11-01,300
'王三','男',30,2014-01-01,200
'陈一','女',26,2015-08-22,100
'王六','男',39,2010-01-01,200
'赵五','女',22,2019-08-01,400
'赵五','女',25,2013-05-01,400
'赵五','女',28,2015-06-01,400
'赵六','女',22,2019-08-01,400
*/
insert into emp(e_name, sex, age, enroll_data, d_id) values
('Alex','男',30,'2015-01-01',100),
('Emy','女',26,'2014-08-02',100),
('王二','男',31,'2012-01-01',200),
('小明','男',24,'2017-11-01',300),
('王三','男',30,'2014-01-01',200),
('陈一','女',26,'2015-08-22',100),
('王六','男',39,'2010-01-01',200),
('赵五','女',22,'2019-08-01',400),
('赵五','女',25,'2013-05-01',400),
('赵五','女',28,'2015-06-01',400),
('赵六','女',22,'2019-08-01',400)
#=> 要插入特定字段是在表名后面加的 2.日期也是字符必须要加

#20.	更新dept表，市场部经理更名张小五
update dept
set d_manager = '张小五'
where d_name = '市场部'
#=>update配合是set 2.update后面跟的是表名 3.update set 不需要配合select from使用 4. update可以配合where使用 5.上面已经把manager 修改为 d_manager

#21.	删除emp表中赵六的记录
delete from emp
where e_name = '赵六'
#=>删除是elete

#22.	查看dept表的所有数据
select*
from dept

#24.	查看去重后的员工姓名
select distinct e_name
from emp

#25.	查看女员工的姓名和入职月数
select e_name, enroll_data
from emp
where sex = '女'

#26.	查看人力部的员工姓名和年龄
select b.e_name, b.age
from dept a right join emp b on a.d_id = b.d_id
where a.d_name = '人力部'
#=>外键只适用连接表，而不能用做查询的条件 2.使用连接时，应考虑左右连接 3.字段名唯一时，可以定义了缩写但不要缩写

#27.	查看地址以“南”开头的部门的部门名，员工人数
select a.d_name, count(b.e_name) as '员工数量'
from dept a join emp b on a.d_id = b.d_id
where a.address like '南%'
group by a.d_name
#=>count是聚合函数,出现两个以上不同字段出现就要进行分组 2.可以count(distinct b.e_name)单因为员工的名字可能相同不需要去重 3.字符串匹配得用like

#28.	查看每个部门的员工的平均年龄和最早入职时间
select d_id,
				round(avg(age),3) as '平均年龄', 
				min(enroll_data) as '最早入职时间'
from emp
group by d_id
#=>保留小数是round 2.默认平均数保留三位小数 3.要显示每个部门的名称 4.对分组条件添加条件才需要having 5.部门可以直接通过部门id来代替，这样就看单表查询

#29(超纲.分组之后内部的排序）分别查看男女员工中的最年轻员工的姓名，年龄，入职时间，按入职倒序排序

#29	分别查看女员工中的最年轻员工的姓名，年龄，入职时间
select e_name, age, enroll_data
from emp
where sex = '女'
order by age
limit 0,1
#=>筛选出首列用limit(假尾巴) 2.order by默认从上往下慢慢变大

#30.	查看每个部门中2014年以后入职的员工的人数，最小年龄，显示大于2人的部门信息，按人数倒序排序。
select d_id, count(e_name) as '2014年以后入职员工数量', min(age) as '最小年龄'
from emp 
where enroll_data > '2014-1-1'
group by d_id
	having count(e_name) > 2 
order by count(e_name) desc
#=>日期的月可以是1位数 2.要写having

#31.	查看最年长的三个男员工信息
select*
from emp
where sex = '男'
order by age desc
limit 0,3

#32.	显示所有的经理名和员工名
select d_manager 
from dept
union
select e_name
from emp
#=>去重联合时union，反之union all

#33.	创建男员工员工号，姓名，年龄，部门名的视图view1
create view view1 as
	select e_id, e_name, age, d_name
	from dept a join emp b on a.d_id = b.d_id
	where sex = '男'
#=>view 后面那个数是 表名as 2.那个自增长的值是员工号 3.查看视图是通过表和show tables

#34.	创建丽丽管理的员工信息的视图view2
create view view2 as
	select b.*
	from dept a join emp b on a.d_id = b.d_id
	where d_manager = '丽丽'
#=>显示一张表的全部查询是表名.* 2.查询多表的两张表只能用联合查询

#35.	查询丽丽理的员工信息的视图的定义语句
show create view view2

#36.	删除丽丽管理的员工信息的视图
drop view view2

#37.	在dept的d_id上创建唯一性索引，倒排
alter table dept add unique index index_did(d_id desc)
#=>创建索引的三种方式，分别是在表内：索引名，索引类型，索引来自 修改表：索引类型，索引名(索引来自) 创建表 索引类型 索引名  on 索引来自 

#38.	在emp的入职日期上创建普通索引
create index index_enroll on emp(enroll_data)

#39.	查看所有的索引
show index from dept
show index from emp
#=> 查看所有的索引是 show …… from

#40.	删除在emp的入职日期上的索引
drop index index_enroll on emp
#=>删除配合的是 on 2.要连索引类型一起写上去 3.索引名是先写index

#41.	删除dept的主键
alter table dept drop primary key
#=>删除主键只能用修改的方式 2.删除肯定有drop

#42.	以root登录，创建用户testuser，密码xxx
create user 'testuser'@'localhost' identified by 'xxx'

#=>create 后面跟的是user @前是用户名，后localhost。密码前面是identied 2.删除用户是

#43.	修改testuser，密码为123456
alter user 'testuser'@'localhost' identified by '123456'
#=>修改用户是alter user

#44.	查看系统中所有的用户
select*
from mysql.user
#=>查看私有用户是查询mysql.user这张表

#45.	为testuser赋权，exam库的emp表，select和update权限
grant select,update on exam.emp to 'testuser'@'localhost'
#=>赋权第一句是grant 2.权限包括 update delete insert select all on 库.表 to 用户 3.权限的增变成了更新 改变成了插 4.权限与权限间用，隔开 5.不包括所有数据库的权限，只能用数据表级别的权限来查询

#46.	撤销testuser的exam库的emp表的select权限
revoke select  exam.emp from 'testuser'@'localhost'


```





## 1.樊晓唯终章

1. 画E-R图
   实体：部门，属性有部门号，部门名，部门经理，地址；员工，属性有员工号，姓名，性别，年龄，入职日期，部门号。一个部门包含多个员工，员工只能在一个部门工作。

   上述ER图转换关系模型

   ![image-20211226215320209](https://i0.hdslb.com/bfs/album/30acae6f3157cc7d50dce608889d5798d44caf89.png)

   

   某企业集团有若干工厂，每个工厂生产多种产品，且每一种产品可以在多个工厂生产，每个工厂按照固定的计划数量生产产品，计划数量不低于300;每个工厂聘用多名职工，且每名职工只能在一个工厂工作，工厂聘用职工有聘期和工资。工厂的属性有工厂编号、厂名、地址，产品的属性有产品编号、产品名、规格,职工的属性有职工号、姓名、技术等级。

   请画出对应的E-R图

   ![1](https://i0.hdslb.com/bfs/album/e76ee133f2efbd6404eef5083e312689783596e0.png)

   

2. 索引有哪些作用：
   1.优化数据库的查询速度
   2.提高数据库性能

   分类：全文，唯一，普通，主键、多列

   

3. truncate 和 delect from的区别和共同点分别是什么
   delect from可以开启事务管理、删除的的数据可以回滚、所以不能释放内存同时可以使用where，而truncate删除的数据没有办法恢复同时只能删除整个表以释放内存。共同点都能删除记录，不能删除表。

   ![image-20211226020847417](https://i0.hdslb.com/bfs/album/05d035c6dcad1b4394f89a010bfacbfbb715b632.png)

   

4. 视图和基表有什么区别：
   1.视图只在执行时才产生数据。

   2.视图是虚拟表是外模式，是窗口，是属于局部模式的表，无实际物理记录
   基表是实表，是内模式，是内容，是属于全局模式的表，有实际物理记录

   3.视图的建立和删除只影响视图本身，不影响对应的基表，而基表的修改在视图可以更新的情况下会影响视图

   

5. 为什么需要存储过程：
   1.为了封装常用的功能 
   2.将重复性很高的一些操作，封装到一个存储过程中，简化了这些SQL调用

   3.进行批量处理，提升效率。统一接口，确保数据安全

   

6. 用户可以授权哪几种表

   用户权限级别、数据库级别、数据表级别、数据列级别

   

7. 视图很多时候无法更新,说3种情况
   多表，聚合，计算列



```mysql
##将文件拖入navicat，并删除数据库exam、本地用户testuser、p_01到p_05的存储过程
drop database exam
drop user 'testuser'@'localhost'



##一、存储引擎
#1.查看当前mysql支持的数据存储引擎
show engines;

#2.查看默认的存储引擎（innoDB）
show vairables like '%stronge_engine'

#3.或（文字）
my.ini

#4.查看系统支持的字符集
show character set

#5.或
select*
from information_schema.CHARACTER_SETS

#6.查看和latin（拉丁）相关的校验规则
show collation like '%latin%'

#7.查看服务器级别和数据库的字符集和校验规则（还有表和字段的）
show variables like 'character_set_server'
show variables like 'collation_server'
show variables like 'character_set_database'
show variables like 'collation_database'

#8.查看所有数据库的配置信息，变量和值
show variables

#9.用校验方式创建字符集为gbk的数据库scf_1
create database if not exists scf_1 default character set gbk

#10.查看scf_1的建库语句
show create database scf_1

#11.修改scf_1字符集编码为utf8
alter database scf_1 character set utf8

#12.校验方式删除scf_1
drop database if exists scf_1













##二、表的修改
#13.	查看系统中所有库
show databases

#14.	重新建库并选择exam
create database exam
use exam

#15.	建表，部门表dept（d_id, d_name, manager, address）,为部门名和地址入职日期上创建多列全文索引，并指定地址字长30和降序

create table dept(
	d_id varchar(20) primary key,
	d_name varchar(20),
	manager varchar(20),
	address varchar(20),
	fulltext index index_address(d_name,address(20) desc)
)

#16.	建表，员工表emp(e_id(自增,非空,唯一,备注为编号) e_name, sex(男或女,默认‘男’), age, enroll_date, d_id) 外键 
create table emp(
	e_id int(20) primary key not null unique auto_increment comment'编号',
	e_name varchar(20),
	sex enum('男','女'), default '男',
	age varchar(20),
	enroll_data date,
	d_id varchar(20),
	constraint d_id_fk foreign key (d_id) references dept(d_id)
)


#17.	复制表，dept_1
create table dept_1 like dept

#18.	同上，用不会拷贝key的信息的复制 dept_3
create table dept_3 as select* from dept
#复制不用like,得用as

#19.	修改dept_1表名为dept_2
alter table dept_1 rename dept_2

#20.	删除表dept_2、dept_3
drop table dept_2
drop table dept_3

#21.	修改表dept，修改manager为d_manager
alter table dept change manager d_manager varchar(20)

#22.	修改表dept，在d_name后增加列testcol ,在最前添加testcol1 char，用添加列方式在最后添加testcol2 char
alter table dept add testcol char after d_name
alter table dept add testcol1 char first
alter table dept add column testcol2 char

#23.	为testcol1添新约束 time not null unique 
alter table dept modify testcol1 time not null unique

#24.	修改表dept，删除testcol、testcol1、testcol2列
alter table dept drop testcol
alter table dept drop testcol1
alter table dept drop testcol2

#25.	查看dept的表结构
desc dept

#26.	查看dept的建表语句
show create table dept

#27.	查看数据库中所有的表
show tables











##三、数据的增删改
#28.	Dept数据插入
/*
100,'财务部','张三', '北京'
200,'销售部','丽丽', '上海'
300,'人力部','李四', '南京'
400,'市场部','李二', '南宁'
*/
insert into dept values
('100','财务部','张三', '北京'),
('200','销售部','丽丽', '上海'),
('300','人力部','李四', '南京'),
('400','市场部','李二', '南宁')

#29.	Emp数据插入
/*
'Alex',男,30,2015-01-01,100
'Emy',女,26,2014-08-02,100
'王二',男,31,2012-01-01,200
'小明',男,24,2017-11-01,300
'王三',男,30,2014-01-01,200
'陈一',女,26,2015-08-22,100
'王六',男,39,2010-01-01,200
'赵五',女,22,2019-08-01,400
'赵五',女,25,2013-05-01,400
'赵五',女,28,2015-06-01,400
'赵六',女,22,2019-08-01,400
*/

insert into emp(e_name, sex, age, enroll_data, d_id) values
('Alex','男',30,'2015-01-01',100),
('Emy','女',26,'2014-08-02',100),
('王二','男',31,'2012-01-01',200),
('小明','男',24,'2017-11-01',300),
('王三','男',30,'2014-01-01',200),
('陈一','女',26,'2015-08-22',100),
('王六','男',39,'2010-01-01',200),
('赵五','女',22,'2019-08-01',400),
('赵五','女',25,'2013-05-01',400),
('赵五','女',28,'2015-06-01',400),
('赵六','女',22,'2019-08-01',400)

#30.  删除emp所有记录，并回滚
start transaction;
delete from emp;
rollback;

#31.	删除所有记录，不可回滚
truncate emp;

#32.  换方法对emp数据插入（也可将null换成1，2，3……）
insert into emp values
(null,'Alex','男',30,'2015-01-01',100),
(null,'Emy','女',26,'2014-08-02',100),
(null,'王二','男',31,'2012-01-01',200),
(null,'小明','男',24,'2017-11-01',300),
(null,'王三','男',30,'2014-01-01',200),
(null,'陈一','女',26,'2015-08-22',100),
(null,'王六','男',39,'2010-01-01',200),
(null,'赵五','女',22,'2019-08-01',400),
(null,'赵五','女',25,'2013-05-01',400),
(null,'赵五','女',28,'2015-06-01',400),
(null,'赵六','女',22,'2019-08-01',400);    

#32.	更新dept表，市场部经理更名张小五
update dept
set d_manager = '张小五'
where d_name = '市场部'

#33.	删除emp表中赵六的记录
delete from emp
where e_name = '赵六'










##四.单表
#34.	查看dept表的所有数据
select*
from dept

#35.	查看去重后的员工姓名
select distinct e_name
from emp

#36.	查看女员工的姓名和入职月数
select e_name, enroll_data
from emp
where sex = '女'

#37.  查询年龄在(25，30]范围的员工姓名
select e_name
from emp
where age>25 and age<=30

#38.  查询年龄为25或30或31的员工姓名
select e_name
from emp
where age in(25,30,31)

#39.  或
select e_name
from emp
where age = 25 or age = 30 or age = 31

#40.  查询入职为空的员工信息，再查询不为空
select *
from emp
where enroll_data is null

select *
from emp
where enroll_data is not null

#41.  查询日期不是以2015开头，倒数第4位为6的员工信息
select *
from emp
where enroll_data not like '2015%6___'

#42.  查询表中第2列到第4列
SELECT* 
FROM emp
limit 1,3


#43.  按年降序，入职升序排序(升是asc)
SELECT* 
FROM emp
order by age, enroll_data desc


#44  按照年龄和性别分组，查询行数及最小年龄，按分组排序，显示前4行
select age, sex,count(1) as '行数', 
									min(age) as '最小年龄'
from emp
GROUP BY age, sex
order by age, sex
limit 4


#45.  按性别分组，展现最大年龄，最早入职，只展现平均年龄在22到30(都包含between)的员工信息
select sex, max(age), min(enroll_data)
from emp
group by sex
	having avg(age) BETWEEN 22 and 30


#46.  按照年龄不为空的记录，按照性别和入职分组，展示平均年龄(2位)，只展现组内最大年龄<30的员工信息，按平均年龄降序排序。
select sex, enroll_data, round(avg(age),2) as '平均年龄'
from emp
where age is not null
group by sex, enroll_data
	having max(age) < 30
order by avg(age) desc;








##五、多表
#26.	查看人力部的员工姓名和年龄
select b.e_name, b.age
from dept a right join emp b on a.d_id = b.d_id
where a.d_name = '人力部'

#27.	查看地址以“南”开头的部门的部门名，员工人数
select a.d_name, count(b.e_name) as '员工数量'
from dept a join emp b on a.d_id = b.d_id
where a.address like '南%'
group by a.d_name


#28.	查看每个部门的员工的平均年龄和最早入职时间
select d_id,
				round(avg(age),3) as '平均年龄', 
				min(enroll_data) as '最早入职时间'
from emp
group by d_id

#29(超纲.分组之后内部的排序）分别查看男女员工中的最年轻员工的姓名，年龄，入职时间，按入职倒序排序

#29	分别查看女员工中的最年轻员工的姓名，年龄，入职时间
select e_name, age, enroll_data
from emp
where sex = '女'
order by age
limit 0,1

#30.	查看每个部门中2014年以后入职的员工的人数，最小年龄，显示大于2人的部门信息，按人数倒序排序。
select d_id, count(e_name) as '2014年以后入职员工数量', min(age) as '最小年龄'
from emp 
where enroll_data > '2014-1-1'
group by d_id
	having count(e_name) > 2 
order by count(e_name) desc

#31.	查看最年长的三个男员工信息
select*
from emp
where sex = '男'
order by age desc
limit 0,3

#32.	显示所有的经理名和员工名
select d_manager 
from dept
union all 
select e_name
from emp

#同上去重
select d_manager 
from dept
union
select e_name
from emp


#	多表查询看









##六.索引
#37.	在dept的d_id上创建唯一性索引，倒排
alter table dept add unique index index_did(d_id desc)

#38.	在emp的入职日期上创建普通索引
create index index_enroll on emp(enroll_data)

#39.	查看所有的索引
show index from dept
show index from emp

#或
show create table dept
show create table emp


#40.	删除在emp的入职日期上的索引
drop index index_enroll on emp

#用修改表删除dept的d_id索引
alter table dept drop index index_did







##七.视图
#33.	创建男员工员工号，姓名，年龄，部门名，并指定新的字段名id, name, age ,dname到视图view1
create view view1(id, name, age ,dname) as
	select e_id, e_name, age, d_name
	from dept a join emp b on a.d_id = b.d_id
	where sex = '男'

#34.	创建丽丽管理的员工信息的视图view2
create view view2 as
	select b.*
	from dept a join emp b on a.d_id = b.d_id
	where d_manager = '丽丽'

#35.	查询丽丽理的员工信息的视图的定义语句和视图结构
show create view view2
desc view2

#修改view2，添加查询d_name, 查询条件年龄>24,并查询所有内容
alter view view2 as
	select b.*, d_name
	from dept a join emp b on a.d_id = b.d_id
	where age > 24
select*
from view2

#查看当前数据库的所有视图
show tables;


#或
select* 
from information_schema.views
where table_schema='exam'


#将view2的陈一的性别修改成男
update view2
set sex = '男'
where e_name = '陈一'
select*from view2
select*from emp

#将emp的陈一的性别修改成女
update emp
set sex = '女'
where e_name = '陈一'
select*from view2
select*from emp

#模仿视图view2创建view2_check，使其在更新数据不满足where时，报错。试图修改视图陈一年龄为22
show create view view2
CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `view2_check` AS select `b`.`e_id` AS `e_id`,`b`.`e_name` AS `e_name`,`b`.`sex` AS `sex`,`b`.`age` AS `age`,`b`.`enroll_data` AS `enroll_data`,`b`.`d_id` AS `d_id`,`a`.`d_name` AS `d_name` from (`dept` `a` join `emp` `b` on((`a`.`d_id` = `b`.`d_id`))) where (`b`.`age` > 24) with check option

update view2_check
set age = 22
where e_name = '陈一'



#36.	同时删除丽丽管理的员工信息的视图和view1
drop view view2;
drop view view1;











##八.存储过程

use exam

#自定义变量pi=3.1415926 并查询(以下都查询)
set @pi = 3.1415926
select @pi

#创建变量max_age,为emp表中年龄的最大值
select max(age) into @max_age
from emp
select @max_age

#查询所有的用户的自定义的变量名(会话变量只在当前会话中有效)
select*
from performance_schema.user_variables_by_thread

#将 select * from emp 封装为存储过程(函数)，命名为p_01并调用
delimiter $$
	create procedure p_01()
		begin
			select*
			from emp;
		end $$
delimiter ;

call p_01()


#根据姓名查询所有员工信息，封装为p_02，输入'陈一'查询结果
delimiter $$
	create procedure p_02(in e_name varchar(20))
		begin
			select *
			from emp
			where e_name = e_name;
		end $$
delimiter ;
call p_02('陈一')

#根据年龄查询emp表的姓名纪律，创建名为p_03的存储过程。入参年龄，出参为姓名
delimiter $$
	create procedure p_03(in p_age varchar(20), out p_name varchar(20))
		begin
			select e_name into p_name
			from emp
			where age = p_age;
		end $$
delimiter ;

#调用存储过程，参数值age为31，输出OUT变量命名为ename, 查询结果
call p_03(31, @ename)
select @ename

#将传入的变量grade提示百分之10，封装成存储过程p_04，输出变量命名为magrade 赋值80并查询
delimiter $$
create procedure p_04(inout grade float)
	begin
			set grade=grade*1.1;
	end $$
delimiter ;

#查看存储过程p_01的定义
show create procedure p_01

#删除p_01
drop procedure p_01

# 从emp表对年进行判断，小于25岁年轻，其余为老手，为结果设置别名年龄水平
select *,
	if(age < 25,'年轻' ,'老手') as '年龄水平'
from emp


#对成绩分组，元老：40-35，老手30-35，成长25-30，年轻20-25，(后的都包含）20以下不达标 为结果设置别名 年龄水平
select*,
	case
		when age>=35 then '元老'
		when age<35 and age>=30 then '老手'
		when age<30 and age>=25 then '成长'
		when age<25 and age>=20 then '年轻'
			else '不达标'
		end as '年龄水平'
from emp;

#41.	删除dept的主键
alter table dept drop primary key

#添加dept复合主键d_id和d_name
alter table dept add primary key(d_id,d_name);

#删除外键，用修改表的方式创建相同外键
alter table emp drop foreign key d_id_fk;
alter table emp add constraint d_id_fk foreign key (d_id) references dept(d_id)

#删父表
alter table emp drop foreign key d_id_fk;
drop table dept



##九.用户权限
#42.	以root登录，创建用户testuser1，密码xxx
create user 'testuser1'@'localhost' identified by 'xxx'

#43.	修改testuser，密码为123456
alter user 'testuser1'@'localhost' identified by '123456'

#修改testuser1用户名为testuser
rename user 'testuser1'@'localhost' to 'testuser'@'localhost'



#44.	查看系统中所有的用户和全局授权情况
select*
from mysql.user

#查看数据库级别、数据表级别、数据列级别授权情况
select*
from mysql.db

select*
from mysql.tables_priv

select*
from mysql.columns_priv;

#44.	查看系统中所有用户的ip地址和用户名
select host,user
from mysql.user

#45.	为testuser赋权，exam库的emp表，select和update权限
grant select,update on exam.emp to 'testuser'@'localhost'

#赋给testuser所有权限
grant all on *.* to 'testuser'@'localhost'

#46.	撤销testuser的exam库的emp表的select权限
revoke select on exam.emp from 'testuser'@'localhost'

#撤销testuser所有权限
revoke all on *.* from 'testuser'@'localhost'



```







## 2.终章-多表1

```mysql
-- 第六章 多表查询
-- 【0】准备工作
-- 使用schoolinfo数据库
use schoolinfo;

delete from sc;
delete from course;
delete from student;
delete from specialty;

-- 创建几张表，并插入数据
-- 【0.1】专业表
-- 【0.1】创建专业表：specialty
DROP TABLE IF EXISTS specialty;
CREATE TABLE specialty (
  zno VARCHAR(4) NOT NULL PRIMARY KEY ,
  z_name VARCHAR(50) NOT NULL
);

-- 【0.2】创建课程表：course
DROP TABLE IF EXISTS course;
CREATE TABLE course (
  cno VARCHAR(8) NOT NULL PRIMARY KEY,
  c_name VARCHAR(50) NOT NULL ,
	c_credit int not null,
	c_teacher VARCHAR(20) not null,
	c_dept VARCHAR(20) not null
);
select*from course;

-- 1.[0.3]学生表student,增加外键，对已有的字段名zno引用自专业表（zno）（注：student表结构延续至单表)
-- 要先删除student表的记录
delete from student;
alter table student add constraint stu_fk foreign key(zno) references specialty(zno);

-- 【0.4】创建选修表：sc
DROP TABLE IF EXISTS sc;
CREATE TABLE sc (
	sno VARCHAR(10) NOT NULL,
	cno VARCHAR(8) NOT NULL,
	grade FLOAT(4) not null,
	PRIMARY KEY(sno, cno),
	CONSTRAINT sc_stu_FK FOREIGN KEY(sno) REFERENCES student(sno),
	CONSTRAINT sc_c_FK FOREIGN KEY(cno) REFERENCES course(cno)
);
show tables;

-- 【0.5】创建选修表：student
create table student(
	sno VARCHAR(10) NOT NULL primary key COMMENT '学号',
	s_name VARCHAR(20) NOT NULL COMMENT '姓名',
	s_sex enum('男','女') not null COMMENT '性别',
	s_age TINYINT UNSIGNED COMMENT '年龄',
	s_birthday date COMMENT '生日',
	s_class VARCHAR(10) COMMENT '班级',
	s_address varchar(50) comment '地址',
	s_score decimal(3,1) COMMENT '平均成绩',
	zno VARCHAR(4) COMMENT '专业号'
);



-- 【以上建表结束】---------------------
-- 插入数据-- 专业表
insert into specialty values
	('ZN', '人工智能'),
	('YD', '移动应用开发'),
	('RJ', '软件工程');
-- 插入数据-- 课程表
insert into course values
	('1001', '数据库技术',3,'李雷','计算机学院'),
	('1002', 'Java程序设计',3,'韩梅梅','计算机学院'),
	('1003', '高等数学',4,'王小明','公共基础学院'),
	('1004', '线性代数',3,'张老师','公共基础学院'),
	('1005', 'C语言',3,'葛优','计算机学院');
-- 插入数据-- 学生表
insert into student values
	('21020301','张一','男',19,'2001-03-01','智能2111','北京',89.5,'ZN'),
	('21020302','李四','男',17,'2001-03-02','智能2111','北海',80,'ZN'),
	('21020303','王五','女',21,'2001-03-03','智能2111','南京',82,'ZN'),
	('21020304','赵六','女',22,'2001-03-04','智能2121','南京',84,'ZN'),
	('21020305','张一一','女',18,'2001-03-05','移动2113','南通',85,'YD'),
	('21020306','张一二','女',18,'2001-03-05','移动2113','南昌',85,'YD'),
	('21020307','李五','男',30,'2001-02-07','移动2112','海口',90,'YD'),
	('21020308','李六','女',30,'2001-02-08','智能2121','上海',72,'ZN'),
	('21020309','冯小刚','男',16,'2001-02-09','智能2121','广州',73.5,'ZN'),
	('21020310','陈凯歌','男',30,'2001-02-10','移动2113','广西',67,'YD'),
	('21020311','葛优','男',30,'2001-02-11','移动2112','苏州',92,'YD'),
	('21020312','徐峥','男',30,'2001-05-12','移动2112','无锡',91.5,'YD'),
	('21020313','黄渤','男',30,'2001-05-13','智能2131','镇江',89.5,'ZN'),
	('21020314','李诞诞','男',30,'2001-05-14','智能2131','常州',80,'ZN'),
	('21020315','李诞','男',30,'2001-05-14','智能2111','常州',80,'ZN'),
	('21020316','李诞','男',30,null,null,null,83,'YD');

-- 插入数据-- 选课表
insert into sc values
	('21020301','1001',89.5),
	('21020302','1001',78),
	('21020303','1001',58),
	('21020304','1001',80),
	('21020305','1001',70),
	('21020306','1001',56),
	('21020307','1001',84),
	('21020301','1002',90),
	('21020302','1002',89),
	('21020303','1003',74),
	('21020304','1003',95),
	('21020305','1002',70),
	('21020306','1002',83),
	('21020307','1003',82);

select*from specialty;
select*from student;
select*from sc;
-- ********************************
-- 以上建表结束


# 查询选修了含Java字眼课程的同学学号，姓名，课程名和成绩
select c.sno, s_name, c_name, grade
from course a join sc b on a.cno = b.cno
		join student c on b.sno = c.sno
where c_name like '%java%'

-- [1.2]自然连接 学生表、选修表、课程表(自动去重）

select*
from sc 
	natural join course 
	natural join student

#显示student和sc的所有数据,以student的行数为准
-- 显示左表course中的全部记录及右表sc复合连接条件的记录，行数不对等，以左表为主
select* 
from student a   
	left join sc b on a.sno = b.sno

-- 查询所有学生的学号，姓名和可选修的课程号和课程成绩，同时显示未选修课程的学生信息
select a.sno, s_name, cno, grade
from student a
	left join sc b on a.sno=b.sno
			
-- 仅查询曾经修过课程的学生信息
select distinct a.*
from student 
	 join sc b on a.sno=b.sno
		 
# 或（此方法可被select完全替代，所以现在不用了）
select *
from student 
where sno in(select distinct sno 
					from sc)
					
					
# 用子查询所有选修过1002课程的学生信息
select *
from student 
where sno in(select sno 
							from sc
							where cno = '1002')
							

-- 用any子查询比任意 移动班学生年龄小的智能班学生信息
select *
from student 
where s_age < any(select s_age
							from student
							where zno = 'YD')
		and zno = 'ZN'									
		
-- 用all子查询比所有移动班学生年龄小的智能班学生信息
select *
from student 
where s_age < all(select s_age
							from student
							where zno = 'YD')
		and zno = 'ZN'
						
-- 综合练习：
-- 查询计算机学院开设的所有课程的选修平均分，按均分倒排
-- 课程号，课程名，授课教师，平均分（保留两位）
select a.cno , c_name, c_teacher, round(avg(grade),2)
from course a join sc b on a.cno = b.cno
where c_dept = '计算机学院'
group by  cno, c_name, c_teacher 
order by round(avg(grade),2) desc


-- 查询计算机学院开设的所有课程的选修平均分，仅显示平均分大于80的，按均分倒排
-- 显示：课程号，课程名，授课教师，平均分（保留两位）
select a.cno , c_name, c_teacher, round(avg(grade),2)
from course a join sc b on a.cno = b.cno
where c_dept = '计算机学院'
group by  cno, c_name, c_teacher 
	having round(avg(grade),2) > 80
order by round(avg(grade),2) desc

```







## 3.终章-多表2



```mysql
create database staffinfo;
-- 使用员工数据库
USE STAFFINFO;

-- 创建地区表：LOCATIONS
DROP TABLE IF EXISTS LOCATIONS;
CREATE TABLE LOCATIONS (
  LOCATION_ID DECIMAL(4,0) NOT NULL PRIMARY KEY ,
  STREET_ADDRESS VARCHAR(40) DEFAULT NULL  ,
  POSTAL_CODE VARCHAR(12) DEFAULT NULL ,
  CITY VARCHAR(30) NOT NULL ,
  STATE_PROVINCE VARCHAR(25) DEFAULT NULL ,
  COUNTRY_ID CHAR(2) DEFAULT NULL
);

-- 创建部门表：DEPARTMENTS
DROP TABLE IF EXISTS DEPARTMENTS;
CREATE TABLE DEPARTMENTS (
  DEPARTMENT_ID DECIMAL(4,0) NOT NULL PRIMARY KEY,
  DEPARTMENT_NAME VARCHAR(30) NOT NULL ,
  MANAGER_ID DECIMAL(6,0) DEFAULT NULL ,
  LOCATION_ID DECIMAL(4,0) DEFAULT NULL ,
  CONSTRAINT DEP_LO_FK FOREIGN KEY (LOCATION_ID) REFERENCES LOCATIONS (LOCATION_ID)
);

-- 创建员工表：EMPLOYEES
DROP TABLE IF EXISTS EMPLOYEES;
CREATE TABLE EMPLOYEES (
  EMPLOYEE_ID DECIMAL(6,0) NOT NULL PRIMARY KEY ,
  FIRST_NAME VARCHAR(20) DEFAULT NULL ,
  LAST_NAME VARCHAR(25) NOT NULL,
  EMAIL VARCHAR(25) NOT NULL ,
  PHONE_NUMBER VARCHAR(20) DEFAULT NULL ,
  HIRE_DATE DATETIME NOT NULL ,
  JOB_ID VARCHAR(10) NOT NULL,
  SALARY DECIMAL(8,2) DEFAULT NULL ,
  COMMISSION_PCT DECIMAL(2,2) DEFAULT NULL ,
  MANAGER_ID DECIMAL(6,0) DEFAULT NULL ,
  DEPARTMENT_ID DECIMAL(4,0) DEFAULT NULL ,
  CONSTRAINT EMP_DEP_FK FOREIGN KEY (DEPARTMENT_ID) REFERENCES DEPARTMENTS (DEPARTMENT_ID)
);
select*from LOCATIONS;
select*from departments;

-- 观看实验七第三大题设计性试验
insert into student(
	901,'张军','男',1985,'计算机系','北京市海淀区'
	902,'张超','男',1986,'中文系','北京市昌平区'
	903,'张美','女',1990,'中文系','湖南省永州市'
	904,'李五一','男',1990,'英语系','辽宁省阜新市'
	905,'王芳','女',1991,'英语系','福建省厦门市'
	906,'王桂','男',1988,'计算机系','湖南省衡阳市'
);

insert into student(
901,'计算机',98
901,'英语',80
902,'计算机',65
902,'中文',88
903,'中文',95
904,'计算机',70
904,'英语',92
905,'英语',94
906,'计算机',90
906,'英语',85
);


-- （1）查询李五一的考试科目（c_name）和考试成绩（grade）
Select a.c_name,a.grade
From score a join student b on a.stu_id=b.num
Where b.name='李五一';

-- （2）用连接查询的方式查询所有学生的信息和考试信息
Select *
From score a left join score b on a.stu_id=b.num;


-- （3）计算每个学生的总成绩（需显示学生姓名）
Select b.num,b.name,sum(a.grade)
From score a join score b on a.stu_id=b.num
Group by b.num,b.name;


-- （4）计算每个考试科目的平均成绩
Select a.c_name avg(a.grade)
From score a join score b on a.stu_id=b.num
Group by a.c_name;


-- （5）查询计算机成绩低于95的学生的信息
Select a.*
From score a join score b on a.stu_id=b.num
Where a.c_name='计算机' and a.grade<95;


-- （6）查询同时参加计算机和英语考试的学生的信息
Select*
From student
Where num in (select syu_id from score
							where c_name='计算机'
										and stu_id in (select stu_id
																	from score where c_name='英语'));


-- （7）从student表和score表中查询出学生的学号，然后合并查询结果
Select num fron student
Union 
select stu_id from score;


-- （8）查询姓张或者姓王的同学的姓名、院系、考试科目和成绩
Select b.name,b,bumen,a.c_name,a.grade
From score a join score b on a.stu_id=b.num
Where name like '张%' or name like '王%';


-- （9）查询都是湖南的同学的姓名、年龄、院系、考试科目和成绩
Select b.name,year(current_date)-a.birthday,b.num,a.c_name,a.grade
From score a right join score b on a.stu_id=b.num
Where b.address like'%湖南%';


```





## 4.终章-附件

```mysql
-- 【二、函数】
-- 【条件函数】
-- if函数 [if(表达式,为真的值,为假的值)]
-- 小于60分不及格，其余为及格
select*,
			if(grade<60,'不及格','及格') as '是否及格'
from sc;

-- 对成绩分组，优秀：100-90，良好90-80，中等80-70，及格70-60，60以下不及格【case】
select*,
			if(grade<60,'不及格','及格') as '是否及格',
			case
				when grade >=90 then '优秀'
				when grade < 90 and grade >=80 then '良好'
				when grade < 80 and grade >=70 then '中等'
				when grade < 70 and grade >=60 then '及格'
					else '不及格'
			end as '等第'
from sc;
-- *******************************************
-- 部分常用函数****************************************
-- 【数学函数】
-- 四舍五入(3.14567,2)取两位
SELECT ROUND(3.14567,2);
-- ABS取绝对值
SELECT ABS(-12);
-- PI得到圆周率
SELECT PI(); 
-- sqrt(); 求一个数的平方根
SELECT sqrt(144) ;
-- bin十进制转二进制
SELECT bin(10);
-- mod(x,y)  x除数，y被除数。结束是余数。
SELECT mod(10,3);
-- rand() 是用来生成随机数用的
SELECT RAND();


-- 【日期函数】
-- 返回现在时间
SELECT NOW();
-- 返回一年的值：   
SELECT YEAR(NOW());
-- 得到月份： 
SELECT MONTH(NOW());
-- 得到日： 
SELECT DAY(NOW());
-- 返回小时值：
SELECT HOUR(NOW());
-- 返回分钟值：
SELECT MINUTE(NOW());
-- 返回秒数：
SELECT SECOND(NOW());
-- 得到星期几： 
SELECT WEEKDAY(NOW());
-- 计算两个日期之间相隔的天数：
SELECT DATEDIFF(CURRENT_DATE(),‘2000-1-1’);


-- 【字符串函数】
-- 将字符串参数值转换为全小写字母后返回：	
select lower('SQL Course'); 
-- 将字符串参数值转换为全大写字母后返回：	
select upper('Use MYsql');
-- 将多个字符串参数首尾相连后返回： 	
select concat('My','S','QL');
-- 如果参数是数字，则自动转换为字符串：	
select concat(14.3,'mysql');
-- 将多个字符串参数以给定的分隔符separator首尾相连后返回
select concat_ws(‘;’ , ’First name’, 'Second name’, 'Last name’);
-- 删除首尾空格：
select trim('  bar  ');  
-- 字符串替换（大小写敏感）：    
select replace('www.mysql.com','w','X');
-- 返回最左边的len长度的子串：   
select left('chinaitsoft',5);
-- 返回最右边的len长度的子串：   
select right('chinaitsoft',5);     	


-- 【系统函数】
-- VERSION() 返回数据库的版本号
SELECT VERSION() ;
-- CONNECTION_ID() 返回服务器的连接数
SELECT CONNECTION_ID(); 
-- DATABASE()返回当前数据库名
SELECT DATABASE();
-- USER()、SYSTEM_USER()、SESSION_USER()、CURRENT_USER()、CURRENT_USER 返回当前用户
SELECT USER(); 
-- CHARSET(str) 返回字符串str的字符集
SELECT CHARSET('abc'); -- utf8
-- COLLATION(str) 返回字符串str的字符排列方式
SELECT COLLATION('abc'); -- utf8_general_ci
```













































# 拟合数据

## 10.期末复习

### 10.1

1. #=>自增长的类型得是int 2.外键的字长 3.引用的外键得是主键 4.自增长也得是主键
2. #=>修改表的字段应该要加类型
3. #=>mysql会自动修正int为varchat
4. #=>插入要修改int为字符，补齐长度



### 10.2

1. #=> 创建和删除是相对的

2. => 字段类型应根据插入类型修正，entroll_data是登记日期的意思 2.创建外键的首句是constraint，是约束的意思， 建表逻辑是约束 外键名 外键（要约束的本表字段） 参考 其他表（字段） 3.自增长是auto_increment,写在主键后面 4.日期类型是te 5.自增长和外键字段都得是主键，自增长还得是数值类型 6.外键还得在约束前先创建相同字段和字长
3. #=>赋值表的首句是create
4. #=>修改字段的首局是alter 关键词change 2.新字段要加字段类型 3.新字段名写在原字段后面 4.chang的位置和add的位置一样
5. #=>增加列也可以用列column
6. #desc是专用于表的，所以不需要加table
7. #=>insert into 后面加表名 值
8. #=> 要插入特定字段是在表名后面加的 2.日期也是字符必须要加
9. #=>update配合是set 2.update后面跟的是表名 3.update set 不需要配合select from使用 4. update可以配合where使用 5.上面已经把manager 修改为 d_manager
10. #=>删除是elete
11. #=>外键可以做为查询的条件 2.使用连接时，应考虑左右连接 3.字段名唯一时，可以定义了缩写但不要缩写
12. #=>count是聚合函数,出现两个以上不同字段出现就要进行分组 2.可以count(distinct b.e_name)但因为员工的名字可能相同不需要去重 3.字符串匹配得用like
13. #=>保留小数是round 2.默认平均数保留三位小数 3.要显示每个部门的名称 4.对分组条件添加条件才需要having 5.部门可以直接通过部门id来代替，这样就看单表查询
14. #=>筛选出首列用limit(假尾巴) 2.order by默认从上往下慢慢变大
15. #=>日期的月可以是1位数 2.分组条件还有条件要写having
16. #=>去重联合时union，反之union all
17. #=>view 后面那个数是 表名as 2.那个自增长的值是员工号 3.查看视图是通过表和show tables
18. #=>显示一张表的全部查询是表名.* 2.查询多表的两张表只能用联合查询
19. #=>创建索引的三种方式，分别是在表内：索引名，索引类型，(字段名) 修改表：索引类型，索引名(索引来自) 创建表 索引类型 索引名  on 索引来自 
20. #=> 查看所有的索引是 show …… from
21. #=>删除配合的是 on和创建对应 2.要连索引类型一起写上去 3.索引名是先写index
22. #=>删除主键只能用修改的方式 2.删除肯定有drop
23. #=>create 后面跟的是user @前是用户名，后localhost。密码前面是identied 
24. #=>修改用户是alter user
25. #=>查看私有用户是查询mysql.user这张表
26. #=>赋权第一句是grant 2.权限包括 update delete insert select all on 库.表 to 用户 3.权限的增变成了更新 改变成了插 4.权限与权限间用，隔开 5.不包括所有数据库的权限，只能用数据表级别的权限来查询



### 10.3

1. #=>约束是con开头 2.没有来自而是参考 3.参考后面要加s 4.数值和字符统一长度为20  5.当前表的外键字段要加（）
2. #=>没有要求部门名就不需要查询，但要求查询条件为人力部就需要引用另一张表
3. #=>分组条件得是要查询的其中一个字段 2.聚合要写别名
4. #=>出现每个 就说明要分组 2.聚合函数换行写更清晰
5. #=> 分组后出了第一个查询的字段可以不是聚合函数其他的都得是,不然为什么order by进行排序分组，
6. #=> 部门信息，没有指定到查询条件为部门名可以用同意的外键来代替 2.2014以后，所有得>2014
7. #修改索引已经声明过dept 就不需要再写第二遍
8. #=>查看索引用的是from
9. #=>除了字段，其他删除应该只能用drop  2.不能删除一个列表的全部索引，只能指定字段名删除
10. #=>权限间间隔用，
11. #=>表没有给表是on 表已经有是from



## 11.樊晓唯终章

### 11.1

1. #=>不是所有引擎，所有不需要加s 2.默认引擎的的表名和所有的表名都是用_来连接的
2. #=>配置文件是ini
3. #=>是先character 再 set
4. #=>服务器级别是查看配置信息中的两张表 2.配置信息是vari 3.服务器是server
5. #=>存在是ists 2.set后面直接跟gbk 3.gbk不是字符串 4.建表是如果不存在
6. #=>外键名fk写后面
7. #=>modify只能用来修改，add只能用来添加
8. 自增长得在首列
9. 限制行数是从首个下标，向后数几个
10. 修改表删除索引只要在drop 后面加 index 不需要指定索引类型
11. with check option只能防止视图不满足where时修改，但依旧能修改基表
12. 当用;分开的时候，可以同时运行两句语句
13. call p_01('30',@ename) @ename的返回值不能超过1条
14. #=>存储过程的英文为cedure 2.先创建存储过程再写begin 3.存储过程要加（）4.封装的语句要以;结束
5. 三表连接不用用，间隔。只要时连接的直接join就行了
5. 左右连接的左右。显示student和sc的所有数据,行数不对等时，student表的数据一定要显示全，sc表少的自动填充null
5. 外键在查询时一定要注明是哪个表的 select c.sno
5. 多表时应注意行数，和表内是否重复
5. 由于不需要显示未选修的学生信息，所以不需要左连接，只需要筛选掉因选修不同课程而出现两次，但在student表中完全相同的学生就能查询到曾经修过课程的学生信息
5. 目前已知in只能应用于双表
5. 用子查询所有选修过1002课程的学生信息，由于一个学生一学期只能报一个相同的课，所以不需要去重
5. 用any子查询比任意 移动班学生年龄小的智能班学生信息,由于存在不同的智能班级，所以还是用专业号来筛选比较好
5. 复制不用like,得用as





# data_1

> course：数据库技术与应用
>
> teacher：樊晓唯

## -1接口

1.哈希索引和B+树索引是什么







## 0.熵

1. 如何用modify修改主键

2. 自增长是如何实现再外连接的表上增长，又是以什么为映射来自增长的

3. 撤销已经运行的代码，如何做到

4. TRUNCATE能不能像delete from一样加where

5. 为什么无法执行fulltext index index_date(b_date),

6. 所有的建索引都可以直接设置为desc 吗

7. limit 如何表示最后一行

8. 组内筛选除了可以限制列数，还有什么用？如何对分组后的组内数据进行排序

9. #29(超纲.分组之后内部的排序）分别查看男女员工中的最年轻员工的姓名，年龄，入职时间，按入职倒序排序 下列两种写法哪里错了

   ```python
   select e_name,age,enroll_data
   from emp
   where sex in(
   							select sex
   							from emp
   							group by sex 
   							)
   							and 
   							age in (
   							select min(age)
   							from emp
   							group by age
   							)
   
   order by enroll_data desc
   
   
   select sex
   from emp
   where age in (
   							select e_name,min(age),enroll_data
   							from emp
   							order by age
   							limit 0,1
   							)
   group by sex
   order by enroll_data desc
   
   ```
   
10. #按姓名和性别分组，展现最大年龄，最早入职，用简便方法统计行数, 只展现平均年龄在20到27(都包含)的分组信息，按分组排序，输出前4行
    select sex, e_name, max(age) as '最大年龄', min(enroll_data) as '最早入职', count(1) as '行数'
    from emp
    group by e_name, sex
    	having avg(age) BETWEEN 20 and 27;
    order by sex, e_name
    limit 3



### negative

1. 留言id号由系统自动生成用 auto_increment
2. 留言创建日期和时间为系统时间 datetime
3. delect insert,updata是数据操作语言（DML),select 是数据查询语言（SQL）
4. count不会计算空行
5. 自增长的类型得是int和主键
6. 引用外键要保证字长一样同时为主键
7. 修改表的字段是要给新字段要加类型
8. alter table dept add testcol int not null after d_name中add后面省略了column
9. 给表中插入数据时，mysql会自动修正int为varchat，所以不需要给插入的数字加引号
   但在笔试中要加引号和补齐字段个数（自增长）
10. 语句执行顺序： 查询条件where进行筛选——再按group进行分组——再按having对分组进行筛选——在对分组进行排序（order by）
      eg:筛选出性别为男的数据，按年龄进行分组，再筛选出每组的前两个，再按年龄以从小到大而不是原顺序进行查询显示



















## 1.概述

——数据库系统概述

### 1.三级模式是什么

外模式-逻辑结构-内模式

具象化：

​	外模式：学生看到的课表和老师看到的成绩表

​	逻辑结构：表的是怎样的，表和表之间关联是怎样的

​	内模式：数据库的物理存储





### 2.为什么需要三级模式

让数据间逻辑独立和物理独立的一种模式，达到安全共享的目的

 



### 3.如何实现数据独立性

三级模式之间提供了二级映射

 

 

### 4.什么是二级映射

外模式映射和内模式映射

具象化

​	外模式映射：逻辑结构成的一张表让外模式的不同用户看到不同的表

​	内模式映射：内模式变化，外模式也一起变化。映射唯一

 



### 5.什么是数据库

有组织的永久存储在计算机中并且可共享的大量数据的集合

 

 

### 6.什么是数据库管理系统

用户用来管理数据库的一个软件

 

 

### 7.什么是数据库系统

DBS=DB+DBMS+DBAP+DBA+计算机系统（软硬件）

DBAP:基于数据库的应用、

DBA：管理员

-----





## 2.逻辑结构

—— 信息与数据模式：逻辑结构是怎样设计的



### 练1：论文

https://www.processon.com

论文实体的属性包括：论文号、题目、期刊名称、年份、期刊号;

作者实体的属性包括：手机号、姓名、单位、地址

关系：一篇论文可以有多个作者，且每一位作者写过多篇论文，在每一篇论文中有作者的顺序号。

请画出对应的E-R图



![1](https://i0.hdslb.com/bfs/album/e76ee133f2efbd6404eef5083e312689783596e0.png)





### 练2：企业

某企业集团有若干工厂，每个工厂生产多种产品，且每一种产品可以在多个工厂生产，每个工厂按照固定的

计划数量生产产品，计划数量不低于300;每个工厂聘用多名职工，且每名职工只能在一个工厂工作，工厂聘

用职工有聘期和工资。工厂的属性有工厂编号、厂名、地址，产品的属性有产品编号、产品名、规格,职工的

属性有职工号、姓名、技术等级。

请画出对应的E-R图

![2](https://i0.hdslb.com/bfs/album/9101b7c610a6436cb4214f5986ffe36d46992918.png)



### 1.什么是E-R图

实体-关系图

E-R图是概念模型

Tip	

​	1.实体名唯一

​	 2.属性不可再分



### 2.E-R图如何转换成逻辑模型

关系模型：字段，记录，主码，候选码（多个属性组成的字段）

![3](https://i0.hdslb.com/bfs/album/417d4b081705137d848618047ecd70d89222f93b.png)

表名-实体

字段-属性





### 3.不同的联系如何转换

1：1

![4](https://i0.hdslb.com/bfs/album/57c6f664249ddb1d36d25f017eadf6f2508214a9.png)



1：n

![5](https://i0.hdslb.com/bfs/album/f64ca683e5adb89dd9566255b26cae0fee9711b7.png)



m:n

![6](https://i0.hdslb.com/bfs/album/ca19db008cee5a692b2e4d229c2f42644963cbd6.png)



### 4.如何达成关系模型的完整性

实体完整性

实体主键不能为空

参照完整性

表内有外键引用的字段要对应或者为空

表内自引用也要对应

用户自定义完整性

​	数据类型、数据范围、默认值，空、唯一

-------



## 3. MySQl

——MySQl概述



### 1.为什么要用mysql

开源,兼容性

B/C B：Navicat

以前Oracle



### 2.简述mysql体系结构的组成

![7](https://i0.hdslb.com/bfs/album/1b014764b5072816ee9814788ff4921341db5c65.png)

存储引擎：把表转换成物理文件的方式

SQL：结构化查询语言



### 3.mysql安装

《环境配置》-开发级-mysql和navicat

-------------------------------



## 4.存储引擎

—— 存储引擎和数据库基本操作





### 1.常见存储引擎是啥

innodb

​	能处理处理大数据，支持事务和外键，但占空间大

其他

Mylasm 

menory（存储在内存中）



### 2.什么是字符集

存储字符串的方式

​		Mysql默认：latin1 单字节编码

​									汉字是双字节编码



### 3.什么是校验规则

比较两个字符串的方式

​	大小写是否敏感



### 4.有哪几个级别的字符集和校验

服务器

数据库

表

字段





```mysql
-- 一.【1】Mysql存储引擎
-- 1.查看mysql支持的数据存储引擎
show engines;


-- 2.查看默认的存储引擎（innoDB）
-- variables 环境变量
show variables like '%storage_engine%';


-- 3.通过my.ini 查看默认引擎


-- 【2】字符集和校对规则
-- 1.查看系统支持的字符集 41种
show character set;

-- 或者
select *
from information_schema.CHARACTER_SETS; 


-- 2 查看系统支持的校验规则 272条
-- 一种编码 对应 多种校验规则
-- cs大小写敏感 ci不敏感
show collation;


-- 只想看和latin（拉丁）相关的
show collation like '%latin%';


-- 3 服务器级别server
-- 字符集 character_set
show variables like 'character_set_server';


-- 校验规则 ci:大小写不敏感
show variables like 'collation_server';


-- 所有数据库的配置信息，变量和值
show variables;


-- 数据库级别 
-- 字符集 character_set
show variables like 'character_set_database';


-- 校验规则 ci:大小写不敏感
show variables like 'collation_database';

-- ***************************************************

-- 【三、数据库的操作】
-- 1 创建数据库（右键mysql课程-新建数据库）
create DATABASE scf_1; 
-- 使用默认的字符集和校验规则

-- 设置字符集为gbk（汉字特别多）
create DATABASE scf_2 default CHARACTER set gbk;

-- 再创建scf_1 并不显示报错
create database if not exists scf_1;  -- 先检验是否存在，如果不存在则创建。

-- 用带校验的标准格式创建scf_3
create database if not exists scf_3;

-- 2.查看当前的数据库 show
show databases;

-- 查看某一个数据库的详情
show create database scf_2;

-- 3 选择某一个数据库 use
use scf_1;

-- 4.修改数据库编码
alter database scf_1 CHARACTER set gbk; -- utf8 → gbk
alter database scf_1 CHARACTER set utf8; -- gbk → utf8

-- 5.删除数据库 drop
drop database scf_3;

-- 再删，不报错
-- if excits 来校验是否存在，存在则删除，不存在不删除
drop database if exists scf_3;

-- 标准删除
drop database if exists scf_2;
```

--------







## 5.表的修改





### 1.Mysql数据类型分哪些类型

数值

​	整数 查询精度：help tinyint

​		学号：int

​		年龄：tinyint（0-255）

​		数据库成绩：tinyint

​		身份证号：bigint（varchar）

​	浮点

​		月收入：decimal/float

​	定点数：decimal（4，2）整数4位 小数点后面2位

时间日期

​	Date:'2021-10-01'

​	Time: '23:59:59'

​	Year:2021

​	Datetime=timestamp :'2021-10-01 23:59:59'

字符串

​	Char：定长0~255

​	Varchar：自定义最长位，会自动缩位（占空间小，但慢）

​	Text：日记（字符数据）

​	Blob：图片、音频、视频（二进制）

特殊类型：sex enum（‘male’，‘female’，‘unknow’）插入的数据只能3选1



### 2.代码

```mysql
-- 一、表的操作
-- 1.建库schoolInfo数据库
CREATE DATABASE SCHOOLINFO;
-- 2.选择该库
USE schoolinfo;
-- 3.建表-教师信
-- 结构；字段名 字段类型 各种约束条件1 comment字段注释（以防别人奇异）
CREATE TABLE TEACHERINFO(
	id INT(4) PRIMARY KEY NOT NULL UNIQUE AUTO_INCREMENT COMMENT'编号',
	num INT(10) NOT NULL UNIQUE COMMENT'教工号',
	name VARCHAR(20) NOT NULL COMMENT'姓名',
	age INT(3) DEFAULT 30 COMMENT'年龄，默认30',
	sex enum('男','女') NOT NULL COMMENT '性别（男/女）',
	birthday DATE COMMENT '出生日期',
	address VARCHAR(50) COMMENT '家庭地址'
)ENGINE = INNODB charset = utf8
;

-- [2]查看表
-- 查看当前数据库中的所有表
use schoolinfo;
show tables;
-- 查看某一张表的结构（右键-设计表）
describe teacherinfo;
desc teacherinfo;
-- 查看当初的建表语句
show CREATE TABLE teacherinfo;

-- [3]修改表 [alter]
-- 3.1 修改表名【remane】
alter table teacherinfo rename t1;
show tables;
desc t1;

alter table t1 rename as teacherinfo;
show tables;

-- 3.2 添加字段/列 【add】
-- 在teacher表中最后添加一个身份证字段，card char(18)【最后】
alter table teacherinfo add card char(18);
desc teacherinfo;

-- 在teacher表中最前添加一个身份证字段，teatcol3 [first]
alter table teacherinfo add testcol3 char(1) first;
desc teacherinfo;

-- 在name后面添加列【add after】
alter table teacherinfo add testcol1 int after name;
desc teacherinfo;

-- 完整的字段添加。允许添加约束条件【add 字段名 字段类型 字段约束after 前一字段】
alter table teacherinfo add testcol2 time not null unique after address;
desc teacherinfo;

-- 3.3 删除列 【drop】
alter table teacherinfo drop testcol1;
desc teacherinfo;
alter table teacherinfo drop testcol2;
desc teacherinfo;
alter table teacherinfo drop testcol3;
desc teacherinfo;

-- 3.4 修改列的属性 【modify】不能更改列名
-- 更改数据类型， name: varchar(20),改为varchar（50） 【modify 字段名 新的类型】
-- 把name改为 varchar(50)
alter table teacherinfo modify name varchar(50);
DESC teacherinfo;
-- 同时更改数据类型和约束
-- 把name改为 varchar(50) not null DEFAULT'zhangson';
ALTER TABLE teacherinfo modify name varchar(50) not null DEFAULT'zhangson';
desc teacherinfo;
-- 将card字段移动到name之后
alter table teacherinfo MODIFY card char(18) after name;
desc teacherinfo;

-- 3.5 修改列名（同时也能修改属性） 【chage 旧地段名 新字段名 新数据类型 新约束】
-- 修改name为 teacher_name 并添加约束 varchar(20) not null
alter TABLE teacherinfo change name teacher_name varchar(20) not null;
desc teacherinfo;

-- 主键的新增和删除（也可以通过modify实现） 【drop/add primary key】
-- 删除主键
alter table teacherinfo drop PRIMARY key;
-- 新增主键
alter table teacherinfo add PRIMARY key(id);
-- 添加复合主键
-- 给id和num添加复合主键
alter TABLE teacherinfo drop PRIMARY key;
alter table teacherinfo add PRIMARY key(id,num);
-- 【4】 复制表
-- like ：完整的复制，包括字段。属性，约束
create table t1 like teacherinfo;
desc t1;

-- as select 不会拷贝key的信息。SELECT*from teacherinfo 表达读取表中的所有记录。
create table t2 as select*from teacherinfo;
desc t2;
-- [5]删除表【drop】
drop table t1;
show tables;

drop table t2;
show tables;

-- ********************************************************************
-- [外键] 
-- 1.创建并选择数据库 staffdb
create database staffdb;
use staffdb;
-- 2.建父表 部门表
-- 创建表，表名：dapartment 第一列d_id int(4) primary key comment‘部门号’ 第二列 d_name varchar(20)
create table department(
	d_id int(4) primary key comment'部门号',
	d_name varchar(20)
);
-- 3.建子表 员工表。加外键
-- consistent 外键名 foreign key(子表外键字段） references父表（父表字段)
create table worker(
	id int(4) primary key comment'编号',
	num int(10) comment'员工号',
	d_id int(4) comment'部门号',
	constraint worker_fk foreign key(d_id) references dapartment(d_id)
);

-- 4.直接删除父表？NONONO.被引用了，删不了
drop table dapertment;
-- 5.要删父表，首先删除子表的外键约束
alter table worker drop foreign key worker_fk;
-- 6.再来删除父表？ok
drop table department;
show tables;
```

---



## 6.SQL语言



### 1.数据的增删改

```mysql
-- 第六章 数据的增删改
-- 用schoolinfo库，建一张表
USE schoolinfo;
drop table if exists vipuser;
-- 创建vipuser表，用于后续插入演示示例
CREATE TABLE if not exists vipuser (
	username VARCHAR ( 20 ) PRIMARY KEY NOT NULL UNIQUE,
	pswd CHAR ( 32 ) NOT NULL,
	email VARCHAR ( 50 ) DEFAULT 'abc@niit.edu.cn',
	age TINYINT UNSIGNED 
	);-- 查看表结构
DESC vipuser;
-- 插入记录【insert (into)】
-- 1.1 【单条插入，所有字段】
-- 语法： insert （into）  tbl_name（表名）  values（字段1值，字段2值，……）；
INSERT INTO vipuser VALUES ( 'Cat', '123','cat@qq.com',20);
-- 查看表数据
select* FROM vipuser
-- ----------------------------------------------
-- 以下会报错:
INSERT INTO vipuser VALUES ( 'Cat', '123','cat@qq.com');-- 字段数量不匹配


-- 1.2 【单条插入，只插入某些特定字段】
-- 语法：insert into 表名（字段m，字段n，……）values(字段m值，字段n值，……);
-- tips：（1） not null的字段必须要插入 		
-- 			 （2）有默认值的自动填充默认值，有默认值且允许为空的，显示null
INSERT INTO vipuser(username,pswd) VALUES('a', 'aaaa');
INSERT INTO vipuser ( pswd, username )VALUES( 'bbbbb', 'b' ); 
select* FROM vipuser
-- --------------------
-- 以下会报错
INSERT INTO vipuser ( username )VALUES( 'c' );-- pswd没指定因为psw设置notnull
INSERT INTO vipuser ( username, pasw )VALUES( 'a', 'aaa' );-- unique字段重复
INSERT INTO vipuser VALUES( 'c', 'ccc' );-- 列数不匹配-- 1.3【多条，同时插入】


-- 1.3 【多条，同时插入】
-- 语法：insert 【into】 tab_name[(字段名称...)] values(值...),(值...)
-- tips:(1)每条记录之间用逗号隔开 (2)只要第一列不报错，就不会报错
-- tips:(2)如果没有对这个字段继续插入，如指定字段插入会填充默认值，人为定义为空，默认值是不会覆盖的
INSERT INTO vipuser VALUES
	( 'd', 'ddd', 'd@qq.com', 13 ),
	( 'e', 'eee', 'null', 34 ),
	( 'f', 'fff', 'f@qq.com', 19 );
select* FROM vipuser;

	-- 1.4【自增长字段的数据插入】
-- 先删除现有primary key 
-- 新增一个id字段，Primary key,并且设置成自增长
-- 生出的id字段按照1，2，3，4，5，6，7，8自增长
ALTER TABLE vipuser DROP PRIMARY KEY;
ALTER TABLE vipuser ADD id INT PRIMARY KEY auto_increment FIRST;-- 主键默认不为空
DESC vipuser;
SELECT* FROM vipuser;

-- 再要写入新的数据
-- 写法1：用null来表示id
INSERT INTO vipuser VALUES( NULL, 'g', 'ggg', 'gg@qq.com', 40 );
SELECT* FROM vipuser;

-- 写法2：按顺序插入id，不能重复
INSERT INTO vipuser values ( 8, 'H', 'HHH', 'hh@qq.com', 20 );
SELECT* FROM vipuser;

	
-- **************************************************
-- 【2】修改记录【update】
-- 语法： update 表名 set 字段1=新值1,字段2=新值2 [where 筛选条件]
-- 修改id =3 
UPDATE vipuser SET pswd='zero' WHERE id = 3;
SELECT* FROM vipuser;

UPDATE vipuser 
SET email = 'eee@qq.com',
		age=30
WHERE username='E';
SELECT* FROM vipuser;
-- 如果不跟where条件,就是对所有的记录的某一字段进行统一修改。
-- tips：where--- 行的选择。 set---列的选择
-- 修改所有用户的邮箱为默认值 = default
UPDATE vipuser SET email = DEFAULT;
SELECT* FROM vipuser;
	
	
-- **********************************************
-- 【3】 删除记录【delete from】
-- 语法：delete from 表名 【where 条件】
-- 删除id=4的记录
DELETE FROM vipuser  WHERE id = 1;
SELECT* FROM vipuser;

-- 删除id>10的记录
DELETE FROM vipuser WHERE id > 10;
SELECT * FROM vipuser; 
-- 如果不跟where，会删除所有的记录,但是表的定义和所以约束没有删除，也就是说表仍存在。表结构也存在。
-- 删除所有记录
DELETE FROM vipuser;
SELECT* FROM vipuser;
-- drop和delete的区别 --drop连表带记录全没了 delete表会留着
-- 【DELETE 的数据可以回滚，而truncate没有办法回复】
TRUNCATE vipuser;
SELECT * FROM vipuser; 


-- 【补充】delete vs truncate
INSERT INTO vipuser VALUES
	( 'd', 'ddd', 'd@qq.com', 13 ),
	( 'e', 'eee', 'e@qq.com', 34 ),
	( 'f', 'fff', 'f@qq.com', 19 );
select* FROM vipuser;


-- [delete]可以回滚
START TRANSACTION; -- 开启事务

delete from vipuser; -- 删除记录
SELECT*from vipuser;

rollback; -- 回滚数据
select *from vipuser;

-- [truncate]不可以回滚
START TRANSACTION; -- 开启事务

truncate vipuser; -- 删除记录
SELECT*from vipuser;
desc vipuser;

rollback; -- 回滚数据
select *from vipuser;
```



### 2.单表

```mysql
-- 第六章 -2 单表查询
-- 【0】准备工作
-- 0.1 选择schoolinfo
CREATE DATABASE schoolinfo;
use schoolinfo;
drop table student
-- 0.2 建表 student
create table student(
	sno VARCHAR(10) NOT NULL primary key COMMENT '学号',
	s_name VARCHAR(20) NOT NULL COMMENT '姓名',
	s_sex enum('男','女') not null COMMENT '性别',
	s_age TINYINT UNSIGNED COMMENT '年龄',
	s_birthday date COMMENT '生日',
	s_class VARCHAR(10) COMMENT '班级',
	s_address varchar(50) comment '地址',
	s_score decimal(3,1) COMMENT '平均成绩',
	zno VARCHAR(4) COMMENT '专业号'
);
desc student;
-- 0.3 插入数据
insert into student VALUES ('21020301','张一','男',19,'2001-03-01','智能2111','北京',89.5,'ZN');
delete from student;
insert into student values 
	('21020301','张三','男',19,'2001-03-01','智能2111','北京',89.5,'ZN'),
	('21020302','李四','男',20,'2001-03-02','智能2111','北海',80,'ZN'),
	('21020303','王五','女',21,'2001-03-03','智能2111','南京',82,'ZN'),
	('21020304','赵六','女',22,'2001-03-04','智能2121','南京',84,'ZN'),
	('21020305','张一一','女',18,'2001-03-05','移动2113','南通',85,'YD'),
	('21020306','张一二','女',18,'2001-03-05','移动2113','南昌',85,'YD'),
	('21020307','李五','男',30,'2001-02-07','移动2112','海口',90,'YD'),
	('21020308','李六','女',30,'2001-02-08','智能2121','上海',72,'ZN'),
	('21020309','冯小刚','男',30,'2001-02-09','智能2121','广州',73.5,'ZN'),
	('21020310','陈凯歌','男',30,'2001-02-10','移动2113','广西',67,'YD'),
	('21020311','葛优','男',30,'2001-02-11','移动2112','苏州',92,'YD'),
	('21020312','徐峥','男',30,'2001-05-12','移动2112','无锡',91.5,'YD'),
	('21020313','黄渤','男',30,'2001-05-13','智能2131','镇江',89.5,'ZN'),
	('21020314','李诞诞','男',30,'2001-05-14','智能2131','常州',80,'ZN'),
	('21020315','李诞','男',30,'2001-05-14','智能2111','常州',80,'ZN'),
  ('21020316','李诞','男',30,null,null,null,83,'YD');

-- 【1】简单查询（没有where条件的查询）【select from】
-- 【1.1】查询表中所有的列 【*：所有列】
select * from student;

-- 【1.2】查询指定的列
select s_class
from student;

select s_class,sno,s_name
from student;
-- 【1.3】去重查询【DISTINCT】
SELECT DISTINCT s_class
from student;

SELECT DISTINCT s_class, s_sex
from student;

-- 【1.4】给列取别名 【as】
select sno as '学号',
			s_class as '班级',
			s_name as '姓名'
from student;

-- 【1.5】给表取别名 【as】
SELECT T.sno as '学号',
      T.s_class as '班级',
			T.s_name as '姓名'
from student as T;



-- 【1.6】对字段进行加工处理
SELECT s_class, s_name, s_score, s_score + 1.1 as '提升10%后的成绩'
from student;

SELECT s_class, s_name, s_age, s_age * 1.1 as '提升10%后的年龄'
from student;

-- 【2】带有where条件的查询
-- select是对列的筛选，where是对行的筛选
-- 【2.1】比较大小 【=,<,>,>=,<=,<>不等于】
-- 成绩在(70，80]范围的学生的sno,sname,score
select sno,s_name,s_score
from student
where s_score >70
		and s_score <=80
;
 
-- 年龄小于18岁，或大于25岁的学号，姓名，年龄
select sno,s_name,s_score
from student
where s_score <18
	or s_score >=25
;

-- 【2.2】指定范围【IN，BETWEEN AND(含头尾)】
-- 查询成绩为75或85，或95的同学的所有信息。
select *
from student
where s_score = 75 or s_score = 85 or s_score = 95;
-- 写法2：in
select *
from student
where s_score in (75,85,95);

-- 查询地址在南京，上海，北京的所有同学的所有信息
select *
from student
where s_address in ('南京','上海','北京')
;
-- 查询成绩在80-90之间的学生信息；between and
select *
from student
where s_score BETWEEN 80 and 90;

-- 【2.3】判断为空【is null, is not null】
-- 生日为空的学生信息
select *
from student
where s_birthday is null;

select *
from student
where s_birthday is not null;

-- 【2.4】字符串匹配【LIKE , not LIKE , = 完全匹配】【%：任意长度：_:单一字符长度】
select * from student where s_name = '李诞';
select * from student where s_name like '李%'; -- 以李开头
select * from student where s_name like '李_'; -- 李某
select * from student where s_name like '李__'; -- 李某某
select * from student where s_name like '%一%'; -- 名字中任意位置包含“一”的同学
select * from student where s_name not like '李%'; -- 非以李开头
-- 智能开头，倒数第二位是2的信息。
select * from student where s_class like '智能%2_';


-- 【3】高级查询
-- 【3.1】限制输出的条数【limit x】
select *
from student
limit 5;

-- 【3.2】对筛选出的结构排序【order by】
-- 语法：ORDER BY [字段名1，字段名2] ASC(升序，默认)|DESC(降序）
-- tips：null在升序时，排在最前，降序时排在最后
-- 按生日排序
select *
from student
ORDER BY s_birthday ASC;
-- 按成绩降序排序
select *
from student
ORDER BY s_score desc
-- 按成绩降序，生日排序
select *
from syudent
ORDER BY s(score desc, s_age asc)


-- 【3.3】聚合函数（sum,count,max,min,avg)
-- count：计算的是非空的行数
-- 班级人数
SELECT count(sno)
from student;

-- 计算学号，性别，年龄。班级的行数2
select count(sno),
			count(s_sex),
			count(s_age),
			count(s_class)
from student;

-- 去重DISTINCT
select count(sno) as '班级人数',
			count(distinct s_sex) as '性别数',
			avg(s_age) as '平均年龄',
			count(distinct s_class) as '所在班级数'
from student;

select distinct s_class from student;


-- 练：班级人数。平均年龄，班级数。最高分，最低分，平均分，总分，最小的生日
select count(sno) as '班级人数',
			avg(s_age) as '平均年龄',
			count(distinct s_class) as '班级数',
			max(s_score) as '最高分',
			min(s_score) as '最低分',
			avg(s_score) as '平均分',
			sum(s_score) as '总分',
			min(s_birthday) as '最小的生日'
from student
;
			

-- 【3.4】分组函数【group by】
-- 语法：group by 字段名1，字段名2【having 条件】
-- tips:GROUP BY之后跟的字段，通常放在select里的最前面
-- 按照班级，来统计每个班的最高分和最低分。
select s_class,max(s_score),min(s_score)
from student
group by s_class
;

-- 智能2111班的男女成绩的最高分和平均分
SELECT s_sex,max(s_score),min(s_score)
FROM student
where s_class='智能2111'
GROUP BY s_sex

-- 按照班级和性别分组，统计人数及年龄的最小值
SELECT s_class,s_sex,count(sno),min(s_age) 
-- count(1)计算行数
FROM student
GROUP BY s_class,s_sex

-- 按顺序排
SELECT s_class,s_sex,count(1),min(s_age) 
-- count(1)计算行数
FROM student
GROUP BY s_class,s_sex
-- 注释不能写在句子后面
order by s_class,s_sex
limit 3
;
  
-- 【having条件】组内筛选
-- tips：where条件是全局条件,having条件是分组内的条件
-- 按班级分组，展现最高分，最低分，只展现平均分在80分以上且再90分以下的班级信息
SELECT s_class,max(s_score),min(s_score)
FROM student
GROUP BY s_class
		having avg(s_score)>=80 and avg(s_score)<90
;

--   按照班级不为空的记录，按照班级和性别分组，展示最高分，最低分，平均分，只展现组内最大年龄<30的班级信息，按平均分降序排序。
SELECT s_class,s_sex,max(s_score),min(s_score),avg(s_score)
FROM student
where s_class is not null 
-- 不为空不是<>NULL
GROUP BY s_class,s_sex
		having max(s_age)<30
ORDER BY avg(s_score) DESC
;
```



### 3.多表

```mysql
-- 第六章-3-多表查询
-- 【0】准备工作
-- 使用schoolinfo数据库
use schoolinfo;

delete from sc;
delete from course;
delete from student;
delete from specialty;

-- 创建几张表，并插入数据
-- 【0.1】专业表
-- 【0.1】创建专业表：specialty
DROP TABLE IF EXISTS specialty;
CREATE TABLE specialty (
  zno VARCHAR(4) NOT NULL PRIMARY KEY ,
  z_name VARCHAR(50) NOT NULL
);

-- 【0.2】创建课程表：course
DROP TABLE IF EXISTS course;
CREATE TABLE course (
  cno VARCHAR(8) NOT NULL PRIMARY KEY,
  c_name VARCHAR(50) NOT NULL ,
	c_credit int not null,
	c_teacher VARCHAR(20) not null,
	c_dept VARCHAR(20) not null
);
select*from course;

-- [0.3]学生表student,增加外键，引用自专业表（zno）
-- 要先删除student表的记录
delete from student;
Alter table student add CONSTRAINT stu_fk foreign key(zno)REFERENCES specialty (zno);

-- 【0.4】创建选修表：sc
DROP TABLE IF EXISTS sc;
CREATE TABLE sc (
	sno VARCHAR(10) NOT NULL,
	cno VARCHAR(8) NOT NULL,
	grade FLOAT(4) not null,
	PRIMARY KEY(sno, cno),
	CONSTRAINT sc_stu_FK FOREIGN KEY(sno) REFERENCES student(sno),
	CONSTRAINT sc_c_FK FOREIGN KEY(cno) REFERENCES course(cno)
);

-- 【以上建表结束】---------------------
-- 插入数据-- 专业表
insert into specialty values
	('ZN', '人工智能'),
	('YD', '移动应用开发'),
	('RJ', '软件工程');
-- 插入数据-- 课程表
insert into course values
	('1001', '数据库技术',3,'李雷','计算机学院'),
	('1002', 'Java程序设计',3,'韩梅梅','计算机学院'),
	('1003', '高等数学',4,'王小明','公共基础学院'),
	('1004', '线性代数',3,'张老师','公共基础学院'),
	('1005', 'C语言',3,'葛优','计算机学院');
-- 插入数据-- 学生表
insert into student values
	('21020301','张一','男',19,'2001-03-01','智能2111','北京',89.5,'ZN'),
	('21020302','李四','男',17,'2001-03-02','智能2111','北海',80,'ZN'),
	('21020303','王五','女',21,'2001-03-03','智能2111','南京',82,'ZN'),
	('21020304','赵六','女',22,'2001-03-04','智能2121','南京',84,'ZN'),
	('21020305','张一一','女',18,'2001-03-05','移动2113','南通',85,'YD'),
	('21020306','张一二','女',18,'2001-03-05','移动2113','南昌',85,'YD'),
	('21020307','李五','男',30,'2001-02-07','移动2112','海口',90,'YD'),
	('21020308','李六','女',30,'2001-02-08','智能2121','上海',72,'ZN'),
	('21020309','冯小刚','男',16,'2001-02-09','智能2121','广州',73.5,'ZN'),
	('21020310','陈凯歌','男',30,'2001-02-10','移动2113','广西',67,'YD'),
	('21020311','葛优','男',30,'2001-02-11','移动2112','苏州',92,'YD'),
	('21020312','徐峥','男',30,'2001-05-12','移动2112','无锡',91.5,'YD'),
	('21020313','黄渤','男',30,'2001-05-13','智能2131','镇江',89.5,'ZN'),
	('21020314','李诞诞','男',30,'2001-05-14','智能2131','常州',80,'ZN'),
	('21020315','李诞','男',30,'2001-05-14','智能2111','常州',80,'ZN'),
	('21020316','李诞','男',30,null,null,null,83,'YD');

-- 插入数据-- 选课表
insert into sc values
	('21020301','1001',89.5),
	('21020302','1001',78),
	('21020303','1001',58),
	('21020304','1001',80),
	('21020305','1001',70),
	('21020306','1001',56),
	('21020307','1001',84),
	('21020301','1002',90),
	('21020302','1002',89),
	('21020303','1003',74),
	('21020304','1003',95),
	('21020305','1002',70),
	('21020306','1002',83),
	('21020307','1003',82);

select*from specialty;
select*from student;
select*from sc;
-- ********************************
-- 以上建表结束

-- 【1】连接查询
-- 内连接-- 等值查询（最常用）【inner】 join
-- 概念：【连接条件】用来连接两个表的条件，两个表中都出现的，且类型一样的字段。如：专业号，课程号
-- 语法：select 字段名 from A join 	B on A.xx=B.xx where 表达式
-- 显示学生的选课成绩和对应的课程信息
select * from sc join course on sc.cno = course.cno;

-- 检索选修了1002课程的学生的成绩和课程信息
-- select sc.sno,sc,grade,course.c_name,course.c_teacher
-- from sc join course on sc.cno = course.cno 
-- where sc.cno ='1002';

-- 检索选修了1002号课程的学生信息和选课成绩
select*
from student as s join sc on s.sno=sc.sno

-- 练习：检索专业名为移动应用开发的学生学号，姓名，专业名
SELECT student.sno,
				student.s_name,
				specialty.z_name
from student join specialty on student.zno =specialty.zno
where specialty,z_name='移动应用开发'
-- 简写
SELECT A.sno,A.s_name,B.z_name
from student  A join specialty  B on A.zno = B.zno
where B.z_name='移动应用开发';

select t1.sno,t1.s_name,t2.z_name
from student as t1 join specialty as t2 on t1.zno =t2.zno
where t2.z_name='移动应用开发';

-- 【多表查询】
-- 语法：from A join B on A.XX=B.xx
								-- join C on A.xx=C.yy
-- 检索选修了李老师的课程的学生学号，姓名，班级，课程表，成绩。教师名
select A.sno,A.s_name,A.s_class,
			C.c_name,B.grade,C.c_teacher
from student as A join sc B on A.sno=B.sno
								join course C on B.cno=C.cno
where C.c_teacher like'李%';

-- 多表练习：
-- 检索选修了Java课程的同学学号，姓名，课程名和成绩
select A.sno,A.s_name,C.c_name,B.grade
from student A
	join sc B on A.sno = B.sno
	join course C on B.cno = C.cno
where C.c_name='java程序设计';

select t1.sno,t1.s_name,t3.c_name,t2.grade
from student as t1
	join sc as t2 on t1.sno = t2.sno
	join course as t3 on t2.cno = t3.cno
-- where t3.c_name = 'java程序设计';
where t3.c_name like 'java%';
-- =>运行所选中不可空行


-- [1.2]内连接-- 自然连接(不常用）【natural join 不用on】
-- tips:会自动按照两表中相同的列做join，不需要写on连接条件
-- tips：去掉重复的字段
select*from sc join course  on sc.sno=course.cno

SELECT*from sc natural join course;
select*from student natural join sc natural join course;
select*from  sc natural join course natural join student;
-- **************************************

				
-- [1.3]外连接--左外连接【left [outer] join】左表的基础上补充右表的信息。
-- 显示左表中的所有数据。如果在右表有相应的值就显示，没有就为null
-- 显示左表中的全部记录及右表复合连接条件的记录（以左为主）
select *
from student as t1
left join sc t2 on t1.sno=t2.sno
-- 查询所有的学生的信息，以及他们选修的课程号和课程成绩
select A.*,B.cno,B.grade
from student A 
	left join sc B on A.sno=B.sno

-- 练习：查询所有的课程被学生选课的信息、显示：课程号，课程名，学号
select A.cno,A.c_name,B.sno,B.grade
from course A left join sc B on A.cno=B.cno

-- [1.4]右外连接 【right [outer] join】右表为基础表，补充左表的信息
select*
from sc A right join course B on A.cno = B.cno;

-- *************************************************************************

-- 【2】联合查询，多张表的结果进行拼接 union(会去重) unionall
-- union 会删除重复记录，union all不会
-- 查询全校师生的姓名
SELECT s_name from student;
union
SELECT c_teacher from course
-- 列数必须相等，否则会报错 类型不一样会强行转换
SELECT s_name,s_class from student;
union
SELECT c_teacherfrom course


-- 【3】子查询【=，in】
-- 语法：SELECT frome where 字段 in (select 子句）
-- 仅查询曾经修过课程的学生信息
-- 写法1：join
SELECT A.*
-- 去除重复字段 distinct select distinct A.*
from student A join sc B on A.sno=B.sno
-- 写法2：in
select*
from student;
where sno in(select distinct sno from sc);
-- 一样的效果select distinct sno from sc;
-- 所有的in都可以用join来改写

-- 练习：查询所有选修过1002课程的学生信息
select*from student
where sno in(select  sno from sc where cno=1002);

-- [any、all]
-- 查询比任意 移动班学生年龄小的智能班学生信息
select *
from student
where s_age <any(select s_age from student where zno='YD')
		and zno='ZN';
-- 查询比所有移动班学生年龄小的智能班学生信息
select *
from student
where s_age <all(select s_age from student where zno='YD')
		and zno='ZN';
			
-- 综合练习：
-- 查询计算机学院开设的所有课程的选修平均分，按均分倒排
-- 显示：课程号，课程名，授课教师，平均分
SELECT A.cno,A.c_name,A.c_teacher,round(avg(grade),2)
-- 默认聚合函数前面的都是分组字段
from course A join sc B on A.cno=B.cno
where A.c_dept='计算机学院'
group by A.cno,A.c_name,A.c_teacher
order by avg(grade) desc

```

----





## 7.索引



```mysql
-- 第七章-索引
-- 索引更快，但会占内存
-- 【1】创建索引
-- 【1.1】创建表的饮食建索引
-- 创建一个图书馆数据库 library
create database library;
use library;

-- 语法：[unique|fulltext] index 索引名（字段名【(长度）】【desc|asc】

-- 建表：book:isbn,b_name
create table book_1(
	isbn char(17) primary key, -- 书号
	b_name varchar(50), -- 书名
	b_author varchar(50), -- 作者
	b_date date, -- 出版日期
	b_abs TEXT,  -- 摘要 长文本
	b_pub varchar(50),  -- 出版社
	INDEX index_name (b_name), -- 普通索引
	INDEX index_author(b_author(20)), -- 普通索引，带长度只对前20位建索引
	unique index index_isbn(isbn desc), -- 唯一性索引，设置降序，默认升序ASC
	fulltext index index_abs(b_abs), -- 全文索引
	index index_pub(isbn,b_pub)  -- 多列索引
);




-- 【1.2】已有表：添加索引,使用create index
create table book_2(
	isbn char(17) primary key, -- 书号
	b_name varchar(50), -- 书名
	b_author varchar(50), -- 作者
	b_date date, -- 出版日期
	b_abs TEXT,  -- 摘要 长文本
	b_pub varchar(50)  -- 出版社
);

-- 语法：create [unique|fulltext] index 索引名 on 表名（字段名[(长度）][asc|desc}
create index index_name on book_2(b_name);
create index index_author on book_2(b_author(20));
create  unique index index_isbn on book_2(isbn desc); -- 唯一性索引，设置降序，默认升序ASC
create	fulltext index index_abs on book_2(b_abs); -- 全文索引
create	index index_pub on book_2(isbn,b_pub);  -- 多列索引
	
-- 【1.3】已有表：添加索引,使用alter table add index
create table book_3(
	isbn char(17) primary key, -- 书号
	b_name varchar(50), -- 书名
	b_author varchar(50), -- 作者
	b_date date, -- 出版日期
	b_abs TEXT,  -- 摘要 长文本
	b_pub varchar(50)  -- 出版社
);

-- 语法：create [unique|fulltext] index 索引名 on 表名（字段名[(长度）][asc|desc}
alter table book_3 add index index_name(b_name);
alter table book_3 add index index_auther(b_author(20));
alter table book_3 add unique index index_isbn(isbn desc);
alter table book_3 add fulltext index index_abs(b_abs);
alter table book_3 add index index_pub(isbn,b_pub);

create index index_name on book_2(b_name);
create index index_author on book_2(b_author(20));
create  unique index index_isbn on book_2(isbn desc); -- 唯一性索引，设置降序，默认升序ASC
create	fulltext index index_abs on book_2(b_abs); -- 全文索引
create	index index_pub on book_2(isbn,b_pub);  -- 多列索引
		
	
	
-- 【2】查看索引 [show index]
show index from book_1;
-- non_unique0是唯一 
-- 方式2 
show create table book_2;

CREATE TABLE `book_2` (
  `isbn` char(17) NOT NULL,
  `b_name` varchar(50) DEFAULT NULL,
  `b_author` varchar(50) DEFAULT NULL,
  `b_date` date DEFAULT NULL,
  `b_abs` text,
  `b_pub` varchar(50) DEFAULT NULL,
  PRIMARY KEY (`isbn`),
  UNIQUE KEY `index_isbn` (`isbn` DESC),
  KEY `index_name` (`b_name`),
  KEY `index_pub` (`isbn`,`b_pub`),
  KEY `index_author` (`b_author`(20)),
  FULLTEXT KEY `index_abs` (`b_abs`)
) ENGINE=InnoDB DEFAULT CHARSET=utf8mb3


-- 【3】删除索引
-- 【3.1】drop index on (对应1.2）
show index from book_1;
drop index index_name on book_1;
show index from book_1;

-- 【3.2】alter table 表名 drop index 索引名（对应1.3）
alter table book_1 drop index index_pub;
show index from book_1;
-- =>不管删除什么类型的索引都是用index

-- tip:主键一个表只要一个，删除主键的可以不指定名称
-- 只会删一个字段的其中一个索引
-- 只有primary key可以不写索引名
alter table book_1 drop primary key;
show index from book_1;
```

---



## 8.视图



```mysql
-- 第八章 视图 view
-- 视图的优势：独立性

-- 使用schoolinfo数据库的course sc specialty student 四张表
use schoolinfo;

-- 【1】创建视图
-- create view 视图名 as select 语句
-- 【1.1】单表上创建视图
-- 创建移动班学生学号，姓名，班级的视图 名称：v_yd_stu
create view v_yd_stu as
	select sno,s_name,s_class
	from student 
	where s_class like '移动%'
;

-- 创建智能班学生学号，性别，年龄的视图 名称v_zn_stu
create view v_zn_stu as
	select sno,s_sex,s_age
	from student
	where s_class like '智能%'
;

-- 为上表指定新的字段名num，sex和age
-- 先删除
create view v_zn_stu(num,sex,age) as
	select sno,s_sex,s_age
	from student
	where s_class like '智能%'
;

-- [1.2]多表上创建视图
-- 创建视图v_grade,显示多表的学号，课程名，成绩，学分
desc student;
create view v_grade as
	select B.sno,A.c_name,B.grade,A.c_credit
	from course A join sc B on A.cno=B.cno
;

-- 【2】查看视图（双击）
-- 视图一旦创建好，在使用上，与table没什么区别
-- 【2.1】查看当前数据库的所有视图
select*
from information_schema.views
where table_schema = 'schoolinfo';

select `schoolinfo`.`student`.`sno` AS `sno`,`schoolinfo`.`student`.`s_name` AS `s_name`,`schoolinfo`.`student`.`s_class` AS `s_class` from `schoolinfo`.`student` where (`schoolinfo`.`student`.`s_class` like '移动%')

-- 也可以
show tables; -- 视图也会被发现

-- 【2.2】视图结构
-- 视图是虚拟表，所以没有key
desc v_yd_stu;

-- 【2.3】查看视图的定义
show create view v_yd_stu;

CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v_yd_stu` AS select `student`.`sno` AS `sno`,`student`.`s_name` AS `s_name`,`student`.`s_class` AS `s_class` from `student` where (`student`.`s_class` like '移动%')

-- 【2.4】查看视图的内容
select*from v_yd_stu;
 -- *******************************************************************
 
-- 【3】删除视图
drop view v_yd_stu;
-- *******************************************************************

-- 【4】修改视图的定义（修改select语句）
alter view v_zn_stu as -- 后跟一个新的select
	select sno,s_name,s_class,s_sex,s_age
	from student
	where s_class like '智能%'
				and s_age>20;
;
select*from v_zn_stu;

-- ****************************************************************
-- 【5】更新视图的内容
select*from v_zn_stu;
-- 【5.1】修改视图数据，看看基表的变化？
-- 在v_zn_stu上把王五女变男
update v_zn_stu
set s_sex='男'
where s_name='王五'

select*from v_zn_stu; -- 视图变了
select*from student;  -- 基表也变

-- 【5.2】修改基表数据，看看视图的变化？
-- 把黄渤智能2131改成2151
update student
set s_class='智能2151'
where s_name='黄渤'

select*from student; -- 基表变了
select*from v_zn_stu; 

-- 视图很多时候无法更新


-- ******************************************************************

-- 【6】 关于 with check option
-- 对于需要去做数据操作的视图，可以加上with check option.更新数据的时候，要满足where条件
create  view v_zn_check as -- 后跟一个新的select
	select sno,s_name,s_class,s_sex,s_age
	from student
	where s_class like '智能%'
				and s_age>20
with check option;

select*
from v_zn_check

-- 对比v_zn_stu和v_zn_check有什么区别
update v_zn_stu
set s_age=10
where s_name='李六';
-- 基表
select* from student;
-- 视图
select* from v_zn_stu; -- 更新后李六变得不会在再被筛选出来，基表也改变了。

-- 【v_zn_check】
select* from v_zn_check;

update v_zn_check
set s_age=10
where s_name='黄渤'; -- 报错 check option failedn'school.v_zn_check'
-- 由于年龄不满足建表语句where 所以报错
```

---





## 9.存储过程

——存储过程与函数



```mysql
-- 第九章 存储过程和函数
use schoolinfo;
-- 【一、】存储过程
-- 【1】变量的定义和使用
-- 方法1：set
-- 自定义pi=3.1415926 并查询(一下都查询)
set @pi=3.1415926;
select @pi;

-- 方法2：select into
-- 从sc表中取grade的最大值，并定义给max_grade
select max(grade) into @max_grade
from sc;
select @max_grade

-- 从sc表中取课程号为1001的grade的最小值，并定义给min_grade
select min(grade) into @min_grade
from sc
where cno='1001';
select @min_grade

-- 查询所有的用户的自定义的变量名(会话变量只在当前会话中有效)
select*
from `performance_schema`.user_variables_by_thread;

-- *************************************************************
-- 【2】创建存储过程
-- 【2.1】创建不带参数的存储过程
-- 查询student表所有记录
select * from student;
-- 改为存储过程(封装过程)
delimiter $$
create procedure p01()
begin
		select * from student
end $$
delimiter ;

-- 调用
call p01();

-- 返回姓名=张一的所有信息
delimiter $$
create procedure p_01()
begin
		select * 
		from student
		where s_name = '张一';
end $$
delimiter ;
call p_01();

-- 查看存储过程的定义
show create procedure p_01;

-- 删除
drop procedure p_01

-- 【2.2】带有入参的存储过程-- 传参【in】
delimiter $$
create procedure p_02(in sname varchar(20))
begin
	select*
	from student
	where s_name=sname;
end $$
delimiter ;

-- 调用
call p_02('李诞')

-- 入参班级号，输出的学号，姓名，年龄
-- 写错要先drop函数
desc student;
select* from student


delimiter $$
create procedure p_02_class(in class varchar(20))
begin
	select sno,s_name,s_age
	from student
	where s_class=class;
end $$
delimiter ;

call p_02_class('智能2111');

-- 【2.3】创建带输出的存储过程【out 参数名 参数类型】
select sno 
from student
where s_name='张一'；
-- 存储过程：输入：姓名， 输出：学号->变量
-- 入参是张一 出参return是学号
delimiter $$
create procedure p_03(in sname VARCHAR(20),out ssno varchar(20))
begin
		select sno into ssno
		from student
		where s_name=sname;
end $$
delimiter ;
-- 调用
call p_03('张一',@studentsno)
select @studentsno;

-- 【2.4】创建inout类型的存储过程，入参和回参是同一个变量
delimiter $$
create procedure p_04(inout grade float)
begin
		set grade = grade*1.1;
end $$
delimiter ;

-- 调用之前先定义一个变量
set @mygrade=80;
call p_04(@mygrade);
select @mygrade;

-- ***********************************************************
-- 【二、函数】
-- 【条件函数】
-- if函数 [if(表达式,为真的值,为假的值)]
-- 小于60分不及格，其余为及格
select*,
			if(grade<60,'不及格','及格') as '是否及格'
from sc;

-- 对成绩分组，优秀：100-90，良好90-80，中等80-70，及格70-60，60以下不及格【case】
select*,
			if(grade<60,'不及格','及格') as '是否及格',
			case
				when grade >=90 then '优秀'
				when grade < 90 and grade >=80 then '良好'
				when grade < 80 and grade >=70 then '中等'
				when grade < 70 and grade >=60 then '及格'
					else '不及格'
			end as '等第'
from sc;
-- *******************************************
-- 部分常用函数****************************************
-- 【数学函数】
-- 四舍五入(3.14567,2)取两位
SELECT ROUND(3.14567,2);
-- ABS取绝对值
SELECT ABS(-12);
-- PI得到圆周率
SELECT PI(); 
-- sqrt(); 求一个数的平方根
SELECT sqrt(144) ;
-- bin十进制转二进制
SELECT bin(10);
-- mod(x,y)  x除数，y被除数。结束是余数。
SELECT mod(10,3);
-- rand() 是用来生成随机数用的
SELECT RAND();


-- 【日期函数】
-- 返回现在时间
SELECT NOW();
-- 返回一年的值：   
SELECT YEAR(NOW());
-- 得到月份： 
SELECT MONTH(NOW());
-- 得到日： 
SELECT DAY(NOW());
-- 返回小时值：
SELECT HOUR(NOW());
-- 返回分钟值：
SELECT MINUTE(NOW());
-- 返回秒数：
SELECT SECOND(NOW());
-- 得到星期几： 
SELECT WEEKDAY(NOW());
-- 计算两个日期之间相隔的天数：
SELECT DATEDIFF(CURRENT_DATE(),‘2000-1-1’);


-- 【字符串函数】
-- 将字符串参数值转换为全小写字母后返回：	
select lower('SQL Course'); 
-- 将字符串参数值转换为全大写字母后返回：	
select upper('Use MYsql');
-- 将多个字符串参数首尾相连后返回： 	
select concat('My','S','QL');
-- 如果参数是数字，则自动转换为字符串：	
select concat(14.3,'mysql');
-- 将多个字符串参数以给定的分隔符separator首尾相连后返回
select concat_ws(‘;’ , ’First name’, 'Second name’, 'Last name’);
-- 删除首尾空格：
select trim('  bar  ');  
-- 字符串替换（大小写敏感）：    
select replace('www.mysql.com','w','X');
-- 返回最左边的len长度的子串：   
select left('chinaitsoft',5);
-- 返回最右边的len长度的子串：   
select right('chinaitsoft',5);     	


-- 【系统函数】
-- VERSION() 返回数据库的版本号
SELECT VERSION() ;
-- CONNECTION_ID() 返回服务器的连接数
SELECT CONNECTION_ID(); 
-- DATABASE()返回当前数据库名
SELECT DATABASE();
-- USER()、SYSTEM_USER()、SESSION_USER()、CURRENT_USER()、CURRENT_USER 返回当前用户
SELECT USER(); 
-- CHARSET(str) 返回字符串str的字符集
SELECT CHARSET('abc'); -- utf8
-- COLLATION(str) 返回字符串str的字符排列方式
SELECT COLLATION('abc'); -- utf8_general_ci
```



## 10.用户权限



```mysql
-- 第十章 用户管理和权限管理
-- 【1】用户管理
-- 【1.1】查看当前所以的用户信息【mysql.user】
-- host：本机还是远程 远程是ip地址 用本地sql是是losthost(也是ip地址）
select host,user
from mysql.user

-- 【1.2】创建一个人普通用户【create user】
-- 语法：create user 用户@地址 indentified by 密码
create user 'zhangsan'@'localhost' identified by '123456';
create user 'scf'@'localhost' identified by '123456';

-- navicat可以自动识别 create user zhangsan@localhost identified by '123456'

-- 【1.3】修改用户名 【rename 旧名字 to 新名字】
rename user 'zhangsan'@'localhost' to 'lisi'@'localhost';

-- [1.4] 修改密码 【alter user】
alter user  'lisi'@'localhost' identified by '888888';

-- 【1.5】删除用户【drop user】
drop user 'lisi'@'localhost';

-- 【2】权限管理 select update delete insert
-- 【2.1】为用户授权【grant】权限类型+范围
-- 语法：grant 权限类型 on 库.表 to 用户
-- 为sxf赋权：可以查询所有数据库的所有表
grant select on *.* to 'scf'@'localhost' -- (所有库.所有表)


-- 赋给scf所有权限
grant all on *.* to 'scf'@'localhost' -- (所有权限


create user 'scf_1'@'localhost' identified by '123';
-- scf_1赋权：school.student表 查询权限
grant select on schoolinfo.student to 'scf_1'@'localhost';

-- scf_1赋权，library的所有表的查询、插入、更新、删除权限
grant select,insert,update,delete on library.* to 'scf_1'@'localhost';

-- 【2.2】查看用户的授权情况 【四张表】
-- (1) 全局权限
select * from mysql.user;

-- (2) 数据库级别
select * from mysql.db;

-- (3) 数据表级别
select * from mysql.tables_priv;

-- (4) 数据列级别
select * from mysql.columns_priv;

-- 【2.3】权限的撤销 【revoke】撤销需要与grant对应
-- 全部撤销 scf
revoke all on *.* from 'scf'@'localhost';
select * from mysql.user;

-- 撤销fxw_1在school.student的select权限
revoke select on school.student from 'scf_1'@'localhost';
select * from mysql.user;

```



## 11.期末复习



> 题纲
>
> 《数据库技术与应用》期末复习
>
> 适用专业：人工智能
>
> 
>
> **闭卷**考试，题型：
>
> 一、选择题（30分）15*2分
>
> 二、填空题（20分）10*2分
>
> 三、简答题（20分）4*5分
>
> 四、SQL题（30分）5*6分
>
>  
>
> 复习以复习提纲和作业为准，重点知识如下：
>
> 
>
> **第一章：****数据库系统概述信息与数据模型**
>
> l 数据库（DB）、数据库管理系统（DBMS）、数据库系统（DBS）的定义和区别
>
> l 数据库系统的特点
>
> l 概念模型、E-R图（实体、属性，3种联系1:1，1:N：M:N）要求会画E-R图
>
> l E-R图向关系模型的转换，要求会进行转换，并指出关系模式的码
>
> 
>
> **第二章： MySQL****数据库的创建与管理**
>
> l 创建数据库
>
> l 选择数据库
>
> l 修改数据库名称
>
> l 删除数据库
>
> 
>
> **第三章：****MySQL****数据表定义和完整性约束**
>
> l 常见数据类型（数值型、日期时间、字符串）
>
> l 创建表
>
> l 字段约束（主键约束、外键约束、非空约束、唯一约束、自增约束）
>
> l 查看数据表结构
>
> l 修改数据表（修改表名、修改字段数据类型、修改字段名、添加数据表字段、删除字段、修改字段排序）Alter
>
> l 删除数据表
>
> 
>
> **第四章：****数据操作管理**
>
> l 表数据插入、更新、删除操作（insert，update，delete（truncate区别））
>
> l 单表查询（条件查询，列别名，group by，having，order by，limit）
>
> l 多表查询（join，left join）
>
> 
>
> **第五章： MySQL****索引**
>
> l 索引的作用和分类
>
> l 创建索引
>
> l 查看索引
>
> l 删除索引
>
> 
>
> **第六章： MySQL****视图**
>
> l 视图的优点和创建机制，视图和基表的区别
>
> l 创建视图，删除视图
>
> l 查看视图定义、修改视图定义
>
> 
>
> **第七章：MySQL****存储过程**
>
> l 存储过程的概念
>
> l 创建存储过程（参数列表：参数模式3种、参数名、参数类型）
>
> 
>
> **第****八****章：MySQL****用户管理及权限管理**
>
> l User表的添加用户、查看用户、删除用户
>
> l 给用户授权grant基本语法，回收revoke用户权限语法
>
> l 查看用户授权情况的4张表（mysql.user、db、tables_priv、columns_priv）
>
>  





```mysql
/*期末复习 练习
1.	画E-R图
实体：部门，属性有部门号，部门名，部门经理，地址；员工，属性有员工号，姓名，性别，年龄，入职日期，部门号。一个部门包含多个员工，员工只能在一个部门工作。

2.	上述ER图转换关系模型
*/

#3.	建库exam
create database exam;

#4.	选择库exam
use exam;

#5.	查看系统中所有库
show databases;

#6.	删除库exam
drop database exam;

#7.	重新建库并选择exam
create database exam
use exam

#8.	建表，部门表dept（d_id, d_name, manager, address）
create table dept(
d_id varchar(20) primary key,
d_name varchar(20),
manager varchar(20),
address varchar(30)
);
desc dept
drop table dept

#9.	建表，员工表emp(e_id自增, e_name, sex, age, enroll_date, d_id) 外键
create table emp(
	e_id int(10) primary key auto_increment,
	e_name varchar(20),
	sex varchar(20),
	age varchar(30),
	enroll_data date,
	d_id varchar(20), 
	constraint fk_did foreign key (d_id) references dept(d_id)
);

drop table emp;
#=>自增长的类型得是int 2.外键的字长 3.引用的外键得是主键 4.自增长也得是主键

#10.	复制表，dept_1
create table dept_1 like dept

#11.	删除表dept_1
drop table dept_1;

#12.	修改表dept，修改manager为d_manager
alter table dept change manager d_manager varchar(30)
# =>修改表的字段应该要加类型

#13.	修改表dept，在d_name后增加列testcol int not null
alter table dept add testcol int not null after d_name
alter table dept column testcol int not null after d_name;
#14.	修改表dept，删除testcol列
alter table dept drop testcol;

#15.	查看dept的表结构
desc dept;

#16.	查看dept的建表语句
show create table dept;

#17.	查看数据库中所有的表
show tables;


/*18.	Dept数据插入
100,'财务部','张三', '北京'
200,'销售部','丽丽', '上海'
300,'人力部,'李四', '南京'
400,'市场部','李二', '南宁'
*/

Insert into dept values
(100,'财务部','张三', '北京'),
(200,'销售部','丽丽', '上海'),
(300,'人力部','李四', '南京'),
(400,'市场部','李二', '南宁');
#=>mysql会自动修正int为varchat

/*19.	Emp数据插入
'Alex',男,30,2015-01-01,100
'Emy',女,26,2014-08-02,100
'王二',男,31,2012-01-01,200
'小明',男,24,2017-11-01,300
'王三',男,30,2014-01-01,200
'陈一',女,26,2015-08-22,100
'王六',男,39,2010-01-01,200
'赵五',女,22,2019-08-01,400
'赵五',女,25,2013-05-01,400
'赵五',女,28,2015-06-01,400
'赵六',女,22,2019-08-01,400
*/
/*
insert into emp values #或emp(对应字段)
(null,'Alex','男',30,'2015-01-01,100',100),
(null,'Emy' ,'女',26,'2014-08-02,100',100),
(null,'王二','男',31,'2012-01-01,200',200),
(null,'小明','男',24,'2017-11-01,300',300),
(null,'王三','男',30,'2014-01-01,200',200),
(null,'陈一','女',26,'2015-08-22,100',100),
(null,'王六','男',39,'2010-01-01,200',200),
(null,'赵五','女',22,'2019-08-01,400',100),
(null,'赵五','女',25,'2013-05-01,400',200),
(null,'赵五','女',28,'2015-06-01,400',200),
(null,'赵六','女',22,'2019-08-01,400',400);
*/

insert into emp values
(null,'Alex','男',30,'2015-01-01',100),
(null,'Emy','女',26,'2014-08-02',100),
(null,'王二','男',31,'2012-01-01',200),
(null,'小明','男',24,'2017-11-01',300),
(null,'王三','男',30,'2014-01-01',200),
(null,'陈一','女',26,'2015-08-22',100),
(null,'王六','男',39,'2010-01-01',200),
(null,'赵五','女',22,'2019-08-01',400),
(null,'赵五','女',25,'2013-05-01',400),
(null,'赵五','女',28,'2015-06-01',400),
(null,'赵六','女',22,'2019-08-01',400);


#=>插入要修改int为字符，补齐长度

#20.	更新dept表，市场部经理更为张小五

update dept 
set d_manager = '张小五'
where d_name = '市场部'
select*
from dept

#21.	删除emp表中赵六的记录
delete from emp
where e_name = '赵六'

select*
from dept


#22.	查看dept表的所有数据
select *
from dept;

#23.	查找emp表的所有数据
select*
from emp;

#24.	查看去重后的员工姓名
select distinct e_name
from emp;

#25.	查看女员工的姓名和入职月数
select e_name, enroll_data
from emp
where sex = '女'

#26.	查看人力部的员工姓名和年龄
select b.e_name,b.age
from dept a right join emp b on a.d_id=b.d_id
where a.d_name = '人力部'

#27.	查看地址以“南”开头的部门的部门名，员工人数
select a.d_name,count(b.e_id) as '员工数量'
from dept a join emp b on a.d_id=b.d_id
where a.address like '南%'
group by a.d_name

#28.	查看每个部门的员工的平均年龄和最早入职时间（别名）
select d_id,
				avg(age) as '平均年龄',
				min(enroll_data) as '最早入职时间'
from emp
group by d_id;

#29(超纲）.分组之后内部的排序	分别查看男女员工中的最年轻员工的姓名，年龄，入职时间，按入职倒序排序


#29	分别查看女员工中的最年轻员工的姓名，年龄，入职时间
select e_name, age, enroll_data
from emp
where sex = '女'
order by age
limit 0,1;

#30.	查看每个部门中2014年以后入职的员工的人数，最小年龄，显示大于2人的部门信息，按人数倒序排序。
select d_id, count(e_id), min(age)
from emp
where enroll_data > '2014-01-01'
group by d_id
	having count(e_id)>2
order by count(e_id) desc;


#31.	查看最年长的三个男员工信息
select *
from emp
where sex = '男'
order by age desc
limit 3;


#32.	显示所有的经理名和员工名
select e_name
from emp
union all
select d_manager from dept;



#33.	创建男员工员工号，姓名，年龄，部门名的视图
create view view1 as
	select e_id,e_name,age,d_name
	from dept join emp on dept.d_id = emp.d_id
	where sex = '男';
	
#34.	创建丽丽管理的员工信息的视图
create view view2 as
	select emp.*
	from dept join emp on dept.d_id = emp.d_id
	where dept.d_manager = '丽丽';


#35.	查询丽丽理的员工信息的视图的定义语句
show create view view2;

#36.	删除丽丽管理的员工信息的视图
drop view view2;

#37.	在dept的d_id上创建唯一性索引，倒排
alter table dept add unique index index_id(d_id desc);

#38.	在emp的入职日期上创建普通索引
create index index_enroll on dept(enroll_data);

#39.	查看所有的索引
show index from dept;
show index from emp;

#40.	删除在emp的入职日期上的索引
drop index index_enroll on emp;

#41.	删除dept的主键
alter table dept drop primary key;

#42.	以root登录，创建用户testuser，密码xxx
create user 'testuser'@'localhost' identified by'xxx';

#43.	修改testuser，密码为123456
alter user 'testuser'@'localhost' identified by'123456';

#44.	查看系统中所有的用户
select * from mysql.user;

#45.	为testuser赋权，exam库的emp表，select和update权限
grant select,update on exam.emp to 'testuser'@'localhost';


#46.	撤销testuser的exam库的emp表的select权限
revoke select on exam.emp from 'testuser'@'localhost';
```





## 实践

### 1.存储引擎

```mysql
-- 第四章  mysql存储引擎和数据库操作
删除scf_1、scf_2数据库

-- 查看当前mysql支持的数据存储引擎
show engines;
-- =>engine 后加s

-- 查看默认的存储引擎（innoDB）
show variables like '%storage_engine%'
-- =>默认保存在配置信息里 2.存储是storage 3.配置信息是var

-- 或者
-- =>是填my.ini

-- 查看系统支持的字符集
show character set;

-- 或者 查表
SELECT*
from information_schema.CHARACTER_SETS;


-- 查看系统支持的校验规则
show collation;
-- =>排序的英文拼写是collation

-- 只想看和latin（拉丁）相关的校验规则
show collation like '%latin%';

-- 查看服务器级别的字符集和校验规则
show variables like 'character_set_server'
show variables like 'collation_server'
-- =>在配置信息里也有校验规则

-- 查看所有数据库的配置信息，变量和值
show variables;

-- 查看数据库级别的字符集和校验规则
show variables like 'character_set_database'
show variables like 'collation_database'

-- 创建数据库scf_1
create database scf_1;

-- 创建字符集为gbk的数据库scf_2
create database scf_2 default character set gbk;
-- =>修改的内容写在scf_2后面

-- 带校验的标准格式创建scf_3
create database if not exists scf_3;
-- =>存在exsist 2.创建是is not

-- 查看当前的所有数据库
show databases;

-- 查看scf_2数据库的详情
show create database scf_2;
CREATE DATABASE `scf_2` /*!40100 DEFAULT CHARACTER SET gbk */ /*!80016 DEFAULT ENCRYPTION='N' */
-- =>要注明是创建语句

-- 选择某一个数据库scf_1
use scf_1;

-- 修改scf_1字符集编码为gbk
alter database scf_1 CHARACTER set gbk
-- =>修改是alter，插入是insert

-- 删除数据库scf_3
drop database scf_3;

-- 标准格式删除scf_2
drop database if exists scf_2;

```

---







### 2.表的修改

```mysql
-- 一、表的操作
-- [1]建表
-- 1.建库schooliInfo数据库
create database schoolinfo;
-- 2.选择该库
use schoolinfo;
-- 3.建表-教师表teacherinfo【看word】
create table teacherinfo(
	id int(4) primary key not null unique	auto_increment comment'编号',
	num int(10) not null unique comment'教工号',
	name varchar(20) not null comment'姓名',
	age int(3) DEFAULT 30 comment'年龄，默认30',
	sex enum('男','女') not null comment'性别男/女',
	birthday date comment'出生日期',
	address varchar(50) comment'家庭地址'
)
;
-- =>1.自增长是auto_increment 2.engine = innodb charset = utf8 3.有默认值最好备注默认值 如'年龄，默认30' 4.默认是数值不用加'' 5.日期是date 6.每段用，隔开

-- [2]查看表
-- 查看当前数据库中的所有表
show tables;

-- 查看教师表的结构（右键-设计表）
desc teacherinfo;

-- 查看当初教师表的建表语句
show create table teacherinfo;

-- [3]修改表 
-- 3.1 修改表名
-- 修改教师表名为t1，查询库内所有表，并改回名字
alter table teacherinfo rename t1;
show tables
alter table t1 rename teacherinfo;
show tables

-- 3.2 添加字段/列 
-- 在teacher表最后添加一个身份证字段，card char(18),并查看表
alter table teacherinfo add card char(18);
desc teacherinfo;
-- =>1.最后是默认的 2.alter table后面跟的一定是表名

-- 在teacher表中最前添加一个身份证字段，teatcol3 char，并查看设计表(以下都要这样验证)
alter table teacherinfo add teatcol3 char first;
desc teacherinfo;

-- 在name后面添加列testcol1 int
alter table teacherinfo add testcol1 int after name;
desc teacherinfo;

-- 完整的字段添加
-- 为testcol2 添加新约束 time not null unique 
alter table teacherinfo add testcol2 time not null unique;
desc teacherinfo;
-- =>添加字段和约束都用add

-- 3.3 删除列
-- 分别删除testcol1，testcol2，testcol3列
alter table teacherinfo drop testcol1;
alter table teacherinfo drop testcol2;
alter table teacherinfo drop testcol3;
desc teacherinfo;

-- 3.4 修改列的属性
-- 更改数据类型
-- 把name改为 varchar(50)
alter table teacherinfo modify name varchar(50);
desc teacherinfo;
-- =>modify相当于代替add的位置

-- 同时更改数据类型和约束
-- 把name改为 varchar(50) not null DEFAULT'zhangson';
alter table teacherinfo modify name varchar(50) not null DEFAULT'zhangson';
desc teacherinfo;

-- 将card字段移动到name之后
alter table teacherinfo modify card char(18) after name;
desc teacherinfo;
-- =>移动字段时要跟后面的数据类型

-- 3.5 修改列名（同时也能修改属性） 
-- 修改name为 teacher_name 并添加约束 varchar(20) not null
alter table teacherinfo  change name teacher_name varchar(20) not null;
desc teacherinfo;
-- =>修列名原列名前要用change连接，modify没用
 
-- 主键的新增和删除（也可以通过modify实现）
-- 删除主键（有两种方式，用最好用的一种方法）
alter table teacherinfo drop primary key;

-- 新增主键（id）
alter table teacherinfo add primary key(id);

-- 添加复合主键
-- 给id和num添加复合主键（要先另一种方法删除主键）
alter table teacherinfo drop primary key;
desc teacherinfo;
alter table teacherinfo add primary key(id,num);
-- ?如何用modify修改主键

-- 【4】 复制表
-- 用完整的复制，包括字段。属性，约束 复制teacherinfo为t1
create table t1 like teacherinfo;
show tables;
-- =>复制表的语法 创造表like+原表

-- 用不会拷贝key的信息的复制。读取表中的所有记录到t2
create table t2 as select*from teacherinfo;
show tables;
-- =>读取表中所有数据是as select*from+原表名

-- [5]删除上述两张新建的表
drop table t1;
drop table t2;
show tables;
-- =>删除表 drop后面要加table
-- ********************************************************************

-- [外键] 
-- 1.创建并选择数据库 staffdb，并使用
create database staffdb;
use staffdb;

-- 2.建父表 部门表
-- 创建部门表，表名：dapartment 第一列d_id int(4) primary key comment'部门号' 第二列 d_name varchar(20)
create table department(
	d_id int(4) primary key comment'部门号',
	d_name varchar(20)
);

-- 3.建子表 员工表worker。id int(4) primary key comment'编号'，num int(10) comment'员工号'，d_id int(4) comment'部门号', 第4列 把部门表d_id作为外键给到员工表的d_id
create table worker(
	id int(4) primary key comment'编号',
	num int(10) comment'员工号',
	d_id int(4) comment'部门号',
	constraint worker_fk foreign key(d_id) references dapartment(d_id)
);

-- 创建外键的语句是：constraint 添加外键的子表名_fk foreign key(子表外键字段） refernces父表（父表字段)

-- 5.删父表(先删子表外键）
alter table worker drop foreign key worker_fk;
drop table department;
show tables;



```

---



### 3.数据的增删改

```mysql
-- 第六章 数据的增删改
-- 使用schoolinfo库
use schoolinfo;
-- 删除如果存在vipuser表
drop table if exists vipuser;
-- 存在是exists
-- 创建vipuser表，用于后续插入演示示例
CREATE TABLE if not exists vipuser (
	username VARCHAR ( 20 ) PRIMARY KEY NOT NULL UNIQUE,
	pswd CHAR ( 32 ) NOT NULL,
	email VARCHAR ( 50 ) DEFAULT 'abc@niit.edu.cn',
	age TINYINT UNSIGNED 
	);
DESC vipuser;
-- 插入记录
-- 1.1 单条插入，所有字段
-- 插入：'Cat', '123','cat@qq.com',20
insert into vipuser values('Cat', '123','cat@qq.com',20);
-- =>插入是insert into...values(...)

-- 查看表数据
select*from vipuser;
-- ----------------------------------------------

-- 1.2 单条插入，插入某些特定字段（以下都要显示表数据验证）
-- 给username,pswd分别插入'a', 'aaaa'
insert into vipuser(username,pswd) values ('a','aaaa');
select*from vipuser;
-- =>插入指定字段是表名（）

-- 给pswd, username分别插入'bbbbb', 'b‘
insert into vipuser(pswd,username) values ('bbbb','b');
select*from vipuser;
-- --------------------

-- 1.3 多条，同时插入
-- 同时插入	'd', 'ddd', 'd@qq.com', 13 ，'e', 'eee', null, 34 ，'f', 'fff', 'f@qq.com', 19 
insert into vipuser values
	('d', 'ddd', 'd@qq.com', 13),
	('e', 'eee', NULL, 34),
	('f', 'fff', 'f@qq.com', 19);
select*from vipuser;
-- =>insert 还需要（）来隔开，最后用；

-- 1.4【自增长字段的数据插入】
-- 先删除现有primary key 
-- 新增一个id字段int，Primary key,并且设置成自增长,放在列首
-- 生出的id字段按照1，2，3，4，5，6，7，8自增长
alter table vipuser drop primary key;
alter table vipuser add id int primary key auto_increment first;
desc vipuser;
select*from vipuser;
-- 再要写入新的数据
-- 写法1：自动增长 插入G
insert into vipuser values (null,'g', 'ggg', 'gg@qq.com', 40);
select*from vipuser;

-- 写法2：手动字长 插入H
insert into vipuser values (8,'h','hhh','hh@qq.com',20);
select*from vipuser;

-- 自动增长同时插入i,g,k
insert into vipuser values 
			(null,'i', 'ggg', 'gg@qq.com', 40),
			(null,'j', 'ggg', 'gg@qq.com', 40),
			(null,'k', 'ggg', 'gg@qq.com', 40);
select*from vipuser;


	
-- **************************************************
-- 【2】修改记录
-- 修改，id 为3 列的pswd改为‘zero’
update vipuser set pswd='zero'
where id=3;
select*from vipuser;
-- =>1.修改字段用的是update set 2.updata的重命名直接用‘=’

-- 修改username为e的一行email = 'ee@qq.com',age=31
update vipuser
set email='ee@qq.com',
	age=31
where username='e';
select*from vipuser;
-- wrong：username=e的e没有加’‘

-- 修改所有用户的邮箱为默认为default
update vipuser
set email=default;
select*from vipuser;
	
-- **********************************************
-- 【3】 删除记录
-- 删除id>10的记录
delete from vipuser where id>10;
select*from vipuser;

-- 删除所有记录，并回滚
start transaction;
delete from vipuser;
rollback;
select*from vipuser;
-- 1.开启事务是：start transaction 2。回滚直接是rollback；

-- 删除所有记录，不可回滚
truncate vipuser;
select*from vipuser;
```

---







### 4.单表

```mysql
-- 第六章 -2 单表查询
-- 【0】准备工作
-- 0.1 选择schoolinfo
CREATE DATABASE schoolinfo;
use schoolinfo;
drop table student
-- 0.2 建表 student
create table student(
	sno VARCHAR(10) NOT NULL primary key COMMENT '学号',
	s_name VARCHAR(20) NOT NULL COMMENT '姓名',
	s_sex enum('男','女') not null COMMENT '性别',
	s_age TINYINT UNSIGNED COMMENT '年龄',
	s_birthday date COMMENT '生日',
	s_class VARCHAR(10) COMMENT '班级',
	s_address varchar(50) comment '地址',
	s_score decimal(3,1) COMMENT '平均成绩',
	zno VARCHAR(4) COMMENT '专业号'
);
desc student;
-- 0.3 插入数据
insert into student VALUES ('21020301','张一','男',19,'2001-03-01','智能2111','北京',89.5,'ZN');
delete from student;
insert into student values 
	('21020301','张三','男',19,'2001-03-01','智能2111','北京',89.5,'ZN'),
	('21020302','李四','男',20,'2001-03-02','智能2111','北海',80,'ZN'),
	('21020303','王五','女',21,'2001-03-03','智能2111','南京',82,'ZN'),
	('21020304','赵六','女',22,'2001-03-04','智能2121','南京',84,'ZN'),
	('21020305','张一一','女',18,'2001-03-05','移动2113','南通',85,'YD'),
	('21020306','张一二','女',18,'2001-03-05','移动2113','南昌',85,'YD'),
	('21020307','李五','男',30,'2001-02-07','移动2112','海口',90,'YD'),
	('21020308','李六','女',30,'2001-02-08','智能2121','上海',72,'ZN'),
	('21020309','冯小刚','男',30,'2001-02-09','智能2121','广州',73.5,'ZN'),
	('21020310','陈凯歌','男',30,'2001-02-10','移动2113','广西',67,'YD'),
	('21020311','葛优','男',30,'2001-02-11','移动2112','苏州',92,'YD'),
	('21020312','徐峥','男',30,'2001-05-12','移动2112','无锡',91.5,'YD'),
	('21020313','黄渤','男',30,'2001-05-13','智能2131','镇江',89.5,'ZN'),
	('21020314','李诞诞','男',30,'2001-05-14','智能2131','常州',80,'ZN'),
	('21020315','李诞','男',30,'2001-05-14','智能2111','常州',80,'ZN'),
  ('21020316','李诞','男',30,null,null,null,83,'YD');

-- 【1.1】查询表中所有的列 
select*
from student

-- 【1.2】查询s_class，s_name两列
select s_class,s_name
from student

-- 【1.3】对s_class去重查询，再对【1.2】去重查询
select distinct s_class
from student;
select distinct s_class,s_name
from student;
-- => 去重是ct，对两项只用写一次

-- 【1.4】给sno列取别名为‘学号’，s_class 为 '班级',s_name 为 '姓名'，并查询
select sno as '学号',
			s_class as '班级',
			s_name as '姓名'
from student;

-- 【1.5】在1.4的基础上给表student取别名为t
select t.sno as '学号',
			t.s_class as '班级',
			t.s_name as '姓名'
from student  t;

-- 【1.6】对字段s_score。和s_age提升10%后以'提升10%后的成绩'的别名显示查询
SELECT S_score *1.1 as '提升10%后的成绩',s_age *1.1 as '提升10%后的年龄'
FROM student

-- [2.1]查询成绩在(70，80]范围的学生的sno,s_name,s_score
SELECT sno,s_name,s_score
FROM student
where s_score>70 
		and s_score<=80;
 
-- 条件查询年龄s_age小于18岁，或大于25岁的学号，姓名，成绩
SELECT sno,s_name,s_score
FROM student
where s_age>25 
		or s_age<80;
 
-- [2.2]写法1：条件查询成绩为75或85或95的同学的所有信息。
SELECT*
FROM student
where s_score=75 or s_score=85 or s_score=95;

-- 写法2：指定范围查询
SELECT*
FROM student
where s_score in(75,85,95);

-- 指定查询地址在南京，上海，北京的所有同学的所有信息
SELECT*
FROM student
where s_address in('南京','上海','北京');


-- 指定查询成绩在80-90之间的学生信息
SELECT*
FROM student;
where s_score BETWEEN 80 and 90
-- =>between还需要一个and

-- 【2.3】查询生日为空的学生信息，再查询不为空
SELECT* 
FROM student
where s_birthday is null

SELECT* 
FROM student
where s_birthday is not null 
-- 1.条件都是where，select只是显示内容 2.;在哪就在哪显示一次，与下面的取消关联

-- 【2.4】字符串匹配【LIKE , not LIKE , = 完全匹配】【%：任意长度：_:单一字符长度】
-- 查询名字为李诞的所有数据
SELECT* 
FROM student
where s_name='李诞'

-- 查询以李开头的同学的所有数据
SELECT* 
FROM student
where s_name like'李%'

-- 查询以李某的所有数据
SELECT* 
FROM student
where s_name like'李_'

-- 查询以李某某的所有数据
SELECT* 
FROM student
where s_name like'李__'

-- 查询以名字中任意位置包含“一（yi）”的同学的所有数据
SELECT* 
FROM student
where s_name like'%一%'

-- 查询非以李开头的同学的所有数据
SELECT* 
FROM student
where s_name  not like'李%'
-- =>like取反是 not like

-- 查询班级智能开头，倒数第二位是2的信息。
SELECT* 
FROM student
where s_class like'智能%2_' 
-- =>对同一个字段的字符串查询用一个like就行

-- 【3.1】查询表中前5列的列 
SELECT* 
FROM student
limit 5
-- 查询表中第2列到第四列 linit 1,4
SELECT* 
FROM student
limit 1,3
-- =>第二列的索引是1，往后2列，2+1=3

-- 【3.2】按生日排序查询所有信息
SELECT* 
FROM student
order by s_birthday;

-- 按成绩降序排序查询所有信息
SELECT* 
FROM student
order by s_score desc;

-- 按成绩降序，生日升序排序
SELECT* 
FROM student
order by s_score desc, s_birthday asc;



-- 【3.3】计算班级人数
select count(sno)
from student;
-- =>1.聚合函数可以和分组函数分开使用 2.计数函数是count

-- 计算学号，性别，年龄。班级的行数
select count(sno),
			count(s_sex),
			count(s_age),
			count(s_class)
FROM student;
-- =>count（）里只能有一个字段

-- 计算学号，性别，班级的行数，年龄的平均数(保留三位小数），班级和性别去重，并显示含义
select count(sno)as'学号数',
			count(distinct s_sex) as '性别数',
			round(avg(s_age),3) as '年龄数',
			count(distinct s_class) as '班级数'
FROM student;
-- =>1.distinct是写（）里面的，2.count的含义是**数 3.round(x,3)是保留三位小数

-- 练：同上，并求最高分，最低分，平均分，总分，最小的生日。并显示含义
select count(sno)as'学号数',
			count(distinct s_sex) as '性别数',
			round(avg(s_age),3) as '年龄数',
			count(distinct s_class) as '班级数',
			max(s_score) as '最高分',
			min(s_score) as '最低分',
			sum(s_score) as '总分',
			min(s_birthday) as '最小的生日'
FROM student;
			
-- 【3.4】按照班级，来统计每个班的最高分和最低分。
select s_class,max(s_score),min(s_score)
from student
GROUP BY s_class;

-- 智能2111班的男女成绩的最高分和平均分
select s_sex ,max(s_score),min(s_score)
from student
where s_class='智能2111'
GROUP BY s_sex;

-- 按照班级和性别分组，用简便方法统计人数及年龄的最小值
select s_class,s_sex,count(1),min(s_age)
from student
GROUP BY s_class,s_sex;

-- 对上述按分组顺序排序，输出前8行
select s_class,s_sex,count(1),min(s_age)
from student
GROUP BY s_class,s_sex
order by s_class,s_sex
limit 8;
  
-- 按班级分组，展现最高分，最低分，只展现平均分在80分以上且再90分以下(都包含)的班级信息
select s_class,max(s_score),min(s_score)
from student
group by s_class
	having avg(s_score) BETWEEN 80 and 90;
-- =>BETWEEN连用的是and 2.聚合函数不能在where被使用 3.聚合函数的组内筛选直接换行用having

-- 按照班级不为空的记录，按照班级和性别分组，展示最高分，最低分，平均分(2位)，只展现组内最大年龄<30的班级信息，按平均分降序排序。
select s_class,s_sex,max(s_score),min(s_score),round(avg(s_score),2)
from student
where s_class is not null
group by s_class,s_sex
	having max(s_age) < 30
order by avg(s_score) desc;


	
	
```

---







### 5.多表

```mysql
-- 第六章 多表查询
-- 【0】准备工作
-- 使用schoolinfo数据库
use schoolinfo;

delete from sc;
delete from course;
delete from student;
delete from specialty;

-- 创建几张表，并插入数据
-- 【0.1】专业表
-- 【0.1】创建专业表：specialty
DROP TABLE IF EXISTS specialty;
CREATE TABLE specialty (
  zno VARCHAR(4) NOT NULL PRIMARY KEY ,
  z_name VARCHAR(50) NOT NULL
);

-- 【0.2】创建课程表：course
DROP TABLE IF EXISTS course;
CREATE TABLE course (
  cno VARCHAR(8) NOT NULL PRIMARY KEY,
  c_name VARCHAR(50) NOT NULL ,
	c_credit int not null,
	c_teacher VARCHAR(20) not null,
	c_dept VARCHAR(20) not null
);
select*from course;

-- 1.[0.3]学生表student,增加外键，对已有的字段名zno引用自专业表（zno）（注：student表结构延续至单表)
-- 要先删除student表的记录
delete from student;
desc student;
alter table student add constraint stu_fk foreign key(zno) references specialty(zno);
desc student;
-- =>1.删除是te 2.修改表添加外键第一句是add 外键constraint 你想要的外键名(一般是自己的表名+你要连的表的缩写后加_fk)  foreign key(表内想要连接的字段) references 外键来源 3.专业表是speci a l t y

-- 【0.4】创建选修表：sc
DROP TABLE IF EXISTS sc;
CREATE TABLE sc (
	sno VARCHAR(10) NOT NULL,
	cno VARCHAR(8) NOT NULL,
	grade FLOAT(4) not null,
	PRIMARY KEY(sno, cno),
	CONSTRAINT sc_stu_FK FOREIGN KEY(sno) REFERENCES student(sno),
	CONSTRAINT sc_c_FK FOREIGN KEY(cno) REFERENCES course(cno)
);
show tables;

-- 【以上建表结束】---------------------
-- 插入数据-- 专业表
insert into specialty values
	('ZN', '人工智能'),
	('YD', '移动应用开发'),
	('RJ', '软件工程');
-- 插入数据-- 课程表
insert into course values
	('1001', '数据库技术',3,'李雷','计算机学院'),
	('1002', 'Java程序设计',3,'韩梅梅','计算机学院'),
	('1003', '高等数学',4,'王小明','公共基础学院'),
	('1004', '线性代数',3,'张老师','公共基础学院'),
	('1005', 'C语言',3,'葛优','计算机学院');
-- 插入数据-- 学生表
insert into student values
	('21020301','张一','男',19,'2001-03-01','智能2111','北京',89.5,'ZN'),
	('21020302','李四','男',17,'2001-03-02','智能2111','北海',80,'ZN'),
	('21020303','王五','女',21,'2001-03-03','智能2111','南京',82,'ZN'),
	('21020304','赵六','女',22,'2001-03-04','智能2121','南京',84,'ZN'),
	('21020305','张一一','女',18,'2001-03-05','移动2113','南通',85,'YD'),
	('21020306','张一二','女',18,'2001-03-05','移动2113','南昌',85,'YD'),
	('21020307','李五','男',30,'2001-02-07','移动2112','海口',90,'YD'),
	('21020308','李六','女',30,'2001-02-08','智能2121','上海',72,'ZN'),
	('21020309','冯小刚','男',16,'2001-02-09','智能2121','广州',73.5,'ZN'),
	('21020310','陈凯歌','男',30,'2001-02-10','移动2113','广西',67,'YD'),
	('21020311','葛优','男',30,'2001-02-11','移动2112','苏州',92,'YD'),
	('21020312','徐峥','男',30,'2001-05-12','移动2112','无锡',91.5,'YD'),
	('21020313','黄渤','男',30,'2001-05-13','智能2131','镇江',89.5,'ZN'),
	('21020314','李诞诞','男',30,'2001-05-14','智能2131','常州',80,'ZN'),
	('21020315','李诞','男',30,'2001-05-14','智能2111','常州',80,'ZN'),
	('21020316','李诞','男',30,null,null,null,83,'YD');

-- 插入数据-- 选课表
insert into sc values
	('21020301','1001',89.5),
	('21020302','1001',78),
	('21020303','1001',58),
	('21020304','1001',80),
	('21020305','1001',70),
	('21020306','1001',56),
	('21020307','1001',84),
	('21020301','1002',90),
	('21020302','1002',89),
	('21020303','1003',74),
	('21020304','1003',95),
	('21020305','1002',70),
	('21020306','1002',83),
	('21020307','1003',82);

select*from specialty;
select*from student;
select*from sc;
-- ********************************
-- 以上建表结束

-- 【1】连接查询
-- 内连接
-- 2.显示学生成绩和对应的课程信息
select *
from sc A join course B on A.cno=B.cno
-- =>join配合on用 2.连个表连接一定有外键 3.join左边是最先显示的 4.简写表名最好大写 5.解多表题的第一步，先搞清楚连接的外键名,并排序使其连接是一条线,并注明简写。简写要统一.还要注明外键含义

-- 检索选修了1002课程的学生成绩和对应的课程信息
select*
from sc A join course B on A.cno=B.cno
where A.cno='1002';

-- 练习：检索专业名为移动应用开发的学生学号，姓名，专业名
select*
from student A join specialty B on A.zno=B.zno
where B.z_name='移动应用开发';


-- 【多表查询】
-- 检索选修了李老师的课程的学生学号，姓名，班级，课程名，成绩,教师名
select A.sno,A.s_name,A.s_class,
			C.c_name,B.grade,C.c_teacher
from student A join sc B on A.sno=B.sno
							join course C on B.cno=C.cno
where C.c_teacher like'李%';
-- =>可以同时join on 多张表 2.两张不是直接外键连接的表要通过join on 多张表实现内连接 3.3多表连接直接join，join前面不需要写 4.name不一定是教师名，还可能是课程名 5.字符匹配是like 6.如果select 后跟太多，3个可换一行 7.最后检查要注意select后面有没有重复的 

-- 用where检索选修了‘java程序设计’这门课程的同学学号，姓名，课程名和成绩
select A.sno,A.s_name,C.c_name,
			B.grade
from student A
	join sc B on A.sno=B.sno
	join course C on B.cno=C.cno
where C.c_name ='java程序设计';
-- =>join直接对其会比较好

-- 用where-like检索选修了含Java字眼课程的同学学号，姓名，课程名和成绩
select A.sno,A.s_name,C.c_name,
			B.grade
from student A 
	join sc B on A.sno=B.sno
	join course C on B.cno=C.cno
where C.c_name like'%java%';

-- [1.2]内连接-- 自然连接 效果同select*from sc join course  on sc.sno=course.cno
select*
from sc 
 natural join course 
-- =>自然连接不用on

-- 自然连接 效果同select* from student A    join sc B on A.sno=B.sno    join course C on B.cno=C.cno
select* 
from student    
	natural join sc    
	natural join course 
	
-- [1.3]显示左表student中的全部记录及右表sc复合连接条件的记录
select* 
from student A   
	left join sc B on A.sno=B.sno
-- =>（以左为主，右边没有对应则显示null（直接join则只显示都有的），并会自动去掉重复字段

-- 查询所有的学生的信息，以及他们选修的课程号和课程成绩
select A.*,B.cno,B.grade
from student A   
	left join sc B on A.sno=B.sno
	
-- 练习：查询所有学生的课程和被学生选课的信息。显示：课程号，课程名，学号
select B.cno,C.c_name,B.sno
from course C   
	left join sc B on C.cno=B.cno

-- 查询所有学生的学号，姓名和选修的课程号和课程成绩（包括未选修的）  
	select A.cno,A.c_name,B.sno,B.grade
from course A left join sc B on A.cno=B.cno

select A.sno,A.s_name,B.cno,B.grade
from student A
	left join sc B on A.sno=B.sno

-- [1.4]右外连接同[1.3]
select* 
from student A   
	right join sc B on A.sno=B.sno
-- *************************************************************************

-- 【2】联合查询
-- 查询全校师生的姓名，输出显示'师生姓名'
select A.s_name from student A
union
select C.c_teacher from course C
-- =>联合是union

-- 同上(不去重）
select A.s_name from student A
union all
select C.c_teacher from course C


-- 【3】子查询
-- 仅查询曾经修过课程的学生信息
-- 写法1：join
select distinct A.*
from student A 
	join sc B on A.sno=B.sno
-- =>题目的意思是通过外键字段的不对应，筛选出所有对应的字段，并去掉第二次sc表中重复的
	
-- 写法2：in
select *
from student 
where sno in(select distinct sno 
					from sc)
-- =>in与 select 和 where连用，用于筛选student表中通过外键对应sc表的外键，取二者都有的值。2.语法where 外键字段，in（select 去重 外键字段 from 表）3.缩写后面一定要加.+字段

-- 练习：用in子查询所有选修过1002课程的学生信息
select *
from student 
where sno in(select distinct sno 
					from sc
					where cno='1002')
					
-- =>in的语法不变，所以这里的条件应该放在in里 2.两边连接的字段是sno

-- 用any子查询比任意 移动班学生年龄小的智能班学生信息
select *
from student 
where s_age<any(select s_age
					from student
					where zno='YD')
		and zno='ZN'
--  =>where 子查询 and是可以的 2.子查询可以引用自同一个表 3.移动班的映射还有zno 4.and和where并齐

-- 用all子查询比所有移动班学生年龄小的智能班学生信息
select *
from student 
where s_age<all(select s_age
					from student
					where zno='YD')
		and zno='ZN'
		
			
-- 综合练习：
-- 查询计算机学院开设的所有课程的选修平均分，按均分倒排
-- 显示：课程号，课程名，授课教师，平均分（保留两位）
SELECT C.cno,C.c_name,C.c_teacher,round(avg(grade),2)
from course C join sc B on C.cno=B.cno
where C.c_dept='计算机学院'
group by C.cno,C.c_name,C.c_teacher
order by avg(grade) desc
-- =>1.默认聚合函数前面的都是分组字段 2.where在最前面 3.只要两个表

-- 查询计算机学院开设的所有课程的选修平均分，仅显示平均分大于80的，按均分倒排
-- 显示：课程号，课程名，授课教师，平均分（保留两位）
SELECT C.cno,C.c_name,C.c_teacher,round(avg(grade),2)
from course C join sc B on C.cno=B.cno
where C.c_dept='计算机学院'
group by C.cno,C.c_name,C.c_teacher
	having avg(grade)>80
order by avg(grade) desc
-- =>分组的筛选用having
```

#### 



### 6.索引

```mysql
-- 创建一个图书馆数据库 library
create database library;
use library;

-- 建表book_1分别插入1.b_name varchar(50),  2.isbn char(17) primary key,  3.b_author varchar(50), 4.b_date date, 5.b_abs TEXT, 6.b_pub varchar(50), 并分别以index_原名称(去_) 分别建立1.普通索引，2.普通索引，带长度只对前20位建索引 3.唯一性索引isbn，设置降序 4.全文索引b_abs 5.多列索引：isbn和b_pub
create table book_1(
	b_name varchar(50),
	b_author varchar(50),
	isbn char(17) primary key,
	b_date date,
	b_abs TEXT,
	b_pub varchar(50),
	index index_name(b_name),
	index index_author(b_author(20)),
	unique index index_isbn(isbn desc),
	fulltext index index_abs(b_abs),
	index index_pub(isbn,b_pub)
);
-- wrong unique,author拼错
-- =>1.表内创建索引：索引类型 索引名(原字段名) 2.全文索引fulltext 3.限制字段长度不用加字段类型 4.升降序只能用在主键

-- 建表book_2，表外创建同上索引
create table book_2(
	b_name varchar(50),
	b_author varchar(50),
	isbn char(17) primary key,
	b_date date,
	b_abs TEXT,
	b_pub varchar(50)
	);
	create index index_name on book_2(b_name);
	create index index_author on book_2(b_author(20));
	create unique index index_isbn on book_2 (isbn desc);
	create fulltext index index_abs on book_2 (b_abs);
	create index index_pub on book_2(isbn,b_pub);
-- create index 索引名 on...

-- 建表book_3：修改表添加索引
create table book_3(
	b_name varchar(50),
	b_author varchar(50),
	isbn char(17) primary key,
	b_date date,
	b_abs TEXT,
	b_pub varchar(50)
	);

alter table book_3 add index index_name(b_name);
alter table book_3 add index index_author(b_author(20));
alter table book_3 add unique index index_isbn(isbn desc);
alter table book_3 add fulltext index  index_abs(b_abs);
alter table book_3 add index index_pub(isbn,b_pub);
-- =>只要alter table 语法 alter table 表名 add 索引类型 索引名（字段名）
	
-- 查看book_1索引(设计表)
show index from book_1 
-- =>有一个from

-- 用建表语句查询查看book_2索引
show create table book_2;

-- 删除book_1的索引index_name
show index from book_1 
drop index index_name on book_1;
show index from book_1 
-- =>删除索引用的是drop index,选择表用的是on

-- 用修改表方式删除book_1的索引index_isbn
alter table book_1 drop index index_isbn;
-- =>1.alter table 也可以实现删除2.drop后面也要跟index

-- 删除book_1主键
alter table book_1 drop primary key;
show index from book_1;

```

---







### 7.视图

```mysql
-- 第八章 视图 view
视图的优势：独立性

update v_zn_stu
set s_sex='女'
where s_name='王五'

update student
set s_class='智能2131'
where s_name='黄渤'


use schoolinfo;

-- 删除所有视图
-- 使用schoolinfo数据库的course sc specialty student 四张表
use schoolinfo;

-- 创建schoolinfo表移动班学生学号，姓名，班级的视图 名称：v_yd_stu
desc student;

create view v_yd_stu as
	select sno,s_name,s_class
	from student
	where s_class like '移动%'
;

-- 创建显示智能班学生学号，姓名，年龄的视图 名称v_zn_stu
create view v_zn_stu as
	select sno,s_name,s_age
	from student
	where s_class like '智能%'
;

-- 将上表的字段指定为新的字段名num，sex和age
drop view v_zn_stu;
create view v_zn_stu (num,sex,age) as
	select sno,s_sex,s_age
	from student
	where s_class like '智能%'
;
-- =>视图显示新的字段名在as前面加 2.要先删除才能在=再创建相同名字的视图 3.删除视图时drop

-- 创建视图v_grade,显示sc和score表的的学号，课程名，成绩，学分
desc course;
create view v_grade as
	select A.cno,A.c_name,B.grade,A.c_credit
	from sc B join course A on A.cno=B.cno
;
-- =>课程时course

-- 查看当前数据库的所有视图
select* 
from information_schema.views
where table_schema='schoolinfo'
-- =>查询的是所有 2.views表里面还得选中的table_schema字段中的schoolinfo 3.view有s

-- 也可以
show tables;

-- 查看v_yd_stu视图结构
desc v_yd_stu;

-- 查看v_yd_stu视图的定义
show create view v_yd_stu;

-- 查看v_yd_stu视图的内容
select*
from v_yd_stu;
-- =>视图和数据表是同一个级别

-- 删除v_yd_stu视图
drop view v_yd_stu;

-- 修改视图v_zn_stu的定义，再查询student表性别和班级，条件添加年龄大于20
alter view v_zn_stu as 
	select sno,s_sex,s_age,s_name,s_class
	from student
	where s_class like '智能%'
				and s_age>20
;
select*
from v_zn_stu;

-- 在v_zn_stu上把王五 女变男，并观察基表的变化
update v_zn_stu
set s_sex='男'
where s_name='王五'

select*from v_zn_stu;
select*from student;
-- =>更新视图和表，直接把表名写在update后面


-- 把student表内的黄渤智能2131改成2151,并观察视图的变化
update student
set s_class='智能2151'
where s_name='黄渤'

select*from v_zn_stu;
select*from student;

-- 视图很多时候无法更新,说3种情况
多表，聚合，计算列



-- 模仿v_zn_stu创建表v_zn_check，使更新的数据不满足where条件时，报错。试把黄渤年龄改为10
show create view v_zn_stu;
CREATE ALGORITHM=UNDEFINED DEFINER=`root`@`localhost` SQL SECURITY DEFINER VIEW `v_zn_check` AS select `student`.`sno` AS `sno`,`student`.`s_sex` AS `s_sex`,`student`.`s_age` AS `s_age`,`student`.`s_name` AS `s_name`,`student`.`s_class` AS `s_class` from `student` where ((`student`.`s_class` like '智能%') and (`student`.`s_age` > 20)) with check option
-- =>check后面是 option  前面是with

 
```

---







### 8.存储过程

```mysql
-- 第九章 存储过程和函数
use schoolinfo;
删除全部函数


-- 自定义变量pi=3.1415926 并查询(以下都查询)
set @pi=3.1415926;
select @pi;
-- =>定义的首句是set 2.变量名前要加@ 3.不能同时定义变量并查询


-- 从sc表中取grade的最大值，并定义给max_grade
select max(grade) into @max_grade
from sc
select @max_grade
-- =>表中值赋给变量 在select语句中用into


-- 从sc表中取课程号（cno）为1001的grade的最小值，并定义给min_grade
select min(cno) into @mmin_grade
from sc
where cno='1001'
select @max_grade


-- 查询所有的用户的自定义的变量名(会话变量只在当前会话中有效)
select*
from performance_schema.user_variables_by_thread;
-- =>表在performance的倒数第四章表


-- 将 select * from student 改为存储过程(封装过程)，命名为p_01并调用
delimiter $$
create procedure p_01()
	begin
			select *
			from student;
	end $$
delimiter ;

call p_01();
#=>首句delimiter  $$ 2.存储过程因为是procedure 3.begin是在create下面 4.最后再改为;结尾 5.调用是ca 函数名要加（）


-- 用存储过程p_02返回姓名=张一的所有信息
delimiter $$
create procedure p_02()
	begin
			select*
			from student
			where s_name='张一';
	END $$
delimiter ;

call p_02()
#=> end后面要加结束符


-- 查看存储过程p_01的定义
show create procedure p_01;

CREATE DEFINER=`root`@`localhost` PROCEDURE `p_01`()
begin
			select *
			from student;
	end


-- 删除p_01
drop procedure p_01


-- 创建存储过程p_03,入参姓名sname,通过s_name返回该学生的全部数据
delimiter $$
create procedure p_03(in sname varchar(20))
	begin
			select *
			from student
			where s_name=sname;
	END $$
delimiter ;

call p_03('张一')
#=>入参的定义是in 入参名 数据类型

-- 创建存储过程p_04,入参班级号class，输入实参智能2111，返回的学号sno，姓名s_name，年龄s_age
-- 写错要先drop函数
delimiter $$
create procedure p_04(in class varchar(20))
	begin
		select sno,s_name,s_age
		from student
		where s_class=class;
	end $$
delimiter ;

call p_04('智能2111')


-- 创建存储过程p_04,入参是sname 回参ssno，返回学号sno的值，输入张一，并将结果封装成可调用的变量studentsno查询
delimiter $$
create procedure p_04(in sname varchar(20),out ssno varchar(20))
	BEGIN
			select sno into ssno
			from student
			where s_name=sname;
	end $$
delimiter ;

call p_04('张一',@studentsno)
select @studentsno
#=>out对应的值要用into注明 2.封装成变量是在函数名（，写上变量名） 3.调用变量是select
	

-- 创建inout类型的存储过程p_05，入参和回参是同一个变量grade，,将grade的值提高10%封装成可调用的变量magrade，赋值80并查询
delimiter $$
create procedure p_05(inout grade float)
	begin
			set grade=grade*1.1;
	end $$
delimiter ;

set @magrade=80
call p_05(@magrade)
select @magrade;
#=>修改一个自定义变量直接set 2.封装一个调用变量的函数要先定义变量，在把变量变成实参 3.inout只能输入变量的入参 4.数值型直接用float


-- 从sc表对成绩grade进行判断，小于60分不及格，其余为及格，为结果设置别名是否及格
select *,
	if(grade<60,'不及格' ,'及格') as '是否及格'
from sc
#=>第一句是查询全部 2.否则不及格不需要写or。1写在,后面。0写在1的，后面 2.if判断是写在select语句上的


-- 对成绩分组，优秀：100-90，良好90-80，中等80-70，及格70-60，(后的都包含）60以下不及格 为结果设置别名 等第
select*,
	case
		when grade>=90 then '优秀'
		when grade<90 and grade>=80 then '良好'
		when grade<80 and grade>=70 then '中等'
		when grade<70 and grade>=60 then '及格'
			else '不及格'
		end as '等第'
from sc;
#=>要实现分组在if语句的基础上，把if改成case-when-end,1改成then 2.优秀：100-90可以直接写成>=90 3.else最好缩进一格
```

---







### 9.用户权限

```mysql
-- 第十章 用户权限
-- 查看当前所有的的用户信息，查询ip地址和用户名
select host,user
from mysql.user
-- =>用户信息保存在mysql的user表里

-- 创建三个个个人普通本地用户 zhangsan,scf和scf_1 密码123456
create user 'zhangsan'@'localhost' identified by '123456';
create user 'scf'@'localhost' identified by '123456';
drop user 'scf_1'@'localhost';
create user 'scf_1'@'localhost' identified by '123456';

-- 修改zhangshan用户名为lisi
rename user 'zhangsan'@'localhost' to 'lisi'@'localhost';
-- =>修改用户名是rename

-- 同上修改密码888888
alter user 'lisi'@'localhost' identified by '888888';

-- 删除用户lisi
drop user 'lisi'@'localhost';
-- =>删除用户是drop

-- 为scf赋权：可以查询所有数据库的所有表 
grant select on *.* to 'scf'@'localhost';
-- =>因为权限是给用户 所有是to 2.grant不用user 3.题目赋权的内容是查询

-- 赋给上述scf所有权限
grant all on *.* to 'scf'@'localhost';
-- =>所有权限是all

-- scf_1赋权：schoolinfo.student表 查询权限
grant select on schoolinfo.student to 'scf_1'@'localhost';

-- scf_1赋权，library的所有表的查询、插入、更新、删除权限
grant insert,delete,update,select on library.* to 'scf_1'@'localhost';
-- =>多个权限间要用,连接 2.即便用修改权限，修改表内数据也好符合字段类型

-- (1) 通过表查询全局授权情况
select*
from mysql.user

-- (2) 数据库级别
select*
from mysql.db

-- (3) 数据表级别
select*
from mysql.tables_priv

-- (4) 数据列级别
select*
from mysql.columns_priv;
-- =>列是colu m n

-- 撤销 scf 的全部权限
revoke  all on *.* from 'scf'@'localhost';
-- =>撤销是ke 2.没有user

-- =>撤销scf_1在school.student的select权限
revoke select on *.* from 'scf_1'@'localhost';


```







### 10.期末复习



```mysql
##将文件拖入navicat，并删除数据库exam和本地用户testuser
drop database exam
drop user 'testuser'@'localhost'
#=> 创建和删除是相对的

#5.	查看系统中所有库
show databases

#7.	重新建库并选择exam
create database exam
use exam

#8.	建表，部门表dept（d_id, d_name, manager, address）
create table dept(
	d_id varchar(20) primary key,
	d_name varchar(20),
	manager varchar(20),
	address varchar(20) 
)

#9.	建表，员工表emp(e_id自增, e_name, sex, age, enroll_date, d_id) 外键 2.创建表无：且每段要加，
create table emp(
	e_id int(20) primary key auto_increment,
	e_name varchar(20),
	sex varchar(20),
	age varchar(20),
	enroll_data date,
	d_id varchar(20),
	constraint fk_did foreign key (d_id) references dept(d_id)
)
#=> 插入类型应根据插入类型修正，entroll_data是登记日期的意思 2.创建外键的首句是constraint，是约束的意思， 建表逻辑是约束 外键名 外键（要约束的本表字段） 参考 其他表（字段） 3.自增长是auto_increment,写在主键后面 4.日期类型是te 5.自增长和外键字段都得是主键，自增长还得是数值类型 6.外键还得在约束前先创建相同字段和字长

#10.	复制表，dept_1
create table dept_1 like dept
#=>赋值表的首句是create

#11.	删除表dept_1
drop table dept_1

#12.	修改表dept，修改manager为d_manager
alter table dept change manager d_manager varchar(20)
#=>修改表的首局是alter 关键词change 2.新字段要加字段类型 3.新字段名写在change后面

#13.	修改表dept，在d_name后增加列testcol int not null
alter table dept add testcol int not null after d_name
#=>也可以用列column

#14.	修改表dept，删除testcol列
alter table dept drop testcol

#15.	查看dept的表结构
desc dept
#desc是专用于表的，所以不需要加table

#16.	查看dept的建表语句
show create table dept

#17.	查看数据库中所有的表
show tables

#18.	Dept数据插入
/*
100,'财务部','张三', '北京'
200,'销售部','丽丽', '上海'
300,'人力部','李四', '南京'
400,'市场部','李二', '南宁'
*/
insert into dept values
('100','财务部','张三', '北京'),
('200','销售部','丽丽', '上海'),
('300','人力部','李四', '南京'),
('400','市场部','李二', '南宁')
#=>insert into 后面加表名 值

#19.	Emp数据插入
/*
'Alex','男',30,2015-01-01,100
'Emy','女',26,2014-08-02,100
'王二','男',31,2012-01-01,200
'小明','男',24,2017-11-01,300
'王三','男',30,2014-01-01,200
'陈一','女',26,2015-08-22,100
'王六','男',39,2010-01-01,200
'赵五','女',22,2019-08-01,400
'赵五','女',25,2013-05-01,400
'赵五','女',28,2015-06-01,400
'赵六','女',22,2019-08-01,400
*/
insert into emp(e_name, sex, age, enroll_data, d_id) values
('Alex','男',30,'2015-01-01',100),
('Emy','女',26,'2014-08-02',100),
('王二','男',31,'2012-01-01',200),
('小明','男',24,'2017-11-01',300),
('王三','男',30,'2014-01-01',200),
('陈一','女',26,'2015-08-22',100),
('王六','男',39,'2010-01-01',200),
('赵五','女',22,'2019-08-01',400),
('赵五','女',25,'2013-05-01',400),
('赵五','女',28,'2015-06-01',400),
('赵六','女',22,'2019-08-01',400)
#=> 要插入特定字段是在表名后面加的 2.日期也是字符必须要加

#20.	更新dept表，市场部经理更名张小五
update dept
set d_manager = '张小五'
where d_name = '市场部'
#=>update配合是set 2.update后面跟的是表名 3.update set 不需要配合select from使用 4. update可以配合where使用 5.上面已经把manager 修改为 d_manager

#21.	删除emp表中赵六的记录
delete from emp
where e_name = '赵六'
#=>删除是elete

#22.	查看dept表的所有数据
select*
from dept

#24.	查看去重后的员工姓名
select distinct e_name
from emp

#25.	查看女员工的姓名和入职月数
select e_name, enroll_data
from emp
where sex = '女'

#26.	查看人力部的员工姓名和年龄
select b.e_name, b.age
from dept a right join emp b on a.d_id = b.d_id
where a.d_name = '人力部'
#=>外键只适用连接表，而不能用做查询的条件 2.使用连接时，应考虑左右连接 3.字段名唯一时，可以定义了缩写但不要缩写

#27.	查看地址以“南”开头的部门的部门名，员工人数
select a.d_name, count(b.e_name) as '员工数量'
from dept a join emp b on a.d_id = b.d_id
where a.address like '南%'
group by a.d_name
#=>count是聚合函数,出现两个以上不同字段出现就要进行分组 2.可以count(distinct b.e_name)单因为员工的名字可能相同不需要去重 3.字符串匹配得用like

#28.	查看每个部门的员工的平均年龄和最早入职时间
select d_id,
				round(avg(age),3) as '平均年龄', 
				min(enroll_data) as '最早入职时间'
from emp
group by d_id
#=>保留小数是round 2.默认平均数保留三位小数 3.要显示每个部门的名称 4.对分组条件添加条件才需要having 5.部门可以直接通过部门id来代替，这样就看单表查询

#29(超纲.分组之后内部的排序）分别查看男女员工中的最年轻员工的姓名，年龄，入职时间，按入职倒序排序

#29	分别查看女员工中的最年轻员工的姓名，年龄，入职时间
select e_name, age, enroll_data
from emp
where sex = '女'
order by age
limit 0,1
#=>筛选出首列用limit(假尾巴) 2.order by默认从上往下慢慢变大

#30.	查看每个部门中2014年以后入职的员工的人数，最小年龄，显示大于2人的部门信息，按人数倒序排序。
select d_id, count(e_name) as '2014年以后入职员工数量', min(age) as '最小年龄'
from emp 
where enroll_data > '2014-1-1'
group by d_id
	having count(e_name) > 2 
order by count(e_name) desc
#=>日期的月可以是1位数 2.要写having

#31.	查看最年长的三个男员工信息
select*
from emp
where sex = '男'
order by age desc
limit 0,3

#32.	显示所有的经理名和员工名
select d_manager 
from dept
union
select e_name
from emp
#=>去重联合时union，反之union all

#33.	创建男员工员工号，姓名，年龄，部门名的视图view1
create view view1 as
	select e_id, e_name, age, d_name
	from dept a join emp b on a.d_id = b.d_id
	where sex = '男'
#=>view 后面那个数是 表名as 2.那个自增长的值是员工号 3.查看视图是通过表和show tables

#34.	创建丽丽管理的员工信息的视图view2
create view view2 as
	select b.*
	from dept a join emp b on a.d_id = b.d_id
	where d_manager = '丽丽'
#=>显示一张表的全部查询是表名.* 2.查询多表的两张表只能用联合查询

#35.	查询丽丽理的员工信息的视图的定义语句
show create view view2

#36.	删除丽丽管理的员工信息的视图
drop view view2

#37.	在dept的d_id上创建唯一性索引，倒排
alter table dept add unique index index_did(d_id desc)
#=>创建索引的三种方式，分别是在表内：索引名，索引类型，索引来自 修改表：索引类型，索引名(索引来自) 创建表 索引类型 索引名  on 索引来自 

#38.	在emp的入职日期上创建普通索引
create index index_enroll on emp(enroll_data)

#39.	查看所有的索引
show index from dept
show index from emp
#=> 查看所有的索引是 show …… from

#40.	删除在emp的入职日期上的索引
drop index index_enroll on emp
#=>删除配合的是 on 2.要连索引类型一起写上去 3.索引名是先写index

#41.	删除dept的主键
alter table dept drop primary key
#=>删除主键只能用修改的方式 2.删除肯定有drop

#42.	以root登录，创建用户testuser，密码xxx
create user 'testuser'@'localhost' identified by 'xxx'

#=>create 后面跟的是user @前是用户名，后localhost。密码前面是identied 2.删除用户是

#43.	修改testuser，密码为123456
alter user 'testuser'@'localhost' identified by '123456'
#=>修改用户是alter user

#44.	查看系统中所有的用户
select*
from mysql.user
#=>查看私有用户是查询mysql.user这张表

#45.	为testuser赋权，exam库的emp表，select和update权限
grant select,update on exam.emp to 'testuser'@'localhost'
#=>赋权第一句是grant 2.权限包括 update delete insert select all on 库.表 to 用户 3.权限的增变成了更新 改变成了插 4.权限与权限间用，隔开 5.不包括所有数据库的权限，只能用数据表级别的权限来查询

#46.	撤销testuser的exam库的emp表的select权限
revoke select  exam.emp from 'testuser'@'localhost'


```



















